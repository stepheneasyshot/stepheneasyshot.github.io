{"posts":[{"title":"Android常用调试命令","content":"Windows常用命令 目录跳转相关 cd \\ 跳转当前盘根目录 cd users/8888/Desktop 跳转当前盘内的某个文件夹目录 cd /d E:Software 使用/d参数跳转其他盘的某个文件夹 cd /? 获取命令帮助 dir 相当于ls，查看当前目录下的子文件 终止操作 某个任务卡住的情况下，直接使用 Ctrl + C 结束等待 清屏 cls 清空当前屏幕上的内容 注意清空后仍然可以使用上下键使用之前的命令 重定向输出 将原本输出到命令窗口的内容，转存到文件中，如jstack 12912 &gt;d:/s.txt 打印线程到指定文件。 cmd &gt; 重定向输出并覆盖源文件。 echo hello &gt; c:\\1.txt // 1.txt的文件内容先被清空，然后写入hello。 cmd &gt;&gt; 重定向输出追加到文件末尾 echo hello &gt;&gt;c:\\1.txt // 在1.txt文件末尾加上hello 增删改查 md derectoryName 创建文件夹 rd derectoryName 删除文件夹 copy 路径\\文件名 路径\\文件名 ： 把一个文件拷贝到另一个地方 move 路径\\文件名 路径\\文件名 ： 把一个文件移动（就是剪切+复制）到另外一个地方 del 文件名 //这个是专门删除文件的，不能删除文件夹 网络调试 ping ip(主机名) //用来测试某个网络是否畅通 Linux通用命令 ls 列出当前工作目录下的所有文件/文件夹的名称。可以增加路径，查看制定目录下的文件。 参数： • -l：表示list，表示以详细列表的形式进行展示。另外-lh可以以可读性较好的形式来展示； • -a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹） pwd 获取当前所处的目录 cd 切换目录。 cd .. 返回到父目录 cd 绝对路径 可以从任意目录跳转，例如在system文件夹，cd /sdcard可以跳转到根目录的sdcard下面 cp 复制文件。cp 路径/文件名 路径/[文件名] mv 移动文件夹，用法同cp rm 删除文件，rm 文件名 参数： • -f：force，强制删除，不提示是否删除 • -r：表示递归 -r表示递归删除，把子目录里的文件全部删除，才能删除目标目录 强删文件夹：rm -rf 文件夹名 ##cat 打开一个文件，展示文件内容 重定向输出 这里和上文windows类似，将原来在窗口中输出的内容，输出到文件中，且若此文件不存在，会自动创建一个。 输出内容写入 &gt; 擦除源文件内容，写新内容到文件 输出内容追加 &gt;&gt; 输出追加文件末尾 ##mkdir mkdir dir创建文件夹 touch touch file创建文件 注意可以同时创建多个文件，touch 123.txt 456.txt Vim操作 vim file 使用vim打开一个文件 vim在android平台上其实是无法使用的，但是在桌面级或者服务器端都很重要，还是稍微记录一下。 VIM的模式 Vim共有以下6种常见的模式： 普通模式（Normal mode）： 这是使用Vim打开一个文件时，Vim的默认模式。在普通模式下，您可以使用各种命令来移动光标、删除、复制、粘贴和其他编辑操作。 插入模式（Insert mode）： 在插入模式下，您可以像在其他文本编辑器中一样输入和编辑文本。按下键盘上的插入键（通常是 i 、a、o或 Insert 键）即可进入插入模式。编辑完成后，使用esc退出插入模式，输入:加字母表示退出，:q是退出，:w是保存，:wq是保存后退出，:q!表示强行退出。 可视模式（Visual mode）： 可视模式允许您选择、高亮并操作文本块。您可以使用各种移动命令来选择文本。在普通模式下敲击键盘的 v 键即可进入可视模式，然后移动光标就可以选中一块文本，常用来完成文本的复制、粘贴、删除等操作。 替换模式（Replace mode）： 在替换模式下，您可以直接替换光标所在位置的字符。在普通模式下敲击键盘上的 R 键即可进入替换模式。 命令行模式（Command-line mode）： 命令行模式允许您执行各种命令。您可以在命令行中输入命令，例如保存文件、退出Vim、显示行号等。在普通模式下敲击 : 键即可进入命令行模式。 Ex 模式（Ex mode）： Ex 模式是Vim的可选模式，它是命令行模式的扩展。Ex 模式提供了更多高级命令和编辑选项。可以一次执行多个命令。 Vim的各种工作模式可以通过不同的键进行切换，均需使用Esc键返回到普通模式。一般大多数情况使用普通和插入模式即可。 ADB操作 核心内容。 Windows段，shell外部的操作一般有： adb devices 查看当前连接上的所有可调试设备，包括AS的虚拟机。用来查看是否成功连接上设备。 如有多个设备，在adb后使用-s serialnumber 参数来区分不同的设备. adb shell 进入设备的shell命令行工具界面，Android版的terminal，这个打开的shell的权限一般和系统应用权限相同。指令集大多与linux相同。 adb root 这个指令只适合装载userdebug版本或者eng版本的设备，使目前的调试终端具有root权限，可以更方便地调试设备，修改系统关键文件和环境。如果要恢复到非root状态，可以使用adb unroot。 adb remount 'adb remount' 的作用相当于 'adb shell mount -o rw,remount,rw /system'，重新挂载system分区，实现对system分区重新挂载，可以对里面的文件进行增删修改。 adb kill-server 终结当前的调试服务端。 指定 adb server 的网络端口 命令： adb -P start-server 默认端口为 5037。 无线调试 首先电脑和手机需要连接上同一个局域网内. 键入adb tcpip 5555 ，打开设备的一个端口5555. 进入android shell里输入ifconfig，查看设备IPV4地址ipaddr. 再断开有线连接，输入adb connect ipaddr:port，即可开启无线调试. 投屏 可以使用最新版AS即可，自带投屏，Running Devices. 想要清晰度更高可以下载screen copy工具： https://github.com/Genymobile/scrcpy adb shell内操作 应用管理 查看已安装应用 adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 无参数筛选就是所有应哟，上面的一众参数为： -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 最后的过滤器表示包名包含 FILTER 字符串 过滤器使用： 比如要查看包名包含字符串 mazhuang 的应用列表，命令： adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： adb shell pm list packages | grep mazhuang 安装应用 adb install [-lrtsdg] &lt;path_to_apk&gt; -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 --abi abi-identifier 为特定 ABI 强制安装 apk，abi-identifier 可以是 armeabi-v7a、arm64-v8a、v86、x86_64 等。 返回字段为Success表示安装成功。 这个操作实际上分三步走的： 1. push apk 文件到 /data/local/tmp。 2. 调用 pm install 安装。 3. 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用 adb uninstall [-k] &lt;packagename&gt; packagename表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 清除缓存： adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 查看前台Activity和Service adb shell dumpsys activity activities | grep mResumedActivity 输出示例： mResumedActivity: ActivityRecord{8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42} 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 在 Windows 下以上命令可能不可用，可以尝试 adb shell dumpsys activity activities | findstr mResumedActivity 或 adb shell &quot;dumpsys activity activities | grep mResumedActivity&quot;。 adb shell dumpsys activity services [&lt;packagename&gt;] &lt;packagename&gt; 参数不是必须的，指定 &lt;packagename&gt; 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。 &lt;packagename&gt; 不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。 查看一个app的详细信息 adb shell dumpsys package &lt;packagename&gt; 输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 只查看安装路径 adb shell pm path &lt;PACKAGE&gt; 应用交互 拉起Activity adb shell am start [options] &lt;INTENT&gt; 一般使用-n参数指定一个具体的Activity。 例如： adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity 还可以不指定Activity，只指定包名，默认开启MainActivity: adb shell monkey -p &lt;packagename&gt; -c android.intent.category.LAUNCHER 1 拉起服务Service adb shell am startservice [options] &lt;INTENT&gt; 例如： adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 相应有停止服务： adb shell am stopservice [options] &lt;INTENT&gt; 发送广播 adb shell am broadcast [options] &lt;INTENT&gt; 例如，向所有组件广播 BOOT_COMPLETED： adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 又例如，只向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 广播 BOOT_COMPLETED： adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机： android.net.conn.CONNECTIVITY_CHANGE 网络连接发生变化 android.intent.action.SCREEN_ON 屏幕点亮 android.intent.action.SCREEN_OFF 屏幕熄灭 android.intent.action.BATTERY_LOW 电量低，会弹出电量低提示框 android.intent.action.DREAMING_STARTED 系统开始休眠 android.intent.action.DREAMING_STOPPED 系统停止休眠 android.intent.action.WALLPAPER_CHANGED 壁纸发生变化 android.intent.action.MEDIA_UNMOUNTED卸载外部介质 android.intent.action.MEDIA_MOUNTED挂载外部介质 android.os.action.POWER_SAVE_MODE_CHANGED省电模式开启 强制停止应用 命令： adb shell am force-stop &lt;packagename&gt; 命令示例： adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 收紧内存 命令： adb shell am send-trim-memory &lt;pid&gt; &lt;level&gt; pid: 进程 ID level: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE 命令示例： adb shell am send-trim-memory 12345 RUNNING_LOW 表示向 pid=12345 的进程，发出 level=RUNNING_LOW 的收紧内存命令。 电脑和设备互传文件 拉取设备里的文件 adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： adb pull /sdcard/sr.mp4 ~/tmp/ 往设备里推送文件 adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： adb push ~/sr.mp4 /sdcard/ 模拟按键输入 adb shell input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...] 比如使用 adb shell input keyevent 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 模拟滑动 如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本 在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： adb shell input text hello 现在 hello 出现在文本框了。 查看日志 Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 按级别过滤 adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 按tag过滤 &lt;filter-spec&gt; 可以由多个 &lt;tag&gt;[:priority] 组成。 比如，命令： adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 清空日志 adb logcat -c 查看设备信息 型号 adb shell getprop ro.product.model 输出示例： Nexus 5 电池状况 adb shell dumpsys battery 输出示例： Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率 命令： adb shell wm size 输出示例： Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 如果使用命令修改过，那输出可能是： Physical size: 1080x1920 Override size: 480x1024 表明设备的屏幕分辨率原本是 1080px * 1920px，当前被修改为 480px * 1024px。 屏幕密度 命令： adb shell wm density 输出示例： Physical density: 420 该设备屏幕密度为 420dpi。 如果使用命令修改过，那输出可能是： Physical density: 480 Override density: 160 表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。 显示屏参数 命令： adb shell dumpsys window displays 输出示例： WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 Android 系统版本 命令： adb shell getprop ro.build.version.release 输出示例： 5.0.2 IP 地址 每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。 命令： adb shell ifconfig | grep Mask 输出示例： inet addr:10.130.245.230 Mask:255.255.255.252 inet addr:127.0.0.1 Mask:255.0.0.0 那么 10.130.245.230 就是设备 IP 地址。 在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP： adb shell ifconfig wlan0 输出示例： wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast] 或 wlan0 Link encap:UNSPEC inet addr:10.129.168.57 Bcast:10.129.175.255 Mask:255.255.240.0 inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:496520 errors:0 dropped:0 overruns:0 frame:0 TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:3000 RX bytes:116266821 TX bytes:8311736 如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）： adb shell netcfg 可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。 Mac 地址 命令： adb shell cat /sys/class/net/wlan0/address 输出示例： f8:a9:d0:17:42:4d 这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 adb shell netcfg 命令来查看。 CPU 信息 命令： adb shell cat /proc/cpuinfo 输出示例： Processor : ARMv7 Processor rev 0 (v7l) processor : 0 BogoMIPS : 38.40 processor : 1 BogoMIPS : 38.40 processor : 2 BogoMIPS : 38.40 processor : 3 BogoMIPS : 38.40 Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt CPU implementer : 0x51 CPU architecture: 7 CPU variant : 0x2 CPU part : 0x06f CPU revision : 0 Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree) Revision : 000b Serial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息 命令： adb shell cat /proc/meminfo 输出示例： MemTotal: 1027424 kB MemFree: 486564 kB Buffers: 15224 kB Cached: 72464 kB SwapCached: 24152 kB Active: 110572 kB Inactive: 259060 kB Active(anon): 79176 kB Inactive(anon): 207736 kB Active(file): 31396 kB Inactive(file): 51324 kB Unevictable: 3948 kB Mlocked: 0 kB HighTotal: 409600 kB HighFree: 132612 kB LowTotal: 617824 kB LowFree: 353952 kB SwapTotal: 262140 kB SwapFree: 207572 kB Dirty: 0 kB Writeback: 0 kB AnonPages: 265324 kB Mapped: 47072 kB Shmem: 1020 kB Slab: 57372 kB SReclaimable: 7692 kB SUnreclaim: 49680 kB KernelStack: 4512 kB PageTables: 5912 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB CommitLimit: 775852 kB Committed_AS: 13520632 kB VmallocTotal: 385024 kB VmallocUsed: 61004 kB VmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 硬件与系统属性 设备的更多硬件与系统属性可以通过如下命令查看： adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： ro.build.version.sdk SDK 版本 ro.build.version.releaseAndroid 系统版本 ro.build.version.security_patchAndroid 安全补丁程序级别 ro.product.model型号 ro.product.brand品牌 ro.product.name设备名 ro.product.board处理器型号 ro.product.cpu.abilistCPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled是否支持 OTG dalvik.vm.heapsize每个应用程序的内存上限 ro.sf.lcd_density屏幕密度 ro.build.id=GRI40版本ID ro.build.display.id=GRJ22版本号 ro.build.version.incremental=eng.buildbot.20110619.060228版本增量 ro.build.version.sdk=10sdk版本 ro.build.version.codename=REL版本代号 ro.build.version.release=2.3.4Android 2.3.4系統无需修改，也可改为3.0装装B ro.build.date=Sun Jun 19 06:02:58 UTC 2011制作者制作的时间，可修改2011年X月X日 某某某制作 ro.build.date.utc=0 ro.build.type=user ro.build.user=buildbot ro.build.host=bb1 ro.build.tags=test-keys ro.product.model=HTC Wildfire HTC内部手机代号也就是手机名，改为你想改的名字 ro.product.brand=htc_wwe 手机品牌，改为中国山寨机 ro.product.name=htc_buzz 手机正式名称，改为你想改的名字 ro.product.device=buzz 采用的设备，改为China G8 ro.product.board=buzz 采用的处理器，改为China 800.8Ghz ro.product.cpu.abi=armeabi-v6j cpu的版本 ro.product.cpu.abi2=armeabi cpu的品牌 ro.product.manufacturer=HTC 手机制造商，改为中国智造 ro.product.locale.language=en 手机默认语言，把en改为zh ro.product.locale.region=US 地区语言，美国毛多呀美国，干掉US改为CN ro.wifi.channels=WIFI连接的渠道 ro.board.platform=msm7k主板平台 ro.build.product=buzz建立产品 ro.build.description=passion-user 2.3.3 GRI40 102588 release-keys用户的KEY ro.build.fingerprint=google/passion/passion:2.3.3/GRI40/102588:user/release-keys机身码的啥玩意 注一： 一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试： adb shell cat /system/build.prop | grep ro.product.cpu.abi 示例输出： ro.product.cpu.abi=armeabi-v7a ro.product.cpu.abi2=armeabi 查看/修改序列号 查看命令： adb get-serialno 或： adb shell getprop sys.serialno 修改序列号： 通常安卓系统正常流程需要修改 cmdline中的参数，可以通过命令查看cmdline参数： adb shell cat /proc/cmdline 显示： storagemedia=emmc androidboot.mode=emmc androidboot.dtbo_idx=0 androidboot.slot_suffix= androidboot.serialno=9501a97c59fe092 console=ttyFIQ0 androidboot.baseband=N/A androidboot.wificountrycode=US androidboot.veritymode=enforcing androidboot.hardware=rk30board androidboot.console=ttyFIQ0 firmware_class.path=/vendor/etc/firmware init=/init rootwait ro init=/init root=PARTUUID=af01642c-9b84-11e8-9b2a-234eb5e198a0 loop.max_part=7 androidboot.selinux=permissive buildvariant=userdebug earlyprintk=uart8250,mmio32,0xff690000 swiotlb=1 kpti=0 bt_type=4 修改设置 注： 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。 修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。 分辨率 命令： adb shell wm size 480x1024 表示将分辨率修改为 480px * 1024px。 恢复原分辨率命令： adb shell wm size reset 屏幕密度 命令： adb shell wm density 160 表示将屏幕密度修改为 160dpi。 恢复原屏幕密度命令： adb shell wm density reset 显示区域 命令： adb shell wm overscan 0,0,0,200 四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。 恢复原显示区域命令： adb shell wm overscan reset 关闭 USB 调试模式 命令： adb shell settings put global adb_enabled 0 恢复： 用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。 允许/禁止访问非 SDK API 允许访问非 SDK API： adb shell settings put global hidden_api_policy_pre_p_apps 1 adb shell settings put global hidden_api_policy_p_apps 1 禁止访问非 SDK API： adb shell settings delete global hidden_api_policy_pre_p_apps adb shell settings delete global hidden_api_policy_p_apps 不需要设备获得 Root 权限。 命令最后的数字的含义： 0 禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。 1 仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。 2 禁止调用深灰名单和黑名单中的接口。 3 禁止调用黑名单中的接口，但允许调用深灰名单中的接口。 实用功能 屏幕截图 截图保存到电脑： adb exec-out screencap -p &gt; sc.png 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法： 先截图保存到设备里： adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数: -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 录制屏幕 录制屏幕以 mp4 格式保存到 /sdcard： adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： --size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 --bit-rate RATE 视频的比特率，默认是 4Mbps。 --time-limit TIME 录制时长，单位秒。 --verbose 输出更多信息。 重新挂载 system 分区为可写 注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 adb shell su 查看当前分区挂载情况。 命令： mount 输出示例： rootfs / rootfs ro,relatime 0 0 tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0 devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0 proc /proc proc rw,relatime 0 0 sysfs /sys sysfs rw,seclabel,relatime 0 0 selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0 debugfs /sys/kernel/debug debugfs rw,relatime 0 0 none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0 none /acct cgroup rw,relatime,cpuacct 0 0 none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0 none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0 tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0 tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0 none /dev/memcg cgroup rw,relatime,memory 0 0 none /dev/cpuctl cgroup rw,relatime,cpu 0 0 none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0 none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0 none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0 /dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 /dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0 /dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0 /dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0 /dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0 /dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 /dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： /dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 重新挂载。 命令： mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码 注：需要 root 权限。 命令： adb shell su cat /data/misc/wifi/*.conf 输出示例： network={ ssid=&quot;TP-LINK_9DFC&quot; scan_ssid=1 psk=&quot;123456789&quot; key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893 } network={ ssid=&quot;TP-LINK_F11E&quot; psk=&quot;987654321&quot; key_mgmt=WPA-PSK sim_num=1 priority=17293 } ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 如果 Android O 或以后，WiFi 密码保存的地址有变化，是在 WifiConfigStore.xml 里面 adb shell su cat /data/misc/wifi/WifiConfigStore.xml 输出格式： 数据项较多，只需关注 ConfigKey（WiFi 名字）和 PreSharedKey（WiFi 密码）即可 &lt;stringname=&quot;ConfigKey&quot;&gt;&quot;Wi-Fi&quot;WPA_PSK&lt;stringname=&quot;PreSharedKey&quot;&gt;&quot;931907334&quot; 设置系统日期和时间 注：需要 root 权限。 命令： adb shell su date -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 使用 Monkey 进行压力测试 Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： adb shell monkey -p -v 500 表示向 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi 注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： adb root adb shell svc wifi enable 关闭 WiFi： adb root adb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令 重启到 Recovery 模式 命令： adb reboot recovery 从 Recovery 重启到 Android 命令： adb reboot 重启到 Fastboot 模式 命令： adb reboot bootloader 通过 sideload 更新系统 如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令：adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： adb sideload &lt;path-to-update.zip&gt; 安全相关命令 启用/禁用 SELinux 启用 SELinux adb root adb shell setenforce 1 禁用 SELinux adb root adb shell setenforce 0 启用/禁用 dm_verity 启用 dm_verity adb root adb enable-verity 禁用 dm_verity adb root adb disable-verity 系统管理命令 Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 ###查看进程 命令： adb shell ps 输出示例： USER PID PPID VSIZE RSS WCHAN PC NAME root 1 0 8904 788 ffffffff 00000000 S /init root 2 0 0 0 ffffffff 00000000 S kthreadd ... u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic u0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure ... shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： USER所属用户 PID进程 ID PPID父进程 ID NAME进程名 查看实时资源占用情况 命令： adb shell top 输出示例： User 0%, System 6%, IOW 0%, IRQ 0% User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： PID进程 ID PR优先级 CPU%当前瞬间占用 CPU 百分比 S进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） THR 线程数 VSSVirtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSSResident Set Size 实际使用物理内存（包含共享库占用的内存） PCY调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID进程所有者的用户 ID NAME进程名 top 命令还支持一些命令行参数，详细用法如下： Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 查看进程 UID 有两种方案： 1. adb shell dumpsys package &lt;packagename&gt; | grep userId= 如： $ adb shell dumpsys package org.mazhuang.guanggoo | grep userId= userId=10394 2. 通过 ps 命令找到对应进程的 pid 之后 adb shell cat /proc/&lt;pid&gt;/status | grep Uid 如： $ adb shell gemini:/ $ ps | grep org.mazhuang.guanggoo u0_a394 28635 770 1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoo gemini:/ $ cat /proc/28635/status | grep Uid Uid: 10394 10394 10394 10394 gemini:/ $ 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： cat显示文件内容 cd切换目录 chmod改变文件的存取模式/访问权限 df查看磁盘空间使用情况 grep过滤输出 kill杀死指定 PID 的进程 ls列举目录内容 mount挂载目录的查看和管理 mv移动或重命名文件 ps查看正在运行的进程 rm删除文件 top查看进程的资源占用情况 常见问题 启动 adb server 失败 出错提示 error: protocol fault (couldn't read status): No error 可能原因 adb server 进程想使用的 5037 端口被占用。 解决方案 找到占用 5037 端口的进程，然后终止它。以 Windows 下为例： netstat -ano | findstr LISTENING ... TCP 0.0.0.0:5037 0.0.0.0:0 LISTENING 1548 ... 这里 1548 即为进程 ID，用命令结束该进程： taskkill /PID 1548 然后再启动 adb 就没问题了。 ","link":"https://github.com/stepheneasyshot/stepheneasyshot.github.io/post/android-chang-yong-diao-shi-ming-ling/"},{"title":"Android集成Unity的两种方案实战","content":"Android平台常见动效 现在市面上的形形色色Android客户端，为了更优的用户体验，我们开发的上游产品和交互往往会在界面里设计很多动效。传统的一页页的静态展示页面已经不足以满足用户的审美需求了。 而动效的分类也是花样百出的，以播放时机来说有点击触发，打开页面触发，还有可跟随手指的交互持续触发的等等。有时候一些和数据耦合性较大的动效甚至需要我们自己来手写复杂的自定义View，比如曲线图、图表类型。 而我日常碰到的大部分的动效需求，还是依赖UI设计的同时来制作提供的，像那些短时间单次的展示类动效，往往实现方式比较随意，对资源的格式要求也不太严苛。一般有以下几种方案: 帧动画 在Android中，帧动画是通过Drawable动画实现的。你可以创建一个AnimationDrawable对象，然后在XML中定义一系列的帧（frames），每帧可以是一个Drawable资源。然后在代码中启动这个动画。 以下是两个简单的例子： 在res/drawable目录下创建一个名为frame_animation.xml的文件，并定义动画的帧： &lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/frame1&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/frame2&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/frame3&quot; android:duration=&quot;100&quot; /&gt; &lt;!-- 更多帧 --&gt; &lt;/animation-list&gt; 这里android:oneshot=&quot;false&quot;表示动画会循环播放，如果设置为true则播放一次。android:duration表示每帧显示的时间。 在你的布局文件中（例如activity_main.xml），添加一个ImageView来展示动画： &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/frame_animation&quot; /&gt; 然后在调用处启动动画： ImageView imageView = (ImageView) findViewById(R.id.imageView); // 获取AnimationDrawable final AnimationDrawable frameAnimation = (AnimationDrawable) imageView.getDrawable(); // 在UI线程之外启动动画 imageView.post(new Runnable() { @Override public void run() { frameAnimation.start(); } }); 注意确保你的每个Drawable资源的尺寸是一致的，以便在动画过程中保持帧的正确显示。这样就创建了一个简单的帧动画，当Activity加载时，动画会自动开始循环播放。 PAG动画 pag相较于上面的帧动画对性能更加友好。PAG是腾讯公司自主研发的一套完整动画工作流解决方案。 PAG诞生于2016年，最初的原因是为了解决更为复杂的视频编辑场景下动画渲染问题，同时又覆盖了UI动画和直播场景，于2022年1月在Github开源。 其使用方法可以说相当简单，只需要先从github主页确定版本，到gradle里引入依赖， implementation 'com.tencent.tav:libpag:3.2.7.40' 然后在我们应用的xml布局中放置pagView，没有额外的属性需要配置： &lt;org.libpag.PAGView android:id=&quot;@+id/pagview&quot; android:layout_width=&quot;@dimen/dp_1190&quot; android:layout_height=&quot;@dimen/dp_1110&quot; android:layout_marginTop=&quot;@dimen/dp_290&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; 最后在代码里设置其文件源，循环方式，调用播放即可 @Override protected void onCreate(Bundle savedInstanceState) { LogUtils.d(&quot;AirConditioner Start&quot;); super.onCreate(savedInstanceState); setContentView(R.layout.instance); PAGView pagView = findViewById(R.id.pagview); PAGFile pf = PAGFile.Load(getContext().getAssets(), fileName); pagView.setComposition(pf); pagView.setRepeatCount(-1); pagView.play(); } MP4动画 这个单次动效的实现方案是最简单的，不写demo演示了，直接获取mediaplayer实例，绑定surfaceView或者TextureView，再填文件，播放视频即可。需要关注的是surfaceView播放视频一开始可能会有黑屏问题，可以用静态图占位。 可交互的动效 顾名思义，这一类动效需要能跟随用户的操作而实时改变表现形式。最常见的就是吸顶动效，例如在一个列表滑动过程中，会监听列表的滑动距离，对界面顶部或者侧边的其他View位置和透明度，颜色等做动态设置。还有systemui的allapp界面的翻页动画，负一屏下拉的时候，根据距离对桌面背景做高斯模糊处理等等。 Kanzi动效 跟手可互动的动效，也不得不谈kanzi动效。以下介绍来自百科与官网： Kanzi产品是行业领先的3D引擎和UI开发工具，支持高效率沉浸式3D效果，跨系统多屏互联并能与安卓生态完美融合，已经成为全球主流车厂智能座舱首选的UI开发工具和引擎。更新后的Kanzi架构可与安卓操作系统、生态系统深度兼容。Kanzi可基于安卓的任何功能提供强大的图形设计支持，确保高质量的图像效果。 对于Kanzi动效的集成使用方式，因为没有自己从头开始对接，我只按照顺序一笔带过，有不对的地方欢迎指正。首先我们集成kanzi运行所需的Runtime.aar，kanziJava支持库aar，资源文件，资源列表的txt等等，还需要在gradle里写明不可压缩的文件类型，以防止无法加载资源。 在使用上，我们先在XML布局中声明，同时通过属性填入asstes里的资源名，和资源文件绑定： &lt;com.rightware.kanzi.KanziTextureView android:id=&quot;@+id/tx_KanziSurfaceView&quot; android:layout_width=&quot;@dimen/dp_2560&quot; android:layout_height=&quot;@dimen/dp_1190&quot; app:clearColor=&quot;@android:color/transparent&quot; app:kzbPathList=&quot;climate.kzb&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:name=&quot;climate&quot; app:startupPrefabUrl=&quot;kzb://climate/StartupPrefab&quot; tools:ignore=&quot;MissingConstraints&quot; /&gt; 在代码里我们需要设置通信的工具类，在里面添加监听器来接收和上行下行信号的交互： // 数据接口定义 public interface AndroidNotifyListener { void notifyDataChanged(String name, String value); void dataSourceFinish(); } // 添加数据接收监听和下行通信 AndroidUtils.setListeners(this); AndroidUtils.removeListeners(this); AndroidUtils.setValue(SourceData.RightMidMove_up2down, y); Unity动效 Unity的大名在游戏界可谓如雷贯耳，记得小时候玩的很多游戏的开屏界面即有一个大大的Unity字样和图标。 以下介绍来自百科和官网：Unity是实时3D互动内容创作和运营平台。包括游戏开发、美术、建筑、汽车设计、影视在内的所有创作者，借助Unity将创意变成现实。Unity平台提供一整套完善的软件解决方案，可用于创作、运营和变现任何实时互动的2D和3D内容，支持平台包括手机、平板电脑、PC、游戏主机、增强现实和虚拟现实设备。Unity作为全球领先的 3D 引擎之一，团结引擎可以为 3D HMI提供全栈支持。即为从概念设计到量产部署的整个 HMI 工作流程提供创意咨询、性能调优、项目开发等解决方案，从而为车载信息娱乐系统和智能驾驶座舱打造令人惊叹的交互式体验。 其实在第一版我们项目集成的是Kanzi方案，其性能表现较Unity要差一些，关键是项目推进的过程中，对方工程师对动效样式的优化也达不到评测部门的要求，后来更新迭代我们就更换了Unity方案。而本文的重点也是在于Unity3D动效的使用，案例为车载IVI系统空调app的风向调节，交互逻辑比上面举的例子更加复杂，需要实时跟手，在交互热区范围内需要不断变化动效形态，并完成双向通信，保证动效和车载信号的一致性。 Unity集成的两种方案 前面做了这些动效的铺垫，终于进入正题了。本文暂时不深究Unity的渲染原理，只谈集成和使用。 通信协议制定 第一步不是创建工程，而是要提前根据HMI的产品交互定义来指定和Unity之间的通信协议。有哪些功能是有开关的，需要调整哪些属性。空调app里就涉及几个出风口的打开关闭，可以以0/1来区分。还有风口的方向调节，需要互传x,y坐标值。Android和Unity之间的是采用JSON字符串来通信的，对于JSON字符串的的打包与解包通过谷歌的Gson等三方库来操作，相当简单。 而且，两方通信链路和Unity的集成方式还有关，像下面要谈到的第一种进程隔离方案，就是通过集成全量的Unity依赖包，利用其中的JNI接口来通信的，而Client/Server架构就是通过Android的AIDL接口来和单独的服务端进程通信的。另外交互的车载信号链路方案涉及项目架构机密，此处不作描述。 进程隔离方案-UAAL(Render As Library) 这种方式集成的话，Unity会将渲染引擎，资源文件，和Android上层的通信代码都打包导出到一个aar中，其体积随动效的复杂程度而变化，同时会使集成方的apk包体积增加。而且项目里有多少方要使用Unity动效，就需要多少份的渲染引擎。这个方案由客户端来负责Unity控件的创建销毁，显示隐藏，一般适用一对一，通信链路简单的，即项目中可能只有一个模块需要使用Unity动效的情况。在多模块需要使用Unity的情况下，进程隔离的方案对性能的占用也比较高。 上层使用到的控件——UnityPlayer，它是一个Unity自定义的FrameLayout，里面有他们自己实现的一系列添加view，显示，和渲染逻辑。资源文件均存在于Unity打的依赖包中，对外不开放。 集成步骤 进程隔离的集成方式如下： 第一步，将Unity提供的aar放置于libs文件夹中，并在gradle里添加其编译引用。 implementation files('libs/UnityAnimation_0321V4.aar') 第二步，gradle中配置Unity所需的NDK版本，配置abifilters，设置要将哪些架构的动态库打包到apk中，对于车机项目来说只需要固定的某一种架构即可。还有设置不压缩的文件类型，使Unity可以顺利找到资源使用。 ndkVersion &quot;23.1.7779620&quot; aaptOptions { noCompress = ['.tj3d', '.ress', '.resource', '.obb', '.bundle', '.tuanjieexp', 'global-metadata.so'] + tuanjieStreamingAssets.tokenize(', ') ignoreAssetsPattern = &quot;!.svn:!.git:!.ds_store:!*.scc:!CVS:!thumbs.db:!picasa.ini:!*~&quot; } ndk{ abiFilters 'arm64-v8a' } 注意，我们还需要在项目的string.xml资源文件中添加Unity所需的一条String资源，否则Unity侧会空指针。 &lt;string name=&quot;game_view_content_description&quot;&gt;Game view&lt;/string&gt; 第三步，将要显示Unity动效的页面Activity改为继承自UnityPlayerActivity，Unity的核心显示控件，UnityPlayer，它的创建销毁，显示隐藏，由这个UnityPlayerActivity来统一管理，项目中集成这个Activity的子类再将mUnityPlayer通过addView添加到自己的根布局ViewGroup中当背景即可，而且可以在xml上面继续增加其他View控件。 第四步，封装Unity通信工具类，Android给Unity发消息可以直接通过UnityPlayer的sendMessage静态方法，传入Unity通信协议中指定的类名。 UnityPlayer.UnitySendMessage(OBJ_NAME, METHOD_NAME, communicateMessage) Unity使用C#开发，其给Android上层发消息则是通过反射回调信号类里的方法实现的，所以我们最好将信号管理类做成单例的，并给其Unity留下一个方法或者成员，可以拿到我们类的实例，顺利反射回调。我这里使用的是一个Kotlin类声明，并对外暴露一个公开的unityInstance成员。而这个方法onReceiveMsgFromUnity，即是Unity的反射调用，我们在其中进行信号的解析，并传到View中去，注意这个方法不是在主线程中反射的，所以后面需要优化一波。 object UnityMessageHelper { val unityInstance = this // Unity给Android的消息回调 fun onReceiveMsgFromUnity(msg: String) { LogUtils.d(TAG, &quot;onReceiveMsgFromUnity: $msg&quot;) if (listenerList.size &gt; 0) { listenerList.forEach { it.onReceiveUnityMessage(msg) } } } } 信号类UnityMessageHelper的优化 由于我们的目标工程是空调app，在用户调节风向时的回调频率相当高，而自动扫风模式下，底层上传的数据频率也相当高，所以不适合到主线程中操作这么多的数据，我们用协程，配合Default调度器来处理这种CPU密集型的任务。两条链路，用户手指的拖动操作时，Unity反射回调的线程本身都是工作线程了，所以我们在使用自定义的接口回调到View类的时候，使用MainScope.launch包一层，确保是到主线程更新我们的UI。而自动扫风模式从域控制器接收到风口点击的坐标值时，我们拿到数据后给Unity下发信号，更新动效的指向位置。可以使用协程上下文切换，withContext(Dispatcher.Default)将其切到工作线程里发送给Unity。 遇到的问题 Unity方给的aar里的基类Activity适用与绝大多数的普通应用，但是我这里空调app的定位是一个悬浮的临时面板，其实我的工程里压根就没有Activity，而是采用WindowManager来添加高层级窗口的View的形式来展示界面。 这个时候我们用不上他们定义的UnityPlayerActivity，只能使用原生Raw的UnityPlayer，自己管理其创建，销毁，resume和pause。这里需要注意的是，UnityPlayer的创建需要传一个Context上下文，而应用里又没有Activity类型的Context，故只能使用非Activity类型的Context，而且实践中发现，这个UnityPlayer的实例必须是我们的应用拿到可用的窗口句柄之后，才能被成功创建，否则就会报错。 所以正确的创建与初始化顺序是先使用WindowManager添加一个xml布局inflate来的ViewGroup，在其onAttachToWindow的方法回调之后，再创建UnityPlayer的实例，并添加到这个ViewGroup的布局中去，调用其resume方法。 public void initUnity() { if (mUnityPlayer == null) { LogUtils.i(TAG, &quot;initUnity&quot;); unityInitView = (LinearLayout) LayoutInflater.from(mContext).inflate(R.layout.layout_unity_init, null); unityInitView.addOnAttachStateChangeListener(new View.OnAttachStateChangeListener() { @Override public void onViewAttachedToWindow(@NonNull View v) { LogUtils.w(TAG, &quot;unityInitView onViewAttachedToWindow&quot;); mUnityPlayer = new UnityPlayer(mContext); unityInitView.addView(mUnityPlayer); mUnityPlayer.requestFocus(); mUnityPlayer.resume(); mUnityPlayer.windowFocusChanged(true); } @Override public void onViewDetachedFromWindow(@NonNull View v) { LogUtils.w(TAG, &quot;unityInitView onViewDetachedFromWindow&quot;); // Unityplayer已经成功移除，通知airView将player添加进去 airConditionerView.addUnityToAirView(); } }); mWindowManager.addView(unityInitView, initUnityWindowParams()); } } 注意，这样添加的UnityPlayer有一个无法解决的黑屏问题，因为Unity的渲染加载至少都需要4，5秒，期间我们只能在更上层的View里设置静态背景图覆盖上去，等Unity加载完毕，发送ready的回调之后，我们移除掉这个占位的静态图，展示Unity动效的界面。这也是进程隔离的方案的一个很棘手的问题。我的解决方案是在开机的时候往屏幕外添加一个View专门来初始化加载Unity，加载完毕后，再将UnityPlayer给从里面remove掉，重新添加到实际的要展示的窗口中去，这样打开界面的时候可以略去加载的耗时，稍微减少页面僵直的时间。 单进程-URAS(Render As Service) Unity Rendering as Service（简称URAS） 的渲染方案是团结引擎特有的，无需在多个安卓应用中集成多个Unity 3D player，而是后台运行，前端应用可直接调用，节省系统资源，更适合多应用动效一镜到底的设计。 相较进程隔离方案的优势 这个方案是在UAAL方案的基础上升级的，所以有一些前期工作是重复的，不作重复的阐述。 它是将要显示的几个Unity引擎都打包到同一个Server服务端去统一管控。其实服务端的apk打包也是拿到Unity提供的服务端AAR打进一个空工程，内部逻辑也隐藏到了AAR中。服务端和客户端的通信采用我们熟知的AIDL接口来实现。而且这个服务端我们需要设置为persistent应用，使其能开机自启，自动执行渲染等工作，其他应用有显示需求可以秒开，并且长时间不显示也不会自己回收资源了，客户端的黑屏问题也可以解决了。 相比于UAAL方案，客户端需要集成的是一个体积很小的Client.aar，对于客户端apk的体积控制是有优势的。 集成与使用方式 我们只需要在gradle里引入这个客户端aar。在gradle sync之后，将远程的UnityView添加到自己的布局中去，配置好display参数(用来给服务端区分是哪个引擎的内容)，并指定服务端的包名。承载的View类型有SurfaceView和TextureView两种，而我的应用界面因为是一个悬浮窗口，设计有进出场的渐隐渐出动效，而SurfaceView不可以线性地设置alpha动画，所以选取TextureView来当作容器。 &lt;com.unity3d.renderservice.client.TuanjieView android:id=&quot;@+id/unityview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:tuanjieDisplay=&quot;2&quot; app:tuanjieServicePkgName=&quot;com.tuanjie.renderservice&quot; app:tuanjieViewType=&quot;TextureView&quot; /&gt; 剩余的代码逻辑仅仅是服务端Service的启动，添加服务连接的回调，消息回调。由于服务端为若干个Client的公共引擎，所以连resume和pause都不需要处理，因为这两个操作会对所有的客户端都生效。我们只需要确保启动服务，并使用正确的display即可，面板退到后台可以使用setVisbility来控制其显示隐藏。除此之外，我们的通信工具类，UnityMessageHelper还需要实现两个接口，一个服务连接状态接口，一个业务数据的消息回调接口，代码如下： object UnityMessageHelper : TuanjieRenderService.Callback, SendMessageCallback { fun initUnityService() { LogUtils.i(TAG, &quot;initUnityService&quot;) unityRenderService = TuanjieRenderService.init(appContext,TUANJIE_PACKAGENAME).apply { enableAutoReconnect = true addCallback(this@UnityMessageHelper) addSendMessageCallback(this@UnityMessageHelper) ensureStarted() } } override fun onServiceConnected() { LogUtils.w(TAG, &quot;onUnityRenderServiceConnected&quot;) } override fun onServiceDisconnected() { LogUtils.w(TAG, &quot;onUnityRenderServiceDisConnected&quot;) messageScope.launch { delay(500L) initUnityService() unityRenderService.resume() } } override fun onServiceStartRenderView(p0: Int) { LogUtils.i(TAG, &quot;onServiceStartRenderView&quot;) } override fun onClientRecvMessage(message: String?) = null // 服务端的消息回调 override fun onClientRecvMessageWithNoRet(msg: String?) { // 回调消息的解析 } } 同时Android给Unity发信号的方法也从UnityPlayer的静态方法换成了这个服务实例的方法调用： unityRenderService.c2sSendMessage(OBJ_NAME, METHOD_NAME, communicateMessage) 接收Unity的回调消息也换成了addSendMessageCallback里设置的回调方法。 可以说URAS方案由于其统一管控，一对多的特点，在性能和客户端的易集成性方面，是优于UAAL方案的。可以从架构层面上，联动更多的动效使用模块，实现一镜到底的丝滑转场。 结语 以上就是本文对于Android常用几种动效的阐述以及对两种常见的Unity集成方案记录。后续我们除了在最表面的使用层面上，还可以进一步挖掘其原理，甚至自己使用Unity的开发工具，自己体验一把动效的制作和接入，做到全链路知己知彼，才可以更高效的集成Unity为自己的应用锦上添花。 ​ ","link":"https://github.com/stepheneasyshot/stepheneasyshot.github.io/post/android-ji-cheng-unity-de-liang-chong-fang-an-shi-zhan/"},{"title":"Android多渠道打包配置方案","content":"​ 背景 多渠道打包，顾名思义就是用来区分同一个软件，在不同渠道上的释放版本。 这个手机上大型app几乎是必配置的一个项，给不同型号的手机所用的apk会做一些细微的区别。像笔者使用酷安社区比较多，在官网下载的酷安apk界面顶部有软件管理功能，在其他手机厂的应用商店里下载的酷安就没有这个功能。 目前我们有需求是要一套软件代码库多个项目共同使用，针对不同的项目打包不同的渠道apk，现学记录一下。 Gradle脚本和Manifest文件配置 不同渠道的apk既然要做细微的功能上的区分，就需要在代码里能拿到一个类似键值对的标志位。并且能够全局调用。首先我们需要在app级的gradle文件里配置不同的channel名称。 其中flavorDimensions和productFlavors中的维度名称需要一一对应。随便写一个&quot;default&quot;即可。 defaultConfig { xxxx = xxxx flavorDimensions.add(&quot;default&quot;) } gradle.kts语法与Groovy略有不同，要添加自己配置的东西一般是使用create，register之类的关键字，不熟悉配置的可以先试试。 不同渠道包的域里，我们可以区分很多参数值，像这里我是配置了不同渠道使用不同平台的签名。 productFlavors { create(&quot;cheetah&quot;) { dimension = &quot;default&quot; signingConfig = signingConfigs.getByName(&quot;cheetah&quot;) manifestPlaceholders[&quot;CHANNEL_VALUE&quot;] = &quot;cheetah_channel&quot; } create(&quot;redfin&quot;) { dimension = &quot;default&quot; signingConfig = signingConfigs.getByName(&quot;aaos&quot;) manifestPlaceholders[&quot;CHANNEL_VALUE&quot;] = &quot;redfin_channel&quot; } } 为了可以设置成自己想要的键值对，建议在Manifest清单文件里设置一组元数据，在打包时让Gradle去赋值它。结合上下两段代码，我们在Manifest里的一组元数据，key设为CHANNEL，value为引用型的变量CHANNEL_VALUE，在Gradle渠道配置里，我们使用： manifestPlaceholders[&quot;CHANNEL_VALUE&quot;] = &quot;cheetah_channel&quot; 来为其赋值。 &lt;meta-data android:name=&quot;CHANNEL&quot; android:value=&quot;${CHANNEL_VALUE}&quot; /&gt; 打包时，可以通过判断flavor的名称，来输出不同的apk名字。 android.applicationVariants.configureEach { outputs.all { if (this is com.android.build.gradle.internal.api.ApkVariantOutputImpl) { if (flavorName == &quot;redfin&quot;) { this.outputFileName = &quot;RedfinChannel_V${versionName}.apk&quot; } else if (flavorName == &quot;cheetah&quot;) { this.outputFileName = &quot;CheetahChannel_V${versionName}.apk&quot; } } } } 代码调用 全局性的打包配置完毕后，我们如何在代码里去使用区分不同渠道呢。 这里也有两种方法来获取，一种是直接拿取Gradle脚本里创建时的渠道名，直接通过BuildConfig类的FLAVOR字段来获取；一种是拿取我们在Manifest里设置的元数据的value值，操作稍复杂一些。具体代码如下： object FlavorConfig { const val REDFIN = &quot;redfin&quot; const val CHEETAH = &quot;cheetah&quot; private var manifestMetaData = &quot;&quot; private var gradleData = &quot;&quot; init { val appInfo = appContext.packageManager.getApplicationInfo( appContext.packageName, PackageManager.GET_META_DATA ) manifestMetaData = appInfo.metaData.getString(&quot;CHANNEL&quot;) as String gradleData = BuildConfig.FLAVOR } fun getMetaDataOne() = manifestMetaData.apply { infoLog(&quot;metaData value: $this&quot;) } fun getMeatDataTwo() = gradleData.apply { infoLog(&quot;gradle metaData value: $this&quot;) } } ​ ","link":"https://github.com/stepheneasyshot/stepheneasyshot.github.io/post/android-duo-qu-dao-da-bao-pei-zhi-fang-an/"},{"title":"Android多进程通信之带回调的AIDL实现","content":"需求背景 我们都知道Android系统的IPC(多进程通信)方式有很多种，像全局广播，系统数据库监听，还有最广为使用的AIDL接口。 最近我收到了来自语音app的需求，他们为了可以顺利注册可见即可说（扫描模拟点击），需要我在打开和关闭界面的时候给他们发个通知。因为我们的应用是采用windowmanager添加的一个临时弹窗，不能通过ActivityStack栈监听到变化，所以需要做这么一个接口给他们。 由于之前已经给语音侧打包过AIDL依赖包，提供过打开关闭界面，获取模式状态等接口了，所以希望基于已有的接口上进行扩展，使用注册监听的形式来给他们发回调通知，告诉他们界面状态有变动。 刚着手准备做，突然想起来这个带回调的AIDL接口好像之前还没有开发过，于是简单看了下，记录下开发过程。不得不感叹谷歌真的懒，这套AIDL的写法，感觉还是有点繁琐。光记录这个加回调AIDL方法的过程实在太短了，这里将我给外部app提供依赖包的习惯也一起记录下吧。 以aar的形式提供AIDL接口 Google官方的例程一般是，作为服务端的app和作为客户端的app两边建立一个同样包名的AIDL文件夹，客户端再去自己做一个bindService的操作，连接成功时，用返回来的binder对象将服务给实例化，使用其中的方法。但是就拿语音距离，大家都这么给语音客户端提供接口的话，他们那边的项目复杂度要爆炸了，所以一般是由提供接口的Server端将客户端连服务的操作也自己实现了，作为一个本地的library模组，一起打一个aar包提供出去。 接下来以两个Demo的代码示例演示下这个打包的流程，我们以一个车速模拟的需求为例: 新建模组配置gradle 在项目里new一个Module，记得选择Library类型，AS会自动帮我们填到setting.gradle.kts中。 接下来我们在新module的gradle构建配置中开启aidl，这样才能新建aidl接口声明文件。第二个改动就是配置构建输出文件名。 buildFeatures { aidl = true } val aarName = &quot;CarSpeedMock&quot; android.libraryVariants.configureEach { outputs.all { if (this is com.android.build.gradle.internal.api.LibraryVariantOutputImpl) { this.outputFileName = &quot;${aarName}_1.0.aar&quot; } } } 这样我们在打包的时候就可以顺利生成一个aar依赖包的输出文件，将这个依赖包提供给接口使用方，可以大大简化他们的工作量，解耦代码，可增强可维护性。 开始实现AIDL接口回调需求 配置Server与Client代理的aidl文件 我们需要模拟一下车速数据的回调，需要新建一个主要的接口声明文件，里面添加一个设置回调的方法，然后需要再声明一个回调接口，里面是onChange的方法。 // ISpeedCallback.aidl interface ISpeedCallback { void onSpeedChange( int speed); } // SpeedMockManager.aidl import com.stephen.vehiclesettings.ISpeedCallback; interface SpeedMockManager { void addSpeedCallback(ISpeedCallback callback); } 然后将整个文件夹都复制到新建的模组中去，保证客户端和服务端两边的aidl文件夹完全相同。 项目里的两边同步之后，我们点击小锤子build一下，以便AS可以生成格式化的stub文件。 实现服务端和客户端的逻辑 在服务端里，我们在onBind方法里返回一个binder对象，它要实现 SpeedMockManager.Stub接口，才可以和客户端顺利对接。 服务端代码如下: class SpeedMockService : Service() { override fun onCreate() { super.onCreate() infoLog() } override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { infoLog() return super.onStartCommand(intent, flags, startId) } override fun onBind(intent: Intent) = object : SpeedMockManager.Stub() { @Throws(RemoteException::class) override fun addSpeedCallback(callback: ISpeedCallback?) { // 采用协程循环和延时来模拟回调车速数据 CoroutineScope(Dispatchers.IO).launch { repeat(1000) { data -&gt; delay(2000L) infoLog(&quot;aidl send int data: $data&quot;) try { // 调用传进来的1回调接口的方法，将数据返回去 callback?.onSpeedChange(data) } catch (e: Exception) { e.printStackTrace() this.cancel() } } } } } } 同样的在客户端代理里面，去执行bindService。需要注意的是，我们的客户端代理类里面，需要多设置一个连接服务成功的接口，在连接成功的时候通知到使用方，我们的服务这时候绑定成功了，以后可以使用里面的方法了。 客户端代理代码如下： object CarSpeedProxy { private const val TAG = &quot;CarSpeedProxy&quot; private lateinit var carspeedManager: SpeedMockManager fun init(context: Context, connectListener: CarSpeedServiceConnectListener) { context.bindService(Intent(&quot;com.stephen.vehiclesettings.service.SpeedMockService&quot;).apply { setPackage(&quot;com.stephen.vehiclesettings&quot;) }, object : ServiceConnection { override fun onServiceConnected(name: ComponentName?, service: IBinder?) { Log.i(TAG, &quot;onServiceConnected: name:$name&quot;) // 接口实例化 carspeedManager = SpeedMockManager.Stub.asInterface(service) // 连接成功回调，告知使用方 connectListener.onServiceConnected() } override fun onServiceDisconnected(name: ComponentName?) { Log.i(TAG, &quot;onServiceDisconnected: name:$name&quot;) connectListener.onServiceDisConnected() } }, Context.BIND_AUTO_CREATE) } fun addCarSpeedCallback(callback: ISpeedCallback) { // 添加回调接口，使用方就可以接收数据了 try { carspeedManager.addSpeedCallback(callback) } catch (e: RemoteException) { e.printStackTrace() } } /** * 服务连接接口 */ interface CarSpeedServiceConnectListener{ fun onServiceConnected() fun onServiceDisConnected() } } 需求方使用aar 服务端和客户端的逻辑都完成后，将这个依赖包提供给需求方展开调试，看看服务连接和数据回调有没有问题。注意此Demo运行在我自己编译的系统中，而且配置了系统签名，拥有System权限，所以不用考虑服务保活问题。 使用这个接口的app，需要将我们提供的aar依赖包放在libs文件夹下，并在gradle里添加编译路径。这里我也新建一个需求方的Demo来测试我们的aar是否工作正常，使用我们aar里的客户端代理类去初始化连接服务，添加回调，并接收来自服务端模拟的车速数据了。 我们在Demo里也使用一个单例类来专门管理这个aar的业务逻辑，进一步解耦。在Application初始化调用init方法连接服务，在正式的使用处确保连接成功后，再添加回调，拿取数据： object AidlCallbackTest { private var isServiceReady = false fun init() { CarSpeedProxy.init(appContext, object : CarSpeedProxy.CarSpeedServiceConnectListener { override fun onServiceConnected() { LogUtils.i(&quot;AidlCallbackTest&quot;, &quot;onServiceConnected&quot;) isServiceReady = true } override fun onServiceDisConnected() { LogUtils.i(&quot;AidlCallbackTest&quot;, &quot;onServiceDisConnected&quot;) } }) } fun addCallback(callback: ISpeedCallback) { if (isServiceReady) CarSpeedProxy.addCarSpeedCallback(callback) } } 在方法调用处，我们需要传入的这个回调，即一个匿名内部类继承自ISpeedCallback.Stub，实现它的onSpeedChange(a:Int)回调方法，就可以接收到数据了： AidlCallbackTest.addCallback(object : ISpeedCallback.Stub() { override fun onSpeedChange(speedData: Int) { LogUtils.i(TAG, &quot;onSpeedChange speed:$speedData&quot;) } }) 先run进去服务端，再run刚刚写的客户端，两个进程都运行起来后，查看AS的Log打印我们可以看到服务成功连接了。再点击Demo的按钮添加上callback回调，可以看到Server和Client两边的模拟数据的打印也都打印出来了，设备不在手边就不再截图了。 这样一个带回调的AIDL接口，就成功地以aar的形式提供给需求方，由他们去使用数据做业务了。 扩展 最后，如果需要扩展接口功能，我们不止可以在AIDL接口中回调像int和String这种基本数据类型，也可以传输一个实现了实现了Parcelable接口的实体类，获取其中的多样化的属性数据。 总结一下就是，简单需求用AIDL接口基本数据类型就足够了。大量数据我们可以用系统数据库的方式传输JSON，或者用全局的键值对存储工具，更大的需求就可以写共享文件，再发单次成功的通知让对方去获取。 ","link":"https://github.com/stepheneasyshot/stepheneasyshot.github.io/post/android-duo-jin-cheng-tong-xin-zhi-dai-hui-diao-de-aidl-shi-xian/"},{"title":"你好 👏  欢迎来到Stephen的个人主页","content":"博客站点由来 最近工作之余，我经常在CSDN和掘金上发文，记录一下工作经验，还有近期折腾的好玩的东西。得到了很多反馈，也结识了一些技术大佬。还是决定花一上午鼓捣一下，用github.io搭建一个属于自己的博客网站。专注于记录，日后也方便其他人了解我的技术栈和工作风格。 因为本科学的嵌入式物联网，工作又转了车机Android，服务器后端完全不熟，所以直接用Gridea来完成大部分的前后端工作。我可以节省掉搭建网站的精力，只专注于文章的撰写，发布分享有意思的技术。 本站的访问量我估计只限于一同搞技术的朋友们，所以还是拿来主要当作记录之用。比如学习过程中的代码笔记，供日后温习查看；工作中积累的经验，提炼出通用的部分；个人和朋友们发掘的一些有意思或者高效率的代码写法。 ","link":"https://github.com/stepheneasyshot/stepheneasyshot.github.io/post/hello-gridea/"}]}