---
layout: post
description: > 
  本文介绍了Android的开机启动流程
image: 
  path: /assets/img/blog/blogs_jvm_cover.png
  srcset: 
    1920w: /assets/img/blog/blogs_jvm_cover.png
    960w:  /assets/img/blog/blogs_jvm_cover.png
    480w:  /assets/img/blog/blogs_jvm_cover.png
accent_image: /assets/img/blog/blogs_jvm_cover.png
excerpt_separator: <!--more-->
sitemap: false
---
# JVM原理概要
## 编译器解释器
编译器和解释器都是将高级语言代码转换成机器码的工具，但它们之间有一些关键区别：

* 编译器：一次性将整个程序代码转换成目标机器的可执行文件，执行时无需再进行翻译，因此执行速度通常较快。但编译过程需要额外的时间，且生成的可执行文件在不同平台上不可移植。
* 解释器：逐行解释源代码，并将其转换成机器码执行。解释器不需要生成可执行文件，因此节省了编译时间，但执行速度通常较慢。另外，解释器可以实现跨平台的代码执行，因为源代码在不同平台上均需要解释器来执行。

## JVM核心功能
 JVM的主要作用是执行Java程序的字节码。在Java应用程序开发中，Java源代码首先被编译成字节码文件（.class文件），而不是本地机器码。
 
 这个字节码是一种与平台无关的中间表示，可以在任何支持Java的平台上运行。

JVM字节码的执行过程大概可以分为以下几个步骤：

* 装载：虚拟机启动后，通过类加载器将.class文件加载到内存中，并进行解析。
* 链接：将被引用的类、方法、变量等符号引用转化为直接引用，并将常量池中的符号引用替换为直接引用。
* 初始化：对类进行初始化。包括执行类构造器<clinit>()方法，静态变量赋值等。
* 解释执行：将解析后的字节码逐行解释执行，根据操作码执行相应的操作。
* 编译执行：如果某个方法被多次执行，JIT编译器会将其编译为本地代码，以提高执行效率。
* 垃圾回收：JVM自动进行垃圾回收，将不再使用的对象进行回收，释放内存空间。

总的来说，JVM字节码的执行过程包括“装载-链接-初始化-解释执行/编译执行-垃圾回收”等几个步骤，其中解释执行和编译执行是主要的执行方式。

## 跨平台特性
JVM跨平台兼容性的原因是因为Java程序编译后生成的是字节码（ByteCode）而不是特定平台上的机器码（Machine Code）。也就是说，Java程序并不是直接翻译成本地平台上的机器码，而是转换成JVM可以识别的字节码，最终由JVM解释执行或编译成本地平台上的机器码。

也就是说JVM充当了一个中间层，负责将字节码翻译成特定操作系统的机器码。

这样做的好处是，由于Java程序并不会直接依赖于本地操作系统或硬件，所以只要有支持Java虚拟机的平台，就可以在该平台上运行Java程序，而不需要对程序进行修改。

这种跨平台机制使得Java程序可以在多个操作系统上进行编译和执行，从而使得Java成为一种性能良好、易于移植的语言。因此，JVM被认为是一种跨平台运行的虚拟机，Java也因此而被大量使用。

## Java内存区域
每一个java进程都是运行在一个独立的jvm虚拟机里面的，彼此之间数据隔离不互通。

一个进程所处的Java虚拟机的内存可以用下面这张热门图片概括：

![jvm_ram](/assets/img/blog/blogs_jvm_ram_simple.png){:width ="500" height="280" loading="lazy"}

* 程序计数器：一小块区域， **线程私有** 。记录了每个线程的代码执行到了哪一行,各种循环，判断都是通过这个区域存的数值来走的。Java多线程是时间分片，各个线程在一段时间内占用这个核来执行任务，这个线程切换到另一个线程，其恢复的依据也是计数器的值。
* 虚拟机栈：周期与线程相同，也是 **线程私有** 。每个方法执行时，都会创建一个栈帧， **栈帧里面存储方法内的局部变量表，方法出口等等信息** 。每个方法执行到退出的过程，就是一个个的方法栈帧入栈出栈的过程。这个区域有两个异常，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 ```StackOverflowError``` 异常；如果JVM允许动态扩展，当栈扩展时无法申请到足够的内存会抛出 ```OutOfMemoryError``` 异常。
* 本地方法栈：和虚拟机栈作用一样，但是服务于 **本地的Native方法** 。同样会抛出上面的两种异常。
* Java堆：最大的一块，所有 **线程共享** 的数据。几乎所有的对象实例都在这里保存。Java堆是垃圾收集器管理的内存区域。Java堆可以处于物理上不连续的内存空间中，可以选择固定大小或可扩展。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出 ```OutOfMemoryError``` 异常。
* 方法区： **线程共享** 。用于存储已被虚拟机加载的 **对象类型信息、常量、静态变量、即时编译器编译后的代码缓存** 等数据。对其要求比较宽松，几乎不用考虑垃圾回收，但是回收也是有必要的，主要针对常量的回收和类型卸载。如果方法区无法满足新的内存分配需求时，将抛出 ```OutOfMemoryError``` 异常。
  * 运行时常量池，其是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行期间也可以将新的常量放入池中。
* 直接内存：直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 ```DirectByteBuffer``` 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

更详细的内存分配图如下：

![jvm_ram](/assets/img/blog/blogs_jvm_ram_ext.jpg){:loading="lazy"}

### 对象创建
当遇到new字节码时，首先会检查这个指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

对象所需的内存大小在类加载完成即可完全确定下来。为对象分配内存即把一块确定大小的内存块从Java堆中分离出来使用。

假设Java堆中的内存是规整的，使用的内存在一遍，空闲的内存在另一边，中间放置一个指针作为分界点指示器，那分配内存就是把指针往空闲的区域移动一段距离，这种方式叫 **指针碰撞** 。

如果堆内存是相互交错的，那么虚拟机就必须维护一个列表，记录哪些内存是可用的，分配内存时就是从列表中找到一块足够大的区域给对象实例，再更新纪录，这种方式叫做 **空闲列表** 。

采用哪种方式由垃圾收集器是否带有空间压缩整理的能力决定。
### 并发安全解决方案
对象创建是非常频繁的行为，可能在为对象A分配时，指针还未修改，对象B又从原来的指针指向处开始分配内存。

* 一种方案是采用CAS加失败重试的方式保障更新操作的原子性。

* 另一种方案是把内存分配的操作按照线程划分在不同空间进行，每个线程先在Java堆中划一小块作为本地线程分配缓冲，本地缓冲区用完，分配新的缓冲区才需要同步锁定。

### 分配收尾
分配完成后需要把分配空间全部置零，确保对象实例字段再Java代码中可以不赋初值直接使用。
接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

虚拟机的视角，对象已经分配完成，从程序的视角看，对象创建才看看开始，到其构造函数。
## 对象在堆中的内存分配
分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
### 对象头
分为两部分，首先是对象运行时数据，如哈希码，GC分代信息，锁状态标志等，在32位和64位虚拟机上，这部分数据分别占32bit和64bit。且被设计成动态定义的数据结构，以存储尽量多的数据。
另一部分是类型指针，指向对象元数据的指针，虚拟机根据这个确定对象是哪一个类的实例，并不是所有实例都会保留类型指针。
### 实例数据
我们所定义的各种类型的字段类容，内存分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs）。相同宽度倾向于一起分配，先加载父类定义的，后加载子类自己的。在虚拟机的CompactFields为true时，子类里较短的变量也会插入父类的空隙中以节省空间。
### 对齐填充
对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义.JVM要求对象起始地址必须是8字节的整数倍，即对象占用空间大小也必须是8字节整数倍，不够的部分就会被对齐填充。
### 对象的访问
Java程序通过栈上的reference数据来操作堆上的具体对象。两种方式，通过句柄访问和指针直接访问。

#### 句柄访问
Java堆中将可能会划分出一块内存来作为句柄池，句柄包含对象的示例数据的指针和对象类型数据的指针。

使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

![jvm_find](/assets/img/blog/blogs_jvm_find_token.png){:loading="lazy"}

#### 直接指针
这种方式来访问对象，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。

使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销。由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。

![jvm_find_2](/assets/img/blog/blogs_jvm_find_direct.png){:loading="lazy"}



## 垃圾回收
垃圾回收，即GC(Garbage Collection)，回收无用内存空间，使其对未来实例可用的过程。由于设备的内存空间是有限的，为了防止内存空间被占满导致应用程序无法运行，就需要对无用对象占用的内存进行回收，也称垃圾回收。 垃圾回收过程中除了会清理废弃的对象外，还会清理内存碎片，完成内存整理。
### 判断对象是否存活的方法
GC堆内存中存放着几乎所有的对象（方法区中也存储着一部分），垃圾回收器在对该内存进行回收前，首先需要确定这些对象哪些是“活着”，哪些已经“死去”，内存回收就是要回收这些已经“死去”的对象。

那么如何其判断一个对象是否还“活着”呢？方法主要由如下两种：

#### 引用计数法
该算法由于无法处理对象之间相互循环引用的问题，在Java中并未采用该算法，在此不做深入探究；

#### 根搜索算法（GC ROOT Tracing）
Java中采用了该算法来判断对象是否是存活的，也叫可达性分析。

通过一系列名为 **GC Roots** 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论来说就是从GC Roots到这个对象不可达）时，则证明对象是不可用的，即该对象是“死去”的，同理，如果有引用链相连，则证明对象可以，是“活着”的。

哪些可以作为GC Roots的对象呢？Java 语言中包含了如下几种：

        1）虚拟机栈（栈帧中的本地变量表）中的引用的对象。

        2）方法区中的类静态属性引用的对象。

        3）方法区中的常量引用的对象。

        4）本地方法栈中JNI（即一般说的Native方法）的引用的对象。

        5）运行中的线程

        6）由引导类加载器加载的对象

        7）GC控制的对象

### 回收流程
现代商用虚拟机基本都采用分代收集算法来进行垃圾回收，当然这里的分代算法是一种混合算法，不同时期采用不同的算法来回收。

 由于不同的对象的生命周期不一样，分代的垃圾回收策略正式基于这一点。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。该算法包含三个区域：年轻代(Young Generation)、年老代(Old Generation)、持久代(Permanent Generation)。

![jvm_find](/assets/img/blog/blogs_jvm_generation.png){:loading="lazy"}
 
#### 年轻代(Young Generation)
所有新生成的对象首先都是放在年轻代中。年轻代的目标就是尽可能快速地回收哪些生命周期短的对象。

新生代内存按照8:1:1的比例分为一个Eden区和两个survivor(survivor0,survivor1)区。

* Eden区，字面意思翻译过来，就是伊甸区，人类生命开始的地方。当一个实例被创建了，首先会被存储在该区域内，大部分对象在Eden区中生成。
* Survivor区，幸存者区，字面理解就是用于存储幸存下来对象。

回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存放满了后，则将Eden和Survivor0区中存活对象复制到另外一个survivor1区，然后清空Eden和这个Survivor0区，此时的Survivor0区就也是空的了。

然后将Survivor0区和Survivor1区交换，即保持Servivor1为空，如此往复。

当Survivor1区不足以存放Eden区和Survivor0的存活对象时，就将存活对象直接放到年老代。如果年老代也满了，就会触发一次Major GC(即Full GC)，即新生代和年老代都进行回收。

新生代发生的GC也叫做 **Minor GC** ，MinorGC发生频率比较高，不一定等Eden区满了才会触发。

**为什么设置两个survivor区域？**

如果只有一个eden区和一个survivor区，那么假设场景，当发生ygc后，存活对象从eden迁移到survivor，这样看好像没什么问题，很棒，但是假设eden满了，这个时候要进行ygc，那么发现此时，eden和survivor都保存有存活对象，那么你是不是要对这两个区域进行gc，找出存活对象，那么你想想是不是难度很大，还容易造成碎片，如果你使用复制算法，那么难度很大，如果你使用标记清除算法，那么容易造成内存碎片，如果你使用标记清除算法，那么耗时很长。

​所以如果存在两个survivor区，那么工作就非常的 轻松，只需要在eden区和其中一个survivor（b1）找出存活对象，一次性放到另一个空的survivor（b2），然后再直接清除eden区和survivor（b1），这样效率是不是很快？快的一。

#### 年老代(Old Generation)

在新生代中经历了多次GC后仍然存活的对象，就会被放入到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。

年老代比新生代内存大很多（大概比例2:1？），当年老代中存满时触发Major GC，即Full GC，Full GC发生频率比较低，年老代对象存活时间较长，存活率比较高。

此处采用Compacting算法，由于该区域比较大，而且通常对象生命周期比较长，compaction需要一定的时间，所以这部分的GC时间比较长。

#### 持久代(Permanent Generation)
持久代用于存放静态文件，如Java类、方法等，该区域比较稳定，对GC没有显著影响。这一部分也被称为运行时常量，有的版本说JDK1.7后该部分从方法区中移到GC堆中，有的版本却说，JDK1.7后该部分被移除，有待考证。


## 类文件的结构
### 魔数
每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。
### 版本号
紧接着魔数的4个字节存储的是Class文件的版本号，Class文件的版本号每个字节都有意义，前2个字节是次版本号（Minor Version），后2个字节是主版本号（Major Version）。
### 常量池
紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：
    * 被模块导出或者开放的包（Package）
    * 类和接口的全限定名（Fully Qualified Name）
    * 字段的名称和描述符（Descriptor）
    * 方法的名称和描述符
    * 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
    * 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

### 访问标志
紧接着常量池结束的是访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。

### 类索引、父类索引与接口索引集合
类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合。Class文件中由这三项数据来确定这个类的继承关系。

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言的单继承性，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不会是0。

接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。

### 字段表集合
字段表（Field Table）用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。

字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

### 方法表集合
方法表（Method Table）用于描述接口或者类中声明的方法。

方法表集合中不会列出从父类或者父接口中继承而来的方法，但有可能列出原本Java代码之中不存在的方法，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

### 属性表集合
属性表（Attribute Table）用于描述某些场景专有的信息。

## 类加载

### 类生命周期
一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。

![jvm_class_lifecycle](/assets/img/blog/blogs_class_lifecycle.png){:loading="lazy"}

解析阶段在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。

这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。

#### 类初始化的六种时机

**类加载的时机看作和类初始化的时机是一致的** ，因为初始化的时候，加载，验证准备等阶段一定是在这之前完成的。

关于初始化的时机，《Java虚拟机规范》则是严格规定了 **有且只有** 六种情况必须立即对类进行“初始化”：

1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：
    * 使用new关键字实例化对象的时候。
    * 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
    * 调用一个类型的静态方法的时候。
1. 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
1. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。1. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
1. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
1. 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

这六种场景中的行为称为对一个类型进行 **主动引用** 。除此之外，所有引用类型的方式都不会触发初始化，称为 **被动引用** 。

容易弄错的情况：

**类里面的static常量**

static常量在编译时，通过常量传播优化，会被放入调用该类的常量池中。外面的代码运行时如果只是调用到这个变量，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

```java
class ConstClass {
    static {
        System.out.println("ConstClass static block");
    }
    public static final String HELLOWORLD = "hello world";
}

public class Test {
    static {
        System.out.println("Test static block");
    }
    public static void main(String[] args) {
        System.out.println(ConstClass.HELLOWORLD);
    }
}
```

**创建一个包装类型的数组**

```java
public class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
    public static int value = 123;
}

/**
 * 被动使用类字段演示二：
 * 通过数组定义来引用类，不会触发此类的初始化
 **/
public class NotInitialization {
    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];
    }
}
```
没有看到“SuperClass init!”，说明没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但是这段代码里面触发了
另一个名为“\[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。

Java语言中对数组的访问要比C/C++相对安全，很大程度上就是因为这个类包装了数组元素的访问，而C/C++中则是直接翻译为对数组指针的移动。在Java语言里，当检查到发生数组越界时会抛出 ```java.lang.ArrayIndexOutOfBoundsException``` 异常，避免了直接造成非法内存访问。

#### 加载（Loading）过程
在加载阶段，Java虚拟机需要完成以下三件事情：
> 1）通过一个类的全限定名来获取定义此类的二进制字节流。
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。

通过一个类的全限定名来获取定义此类的二进制字节流”这条规则，它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。

**开放定义带来的好处**

这也是JVM可以让其他技术借由它遍地开花的主要原因。

* 从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。
* 从网络中获取，这种场景最典型的应用就是Web Applet。
* 运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。
* 由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。
* 从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。
* 可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。

#### 验证（Verification）过程
验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。

##### 文件格式验证
* 是否以魔数0xCAFEBABE开头。
* 主、次版本号是否在当前Java虚拟机接受范围之内。
* 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。
* 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
* CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。
* Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
* ……

##### 元数据验证
* 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。
* 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。
* 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
* 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。
* ……

##### 字节码验证
* 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。
* 保证跳转指令不会跳转到方法体以外的字节码指令上。
* 保证方法体内的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。
##### 符号引用验证
* 符号引用中通过字符串描述的全限定名是否能找到对应的类。
* 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
* 符号引用中的类、字段、方法的访问性（private、protected、public、）是否可被当前类访问。

#### 准备（Preparation）过程
准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并 **设置类变量初始值** 的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK 7及之前， **HotSpot使用永久代来实现方法区** 时，实现是完全符合这种逻辑概念的；而在JDK 8及之后， **类变量则会随着Class对象一起存放在Java堆中** ，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。

需要注意，这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

关于初始值，举一个例子：

```java
public static int value = 123;
```

那变量value在准备阶段过后的初始值为0而不是123，因为这时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。

常见的类型的零值：

![blog_jvm_class_zero](/assets/img/blog/blog_jvm_class_zero.png){:loading="lazy"}

#### 解析（Resolution）过程
解析阶段是Java虚拟机将常量池内的 **符号引用替换为直接引用** 的过程。

* 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
* 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

解析动作主要针对 **类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符** 这7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CON-STANT_Fieldref_info、
CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、
CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和
CONSTANT_InvokeDynamic_info 8种常量类型。

##### 类或接口的解析
如果类 **D** 要在解析过程中，对一个未解析过符号引用 **N** 的类或接口 **C** 进行解析，需要包括以下三个步骤：
* 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。
* 如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“\[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。
* 如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，以确保解析结果能在虚拟机中使用。如果验证不通过，将抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.AbstractMethodError、java.lang.InstantiationError等。

**访问权限验证**

如果我们说一个D拥有C的访问权限，那就意味着以下3条规则中至少有其中一条成立：
* 被访问类C是public的，并且与访问类D处于同一个模块。
* 被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块允许被访问类D的模块进行访问。
* 被访问类C不是public的，但是它与访问类D处于同一个包中。

##### 字段解析
