---
layout: post
description: > 
  本文介绍了Android的开机启动流程
image: 
  path: /assets/img/blog/blogs_jvm_cover.png
  srcset: 
    1920w: /assets/img/blog/blogs_jvm_cover.png
    960w:  /assets/img/blog/blogs_jvm_cover.png
    480w:  /assets/img/blog/blogs_jvm_cover.png
accent_image: /assets/img/blog/blogs_jvm_cover.png
excerpt_separator: <!--more-->
sitemap: false
---
# JVM原理概要
## 编译器解释器
编译器和解释器都是将高级语言代码转换成机器码的工具，但它们之间有一些关键区别：

* 编译器：一次性将整个程序代码转换成目标机器的可执行文件，执行时无需再进行翻译，因此执行速度通常较快。但编译过程需要额外的时间，且生成的可执行文件在不同平台上不可移植。
* 解释器：逐行解释源代码，并将其转换成机器码执行。解释器不需要生成可执行文件，因此节省了编译时间，但执行速度通常较慢。另外，解释器可以实现跨平台的代码执行，因为源代码在不同平台上均需要解释器来执行。

## jvm核心功能
 JVM的主要作用是执行Java程序的字节码。在Java应用程序开发中，Java源代码首先被编译成字节码文件（.class文件），而不是本地机器码。
 
 这个字节码是一种与平台无关的中间表示，可以在任何支持Java的平台上运行。

JVM字节码的执行过程大概可以分为以下几个步骤：

* 装载：虚拟机启动后，通过类加载器将.class文件加载到内存中，并进行解析。
* 链接：将被引用的类、方法、变量等符号引用转化为直接引用，并将常量池中的符号引用替换为直接引用。
* 初始化：对类进行初始化。包括执行类构造器<clinit>()方法，静态变量赋值等。
* 解释执行：将解析后的字节码逐行解释执行，根据操作码执行相应的操作。
* 编译执行：如果某个方法被多次执行，JIT编译器会将其编译为本地代码，以提高执行效率。
* 垃圾回收：JVM自动进行垃圾回收，将不再使用的对象进行回收，释放内存空间。

总的来说，JVM字节码的执行过程包括“装载-链接-初始化-解释执行/编译执行-垃圾回收”等几个步骤，其中解释执行和编译执行是主要的执行方式。

## 跨平台特性
JVM跨平台兼容性的原因是因为Java程序编译后生成的是字节码（ByteCode）而不是特定平台上的机器码（Machine Code）。也就是说，Java程序并不是直接翻译成本地平台上的机器码，而是转换成JVM可以识别的字节码，最终由JVM解释执行或编译成本地平台上的机器码。

也就是说JVM充当了一个中间层，负责将字节码翻译成特定操作系统的机器码。

这样做的好处是，由于Java程序并不会直接依赖于本地操作系统或硬件，所以只要有支持Java虚拟机的平台，就可以在该平台上运行Java程序，而不需要对程序进行修改。

这种跨平台机制使得Java程序可以在多个操作系统上进行编译和执行，从而使得Java成为一种性能良好、易于移植的语言。因此，JVM被认为是一种跨平台运行的虚拟机，Java也因此而被大量使用。

## Java内存区域
每一个java进程都是运行在一个独立的jvm虚拟机里面的，彼此之间数据隔离不互通。

一个进程所处的Java虚拟机的内存可以用下面这张热门图片概括：

![jvm_ram](/assets/img/blog/blogs_jvm_ram_simple.png){:loading="lazy"}

* 程序计数器：一小块区域， **线程私有** 。记录了每个线程的代码执行到了哪一行,各种循环，判断都是通过这个区域存的数值来走的。Java多线程是时间分片，各个线程在一段时间内占用这个核来执行任务，这个线程切换到另一个线程，其恢复的依据也是计数器的值。
* 虚拟机栈：周期与线程相同，也是 **线程私有** 。每个方法执行时，都会创建一个栈帧， **栈帧里面存储方法内的局部变量表，方法出口等等信息** 。每个方法执行到退出的过程，就是一个个的方法栈帧入栈出栈的过程。这个区域有两个异常，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 ```StackOverflowError``` 异常；如果JVM允许动态扩展，当栈扩展时无法申请到足够的内存会抛出 ```OutOfMemoryError``` 异常。
* 本地方法栈：和虚拟机栈作用一样，但是服务于 **本地的Native方法** 。同样会抛出上面的两种异常。
* Java堆：最大的一块，所有 **线程共享** 的数据。几乎所有的对象实例都在这里保存。Java堆是垃圾收集器管理的内存区域。Java堆可以处于物理上不连续的内存空间中，可以选择固定大小或可扩展。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出 ```OutOfMemoryError``` 异常。
* 方法区： **线程共享** 。用于存储已被虚拟机加载的 **对象类型信息、常量、静态变量、即时编译器编译后的代码缓存** 等数据。对其要求比较宽松，几乎不用考虑垃圾回收，但是回收也是有必要的，主要针对常量的回收和类型卸载。如果方法区无法满足新的内存分配需求时，将抛出 ```OutOfMemoryError``` 异常。
  * 运行时常量池，其是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行期间也可以将新的常量放入池中。
* 直接内存：直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 ```DirectByteBuffer``` 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

更详细的内存分配图如下：

![jvm_ram](/assets/img/blog/blogs_jvm_ram_ext.jpg){:loading="lazy"}

### 对象创建
当遇到new字节码时，首先会检查这个指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

对象所需的内存大小在类加载完成即可完全确定下来。为对象分配内存即把一块确定大小的内存块从Java堆中分离出来使用。

假设Java堆中的内存是规整的，使用的内存在一遍，空闲的内存在另一边，中间放置一个指针作为分界点指示器，那分配内存就是把指针往空闲的区域移动一段距离，这种方式叫 **指针碰撞** 。

如果堆内存是相互交错的，那么虚拟机就必须维护一个列表，记录哪些内存是可用的，分配内存时就是从列表中找到一块足够大的区域给对象实例，再更新纪录，这种方式叫做 **空闲列表** 。

采用哪种方式由垃圾收集器是否带有空间压缩整理的能力决定。
### 并发安全解决方案
对象创建是非常频繁的行为，可能在为对象A分配时，指针还未修改，对象B又从原来的指针指向处开始分配内存。

* 一种方案是采用CAS加失败重试的方式保障更新操作的原子性。

* 另一种方案是把内存分配的操作按照线程划分在不同空间进行，每个线程先在Java堆中划一小块作为本地线程分配缓冲，本地缓冲区用完，分配新的缓冲区才需要同步锁定。

### 分配收尾
分配完成后需要把分配空间全部置零，确保对象实例字段再Java代码中可以不赋初值直接使用。
接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

虚拟机的视角，对象已经分配完成，从程序的视角看，对象创建才看看开始，到其构造函数。
## 对象在堆中的内存分配
分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
### 对象头
分为两部分，首先是对象运行时数据，如哈希码，GC分代信息，锁状态标志等，在32位和64位虚拟机上，这部分数据分别占32bit和64bit。且被设计成动态定义的数据结构，以存储尽量多的数据。
另一部分是类型指针，指向对象元数据的指针，虚拟机根据这个确定对象是哪一个类的实例，并不是所有实例都会保留类型指针。
### 实例数据
我们所定义的各种类型的字段类容，内存分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs）。相同宽度倾向于一起分配，先加载父类定义的，后加载子类自己的。在虚拟机的CompactFields为true时，子类里较短的变量也会插入父类的空隙中以节省空间。
### 对齐填充
对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义.JVM要求对象起始地址必须是8字节的整数倍，即对象占用空间大小也必须是8字节整数倍，不够的部分就会被对齐填充。
### 对象的访问
Java程序通过栈上的reference数据来操作堆上的具体对象。两种方式，通过句柄访问和指针直接访问。

#### 句柄访问
Java堆中将可能会划分出一块内存来作为句柄池，句柄包含对象的示例数据的指针和对象类型数据的指针。

使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

![jvm_find](/assets/img/blog/blogs_jvm_find_token.png){:loading="lazy"}

#### 直接指针
这种方式来访问对象，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。

使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销。由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。

![jvm_find_2](/assets/img/blog/blogs_jvm_find_direct.png){:loading="lazy"}

