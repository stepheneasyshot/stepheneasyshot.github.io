---
layout: post
description: > 
  本文介绍了Android的开机启动流程
image: 
  path: /assets/img/blog/blogs_jvm_cover.png
  srcset: 
    1920w: /assets/img/blog/blogs_jvm_cover.png
    960w:  /assets/img/blog/blogs_jvm_cover.png
    480w:  /assets/img/blog/blogs_jvm_cover.png
accent_image: /assets/img/blog/blogs_jvm_cover.png
excerpt_separator: <!--more-->
sitemap: false
---
# JVM原理概要
## 编译器解释器
编译器和解释器都是将高级语言代码转换成机器码的工具，但它们之间有一些关键区别：

* 编译器：一次性将整个程序代码转换成目标机器的可执行文件，执行时无需再进行翻译，因此执行速度通常较快。但编译过程需要额外的时间，且生成的可执行文件在不同平台上不可移植。
* 解释器：逐行解释源代码，并将其转换成机器码执行。解释器不需要生成可执行文件，因此节省了编译时间，但执行速度通常较慢。另外，解释器可以实现跨平台的代码执行，因为源代码在不同平台上均需要解释器来执行。

## jvm核心功能
 JVM的主要作用是执行Java程序的字节码。在Java应用程序开发中，Java源代码首先被编译成字节码文件（.class文件），而不是本地机器码。
 
 这个字节码是一种与平台无关的中间表示，可以在任何支持Java的平台上运行。

JVM字节码的执行过程大概可以分为以下几个步骤：

* 装载：虚拟机启动后，通过类加载器将.class文件加载到内存中，并进行解析。
* 链接：将被引用的类、方法、变量等符号引用转化为直接引用，并将常量池中的符号引用替换为直接引用。
* 初始化：对类进行初始化。包括执行类构造器<clinit>()方法，静态变量赋值等。
* 解释执行：将解析后的字节码逐行解释执行，根据操作码执行相应的操作。
* 编译执行：如果某个方法被多次执行，JIT编译器会将其编译为本地代码，以提高执行效率。
* 垃圾回收：JVM自动进行垃圾回收，将不再使用的对象进行回收，释放内存空间。

总的来说，JVM字节码的执行过程包括“装载-链接-初始化-解释执行/编译执行-垃圾回收”等几个步骤，其中解释执行和编译执行是主要的执行方式。

## 跨平台特性
JVM跨平台兼容性的原因是因为Java程序编译后生成的是字节码（ByteCode）而不是特定平台上的机器码（Machine Code）。也就是说，Java程序并不是直接翻译成本地平台上的机器码，而是转换成JVM可以识别的字节码，最终由JVM解释执行或编译成本地平台上的机器码。

也就是说JVM充当了一个中间层，负责将字节码翻译成特定操作系统的机器码。

这样做的好处是，由于Java程序并不会直接依赖于本地操作系统或硬件，所以只要有支持Java虚拟机的平台，就可以在该平台上运行Java程序，而不需要对程序进行修改。

这种跨平台机制使得Java程序可以在多个操作系统上进行编译和执行，从而使得Java成为一种性能良好、易于移植的语言。因此，JVM被认为是一种跨平台运行的虚拟机，Java也因此而被大量使用。

## Java内存区域
每一个java进程都是运行在一个独立的jvm虚拟机里面的，彼此之间数据隔离不互通。

一个进程所处的Java虚拟机的内存可以用下面这张热门图片概括：

![jvm_ram](/assets/img/blog/blogs_jvm_ram_simple.png){:loading="lazy"}

* 程序计数器：一小块区域， **线程私有** 。记录了每个线程的代码执行到了哪一行,各种循环，判断都是通过这个区域存的数值来走的。Java多线程是时间分片，各个线程在一段时间内占用这个核来执行任务，这个线程切换到另一个线程，其恢复的依据也是计数器的值。
* 虚拟机栈：周期与线程相同，也是 **线程私有** 。每个方法执行时，都会创建一个栈帧， **栈帧里面存储方法内的局部变量表，方法出口等等信息** 。每个方法执行到退出的过程，就是一个个的方法栈帧入栈出栈的过程。这个区域有两个异常，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 ```StackOverflowError``` 异常；如果JVM允许动态扩展，当栈扩展时无法申请到足够的内存会抛出 ```OutOfMemoryError``` 异常。
* 本地方法栈：和虚拟机栈作用一样，但是服务于 **本地的Native方法** 。同样会抛出上面的两种异常。
* Java堆：最大的一块，所有 **线程共享** 的数据。几乎所有的对象实例都在这里保存。Java堆是垃圾收集器管理的内存区域。Java堆可以处于物理上不连续的内存空间中，可以选择固定大小或可扩展。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出 ```OutOfMemoryError``` 异常。
* 方法区： **线程共享** 。用于存储已被虚拟机加载的 **对象类型信息、常量、静态变量、即时编译器编译后的代码缓存** 等数据。对其要求比较宽松，几乎不用考虑垃圾回收，但是回收也是有必要的，主要针对常量的回收和类型卸载。如果方法区无法满足新的内存分配需求时，将抛出 ```OutOfMemoryError``` 异常。
  * 运行时常量池，其是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行期间也可以将新的常量放入池中。
* 直接内存：直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 ```DirectByteBuffer``` 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

更详细的内存分配图如下：

![jvm_ram](/assets/img/blog/blogs_jvm_ram_ext.jpg){:loading="lazy"}

### 对象创建
当遇到new字节码时，首先会检查这个指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

对象所需的内存大小在类加载完成即可完全确定下来。为对象分配内存即把一块确定大小的内存块从Java堆中分离出来使用。

假设Java堆中的内存是规整的，使用的内存在一遍，空闲的内存在另一边，中间放置一个指针作为分界点指示器，那分配内存就是把指针往空闲的区域移动一段距离，这种方式叫 **指针碰撞** 。

如果堆内存是相互交错的，那么虚拟机就必须维护一个列表，记录哪些内存是可用的，分配内存时就是从列表中找到一块足够大的区域给对象实例，再更新纪录，这种方式叫做 **空闲列表** 。

采用哪种方式由垃圾收集器是否带有空间压缩整理的能力决定。
### 并发安全解决方案
对象创建是非常频繁的行为，可能在为对象A分配时，指针还未修改，对象B又从原来的指针指向处开始分配内存。

* 一种方案是采用CAS加失败重试的方式保障更新操作的原子性。

* 另一种方案是把内存分配的操作按照线程划分在不同空间进行，每个线程先在Java堆中划一小块作为本地线程分配缓冲，本地缓冲区用完，分配新的缓冲区才需要同步锁定。

### 分配收尾
分配完成后需要把分配空间全部置零，确保对象实例字段再Java代码中可以不赋初值直接使用。
接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

虚拟机的视角，对象已经分配完成，从程序的视角看，对象创建才看看开始，到其构造函数。
## 对象在堆中的内存分配
分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
### 对象头
分为两部分，首先是对象运行时数据，如哈希码，GC分代信息，锁状态标志等，在32位和64位虚拟机上，这部分数据分别占32bit和64bit。且被设计成动态定义的数据结构，以存储尽量多的数据。
另一部分是类型指针，指向对象元数据的指针，虚拟机根据这个确定对象是哪一个类的实例，并不是所有实例都会保留类型指针。
### 实例数据
我们所定义的各种类型的字段类容，内存分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs）。相同宽度倾向于一起分配，先加载父类定义的，后加载子类自己的。在虚拟机的CompactFields为true时，子类里较短的变量也会插入父类的空隙中以节省空间。
### 对齐填充
对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义.JVM要求对象起始地址必须是8字节的整数倍，即对象占用空间大小也必须是8字节整数倍，不够的部分就会被对齐填充。
### 对象的访问
Java程序通过栈上的reference数据来操作堆上的具体对象。两种方式，通过句柄访问和指针直接访问。

#### 句柄访问
Java堆中将可能会划分出一块内存来作为句柄池，句柄包含对象的示例数据的指针和对象类型数据的指针。

使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

![jvm_find](/assets/img/blog/blogs_jvm_find_token.png){:loading="lazy"}

#### 直接指针
这种方式来访问对象，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。

使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销。由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。

![jvm_find_2](/assets/img/blog/blogs_jvm_find_direct.png){:loading="lazy"}



## 垃圾回收
垃圾回收，即GC(Garbage Collection)，回收无用内存空间，使其对未来实例可用的过程。由于设备的内存空间是有限的，为了防止内存空间被占满导致应用程序无法运行，就需要对无用对象占用的内存进行回收，也称垃圾回收。 垃圾回收过程中除了会清理废弃的对象外，还会清理内存碎片，完成内存整理。
### 判断对象是否存活的方法
GC堆内存中存放着几乎所有的对象（方法区中也存储着一部分），垃圾回收器在对该内存进行回收前，首先需要确定这些对象哪些是“活着”，哪些已经“死去”，内存回收就是要回收这些已经“死去”的对象。

那么如何其判断一个对象是否还“活着”呢？方法主要由如下两种：

#### 引用计数法
该算法由于无法处理对象之间相互循环引用的问题，在Java中并未采用该算法，在此不做深入探究；

#### 根搜索算法（GC ROOT Tracing）
Java中采用了该算法来判断对象是否是存活的，也叫可达性分析。

通过一系列名为 **GC Roots** 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论来说就是从GC Roots到这个对象不可达）时，则证明对象是不可用的，即该对象是“死去”的，同理，如果有引用链相连，则证明对象可以，是“活着”的。


哪些可以作为GC Roots的对象呢？Java 语言中包含了如下几种：

        1）虚拟机栈（栈帧中的本地变量表）中的引用的对象。

        2）方法区中的类静态属性引用的对象。

        3）方法区中的常量引用的对象。

        4）本地方法栈中JNI（即一般说的Native方法）的引用的对象。

        5）运行中的线程

        6）由引导类加载器加载的对象

        7）GC控制的对象

### 回收流程
现代商用虚拟机基本都采用分代收集算法来进行垃圾回收，当然这里的分代算法是一种混合算法，不同时期采用不同的算法来回收。

 由于不同的对象的生命周期不一样，分代的垃圾回收策略正式基于这一点。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。该算法包含三个区域：年轻代(Young Generation)、年老代(Old Generation)、持久代(Permanent Generation)。

![jvm_find](/assets/img/blog/blogs_jvm_generation.png){:loading="lazy"}
 
#### 年轻代(Young Generation)
所有新生成的对象首先都是放在年轻代中。年轻代的目标就是尽可能快速地回收哪些生命周期短的对象。

新生代内存按照8:1:1的比例分为一个Eden区和两个survivor(survivor0,survivor1)区。

* Eden区，字面意思翻译过来，就是伊甸区，人类生命开始的地方。当一个实例被创建了，首先会被存储在该区域内，大部分对象在Eden区中生成。
* Survivor区，幸存者区，字面理解就是用于存储幸存下来对象。

回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存放满了后，则将Eden和Survivor0区中存活对象复制到另外一个survivor1区，然后清空Eden和这个Survivor0区，此时的Survivor0区就也是空的了。

然后将Survivor0区和Survivor1区交换，即保持Servivor1为空，如此往复。

当Survivor1区不足以存放Eden区和Survivor0的存活对象时，就将存活对象直接放到年老代。如果年老代也满了，就会触发一次Major GC(即Full GC)，即新生代和年老代都进行回收。

新生代发生的GC也叫做 **Minor GC** ，MinorGC发生频率比较高，不一定等Eden区满了才会触发。

#### 年老代(Old Generation)

在新生代中经历了多次GC后仍然存活的对象，就会被放入到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。

年老代比新生代内存大很多（大概比例2:1？），当年老代中存满时触发Major GC，即Full GC，Full GC发生频率比较低，年老代对象存活时间较长，存活率比较高。

此处采用Compacting算法，由于该区域比较大，而且通常对象生命周期比较长，compaction需要一定的时间，所以这部分的GC时间比较长。

#### 持久代(Permanent Generation)
持久代用于存放静态文件，如Java类、方法等，该区域比较稳定，对GC没有显著影响。这一部分也被称为运行时常量，有的版本说JDK1.7后该部分从方法区中移到GC堆中，有的版本却说，JDK1.7后该部分被移除，有待考证。

