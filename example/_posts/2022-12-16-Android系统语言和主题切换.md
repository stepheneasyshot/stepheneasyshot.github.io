---
layout: post
description: > 
  本文介绍了应用层定义AIDL接口并使用它通信的简单手法。
image: 
  path: /assets/img/blog/blogs_system_configration.png
  srcset: 
    1920w: /assets/img/blog/blogs_system_configration.png
    960w:  /assets/img/blog/blogs_system_configration.png
    480w:  /assets/img/blog/blogs_system_configration.png
accent_image: /assets/img/blog/blogs_system_configration.png
excerpt_separator: <!--more-->
sitemap: false
---
# Android系统语言和主题切换
以下各个api的开发与测试均在车载设备上，可能在手机上不一定生效。并且只有系统权限的app才可以调用。

## 触发入口调用
### 主题切换
主题切换可以直接使用系统的UiModeManager即可。

```kotlin
    private val uimodeManager =
        appContext.getSystemService(UI_MODE_SERVICE) as UiModeManager

```

深浅主题切换调用：

```java
    /**
     * Sets the system-wide night mode.
     * are only effective when the {@link Configuration#UI_MODE_TYPE_CAR car}
     * or {@link Configuration#UI_MODE_TYPE_DESK desk} mode is enabled on a
     * device. On API 23 through API 28, changes to night mode are always effective.
     * <p>
     * Starting in API 29, when the device is in car mode and this method is called, night mode
     * will change, but the new setting is not persisted and the previously persisted setting
     * will be restored when the device exits car mode.
     * <p>
     * Changes to night mode take effect globally and will result in a configuration change
     * (and potentially an Activity lifecycle event) being applied to all running apps.
     * Developers interested in an app-local implementation of night mode should consider using
     * {@link #setApplicationNightMode(int)} to set and persist the -night qualifier locally or
     * {@link androidx.appcompat.app.AppCompatDelegate#setDefaultNightMode(int)} for the
     * backward compatible implementation.
     *
     * @param mode the night mode to set
     * @see #getNightMode()
     * @see #setApplicationNightMode(int)
     */
    public void setNightMode(@NightMode int mode) {
        if (mService != null) {
            try {
                mService.setNightMode(mode);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
```

我们自定义的触发按钮，按下时可以调用：

```kotlin
mMainView.findViewById<Button>(R.id.btn_night).setOnClickListener {
    uimodeManager.nightMode = UiModeManager.MODE_NIGHT_YES
}

mMainView.findViewById<Button>(R.id.btn_light).setOnClickListener {
    uimodeManager.nightMode = UiModeManager.MODE_NIGHT_NO
}
```

### 语言切换
通过反射调用ActivityManager的方法，即可实现语言切换。

```kotlin
    /**
     * 切换语言
     * @param language 语言
     */
    fun changeLanguageSettings(language: Locale) {
        try {
            val activityManagerNative = Class.forName("android.app.ActivityManager")
            val am = activityManagerNative.getMethod("getService").invoke(activityManagerNative)
            val config = am?.javaClass?.getMethod("getConfiguration")
                ?.invoke(am) as Configuration
            config.setLocale(language)
            config.javaClass.getDeclaredField("userSetLocale").setBoolean(config, true)
            am.javaClass.getMethod("updatePersistentConfiguration", config.javaClass)
                .invoke(am, config)
            BackupManager.dataChanged("com.android.providers.settings")
        } catch (e: Exception) {
            e.message?.let { error(it) }
        }
    }
```

触发按钮调用：

```kotlin
mMainView.findViewById<Button>(R.id.btn_chinese).setOnClickListener {
    changeLanguageSettings(Locale.SIMPLIFIED_CHINESE)
}

mMainView.findViewById<Button>(R.id.btn_english).setOnClickListener {
    changeLanguageSettings(Locale.ENGLISH)
}
```

## 其他app适配
### Activity型应用
#### 资源目录设置
首先我们需要在res资源目录下添加对应的语言和主题的资源目录。

**语言目录**


切换主题和UI时，Activity会销毁重建，


### Service加浮窗型应用