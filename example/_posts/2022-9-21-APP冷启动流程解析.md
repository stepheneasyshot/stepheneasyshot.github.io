---
layout: post
description: > 
  本文为launcher图标拉起app的全流程解析
image: 
  path: /assets/img/blog/blogs_app_cold_start.png
  srcset: 
    1920w: /assets/img/blog/blogs_app_cold_start.png
    960w:  /assets/img/blog/blogs_app_cold_start.png
    480w:  /assets/img/blog/blogs_app_cold_start.png
accent_image: /assets/img/blog/blogs_app_cold_start.png
excerpt_separator: <!--more-->
sitemap: false
---
# APP冷启动流程解析
从用户手指点击桌面上的应用图标到屏幕上显示出应用主Activity界面而完成应用启动，快的话往往都不需要一秒钟，但是这整个过程却是十分复杂的，其中涉及了Android系统的几乎所有核心知识点。

同时应用的启动速度也绝对是系统的核心用户体验指标之一，多少年来，无论是谷歌或是手机系统厂商们还是各个Android应用开发者，都在为实现应用打开速度更快一点的目标而不断努力。

## 概要图
![cold_start](/assets/img/blog/blogs_cold_start.png)

## 流程详解
### 事件传递到launcher图标view
手指按下后，硬件到驱动到系统侧链路暂且不看。

#### System部分
Android 系统是由事件驱动的，而 input 是最常见的事件之一，用户的点击、滑动、长按等操作，都属于 input 事件驱动，其中的核心就是 ```InputReader``` 和 ```InputDispatcher``` 。InputReader 和 InputDispatcher 是跑在 SystemServer进程中的两个 native 循环线程，负责读取和分发 Input 事件。

* InputReader负责从EventHub里面把Input事件读取出来，然后交给 InputDispatcher 进行事件分发；
* InputDispatcher在拿到 InputReader获取的事件之后，对事件进行包装后，寻找并分发到目标窗口;

system_server的native线程 InputReader 读取到了一个触控事件。它会唤醒 InputDispatcher 去进行事件分发，先放入InboundQueue 队列中，再去寻找处理事件的窗口，找到窗口后就会放入OutboundQueue队列，等待通过socket通信发送到launcher应用的窗口中，此时事件处于 ```WaitQueue``` 中，等待事件被处理，若5s内没有处理，就会向systemserver报ANR异常。

![input_event](/assets/img/blog/blogs_input_event.jpg)

#### Launcher部分
Launcher进程接收到之后，通过enqueueInputEvent函数放入“aq”本地待处理队列中，唤醒UI线程的deliverInputEvent流程进行事件分发处理，具体交给界面window里的类型来处理。

从View布局树的根节点DecorView开始遍历整个View树上的每一个子View或ViewGroup界面进行事件的分发、拦截、处理的逻辑。

这次的触摸事件被消耗后，Launcher及时调用finishInputEvent结束应用的处理逻辑，再通过JNI调用到native层InputConsumer的 ```sendFinishedSignal``` 函数通知 ```InputDispatcher``` 事件处理完成，及时从waitqueue里移除待处理事件，避免ANR异常。

**整个处理流程是按照责任链的设计模式进行**

### Launcher到AMS的binder调用
上一轮Input事件传到图标view后，通过一个ACTION_DOWN的TouchEvent触控事件和多个ACTION_MOVE，直到最后出现一个ACTION_UP的TouchEvent事件后，去判断是click点击事件。

就开始通过 ```ActivityManager Binder``` 调用AMS的 ```startActivity``` 服务接口准备启动应用。

```java
private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
                int startFlags, boolean doResume, ActivityOptions options, Task inTask,
                boolean restrictedBgActivity, NeededUriGrants intentGrants) {
        ...
        try {
            ...
            // 添加“startActivityInner”的systrace tag
            Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, "startActivityInner");
            // 执行startActivityInner启动应用的逻辑
            result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,
                    startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
            ...
        }
        ...
    }
```

上面AMS的startActivityUnchecked函数，开始和结尾都会添加traceTAG记录时间，中间则是调用 startActivityInner 方法来启动应用。这个方法首先检查当前Activity栈里处于onresume状态的Activity，如果当前不是目标Activity，就通知这个Activity进入Pause状态。等这个对应的进程把其Activity的 pause 操作执行完毕后，执行 

```java
ActivityTaskManager.getService().activityPaused(token)
```

会通知到AMS，AMS则继续启动应用的逻辑。

先判断需要启动应用进程如果存在，调用realStartActivityLocked，如果进程不存在，就会startProcessAsync创建进程。

拉起一个应用进程，具体是AMS通过Socket连接到Zygote进程开机时创建好的服务端，通知Zygote进程去fork一个新进程，即ZygoteProcess.start(...)方法。

在ZygoteProcess#startViaZygote函数中，拿到创建进程的参数，返回一个列表，里面含有pid等信息。

Zygote开机时就会创建ZygoteServer对象，调用runSelectLoop进入死循环等待AMS的请求。

### Zygote进程fork应用进程
ZygoteServer接收到请求后，去fork一个进程，fork采用copy-on-write技术，这是linux创建进程的标准方法，调用一次，返回两次，返回值有3种类型，父进程里是新的子进程的pid，子进程返回的是0，为负数则表示出错了。父进程去把pid通过socket发送到AMS，子进程通过调用handleChildProc函数，关闭父进程继承来的服务地址，再做一些通用的初始化工作，比如启用Binder机制，执行应用程序的入口函数。========子进程里有三个重要方法，需要通过RuntimeInit#commonInit启用Java默认异常处理机制，nativeZygoteInit函数中JNI调用启动进程的binder线程池，最后返回通过RuntimeInit#applicationInit中反射创建ActivityThread对象并调用其“main”入口方法。进入到子进程内部逻辑。

### 目标APP的内部逻辑
#### 建立消息机制
ActivityThread对象的main方法，里面主要分两步，一是创建主线程并prepare来启动消息循环，二是通过binder调用AMS的attachApplication接口，将自己注册到AMS中。========继续分析主线程消息循环机制的建立，Looper.prepareMainLooper()，通过prepare，创建MassageQueue队列，准备主线程的Looper，通过ThreadLocal机制实现与主线程的一对一绑定。========以上一切完成后，主线程就进入阻塞状态，等待massage。ActivityThread通过Handler来处理Massage。四大组件和Application的生命周期函数均是message的形式在主线程按照顺序处理。========Looper循环器，其loop方法开启后，不断地从MessageQueue中获取Message；MessageQueue 就是一个 Message 管理器，队列中是 Message，在没有 Message 的时候，MessageQueue借助Linux的ePoll机制，阻塞休眠等待，直到有Message进入队列将其唤醒。Message 是传递消息的对象，其内部包含了要传递的内容，最常用的包括 what、arg、callback 等。

#### 将自己的进程注册到AMS
上面是应用内的消息机制建立和初始化，看看AMS怎么处理这个进程的attach注册请求的。AMS接收到请求后，通过oneway类型的binder调用此进程的bindApplication 接口，里面会往主线程的消息队列中post一个BIND_APPLICATION的消息，触发主线程的handleBindApplication。========这个方法里通过AMS发过来的ApplicationInfo，创建LoadedApk对象；创建Application的Context；触发Art虚拟机加载应用APK的Dex文件到内存中；通过LoadedApk 加载应用的Resource资源；LoadedApk的makeApplication方法创建Application对象；最后执行onCreate函数。到这里就到了应用开发者发挥的地方了。

#### Dex文件加载
背景：Java代码在JVM被编译成字节码，再翻译成机器语言来运行。而DVM即Dalvik虚拟机不能和JVM一样能直接运行Java字节码，它只能运行.dex文件。dex文件是由Java的字节码通过Android的dx生成工具来生成的，这个过程就是打包apk的流程。

后面5.0后推出的ART虚拟机，相比Dalvik的JIT实时编译，是在启动时将dex转换成机器码，ART采用了AOT预先编译，在安装apk时就把dex文件转换成可以直接运行的oat文件，其可以支持多dex，大幅提升冷启动速度。缺点是安装速度变慢。

上一轮的Context对象创建后，通过packageInfo.getResources()去加载加载APK的Resource资源赋给context，这个方法中需要getClassLoader获取类加载器，触发ART虚拟机加载dex文件。

#### 资源文件加载
加载应用的Resource。上面getResources方法里，创建ResourcesImpl时，会调用到createAssetManager方法，AssetManager这是实际加载解析apk的类，通过路径去加载ApkAssets.loadFromPath(key.path, key.sharedLib ? ApkAssets.PROPERTY_DYNAMIC : 0)，通过JNI调用Native层的系统system/lib/libandroidfw.so库中的相关C函数实现对APK文件压缩包的解析与加载。

#### 创建Activity
上面AMS接收到新进程的Application绑定请求之后，反馈其bindApplication接口后，立即开始执行启动Activity的流程。简要流程是框架system_server进程最终是通过ActivityStackSupervisor#realStartActivityLocked函数中，通过LaunchActivityItem和ResumeActivityItem两个类的封装，依次实现binder调用通知应用进程这边执行Activity的Launch和Resume动作。========主线程调用到ActivityThread的handleLaunchActivity函数在主线程执行应用Activity的Launch创建动作，这个方法里会执行performLaunchActivity(r, customIntent)，其中创建Activity的Context，通过反射创建activity对象，再调用其attach方法，创建应用窗口的PhoneWindow对象，并配置WindowManager。然后通过mInstrumentation.callActivityOnCreate(activity, r.state)执行其onCreate周期，在setContentView调用中创建DecorView对象。==========Activity和窗口创建完成后，ActivityThread调用handleResumeActivity来执行其onResume流程，WindowManager#addView动作开启视图绘制逻辑，创建ViewRootImpl对象，并调用其setView方法。===========setView内部会开启硬件加速，调用requestLayout来触发界面绘制（measure、layout、draw）动作。通过Binder调用WMS的addView操作，注册应用窗口，创建WindowInputEventReceiver对象，传入本地创建inputChannel对象用于后续接收系统的触控事件。最后将DocorView的parent设置为自己，所以ViewRootImpl不是一个View,但它是所有View的顶层Parent。

#### View绘制流程
requestLayout()首先进行线程检查，然后给主线程MessageQueue队列里增加同步栏删，保证卡住同步消息，只让异步消息通过，使绘制消息属于高优先级。通过 mChoreographer.postCallback，往主线程消息队列添加CALLBACK_TRAVERSAL绘制类型的待执行消息，用于触发后续UI线程真正实现绘制动作。Choreographer背景，配合系统的VSync垂直同步机制，每次VSync信号到来，就绘制一帧，给app的渲染提供一个稳定的Message处理时机。其在渲染链路中承上启下，统筹处理app的消息和回调，输入事件，动画，Traversal等，到下一次Vsync信号来的时候统一处理，对下他负责接收和请求VSync信号。ViewRootImpl推送待执行的消息之后，Choreographer向系统申请APP的VSync信号，等待信号到来之后，调用到doTraversal方法去执行真正的绘制操作。

#### doTraversal绘制操作
测量，布局，绘制。首先移除同步栏删，removeSyncBarrier，避免主线程接受不了同步消息假死。然后再执行具体绘制，从DecorView根节点遍历整个View树，完成measure操作。首次执行traversal操作时，通过Binder调用WMS的relayout接口，实现WMS计算窗口尺寸，向系统的surfaceflinger申请Surface画布操作，再由本地surface获取远端分配的surface的引用。画布有了准备进行layout布局，同样从DecorView根节点遍历，完成布局操作。最后的绘制如果开启了硬件加速，则走GPU硬件绘制，否则走CPU软件绘制。========这三大步走完之后，应用界面的内容用户依然还不可见，需要由RenderThread线程的渲染处理，渲染完成后，还需要通过Binder调用“上帧”交给surfaceflinger进程中进行合成后送显才能最终显示到屏幕上。========硬件加速的绘制流程，遍历DecorView树，递归调用每个子View节点的updateDisplayListIfDirty函数，最终完成绘制树的创建。再通过JNI调用到Native层的RenderThread渲染线程，并唤醒渲染线程利用OpenGL执行渲染任务。==========总结，应用在UI线程中从根节点DecorView出发，递归遍历每个子View节点，搜集其drawXXX绘制动作并转换成DisplayListOp命令，将其记录到DisplayListData并填充到RenderNode中，最终完成整个View绘制命令树的构建。从此UI线程的绘制任务就完成了。

#### C++层面的RenderThread 渲染流程
syncFrameState中遍历View树上每一个RenderNode，执行prepareTreeImpl函数，实现同步绘制命令树的操作；调用OpenGL库API使用GPU，按照构建好的绘制命令完成界面的渲染，将前面已经绘制渲染好的图形缓冲区Binder上帧给SurfaceFlinger合成和显示。

SurfaceFlinger作为系统中独立运行的一个Native进程，借用Android官网的描述，其为承上启下的角色，就是通过Surface与不同的应用进程建立联系，接收它们写入Surface中的绘制缓冲数据，对它们进行统一合成。然后对下层，通过屏幕的后缓存区与屏幕建立联系，发送合成好的数据到屏幕显示设备。

图形载体为Buffer，Surface为Buffer封装，管理了多个Buffer，内部是通过BufferQueue来管理的。这是一个生产者消费者模型，应用进程为生产者，SurfaceFlinger为消费者。应用进程开始界面渲染之前，通过Binder向SurfaceFlinger申请一张可用的buffer，使用CPU或者GPU渲染之后，将缓存数据返回给进程对应的BufferQueue，等其可用时申请sf类型的VSync信号，通知SurfaceFlinger去消费合成。SurfaceFlinger拿取buffer合成结束之后，再度将其置为free状态，返回对应BufferQueue中。