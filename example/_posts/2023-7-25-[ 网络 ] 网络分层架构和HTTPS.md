---
layout: post
description: > 
  本文介绍了Http通信协议的相关内容
image: 
  path: /assets/img/blog/blogs_network_page.jpg
  srcset: 
    1920w: /assets/img/blog/blogs_network_page.jpg
    960w:  /assets/img/blog/blogs_network_page.jpg
    480w:  /assets/img/blog/blogs_network_page.jpg
accent_image: /assets/img/blog/blogs_network_page.jpg
excerpt_separator: <!--more-->
sitemap: false
---
# [ 网络 ] 网络分层架构和HTTPS
TCP/IP模型是实际应用中广泛使用的网络分层架构，它将网络通信分为四个层次：

* 网络接口层：对应于OSI模型的物理层和数据链路层，负责将数据帧从一个网络节点传输到另一个网络节点。
* 网络层：与OSI模型的网络层功能相同，负责在不同网络之间进行路由选择和数据包转发。
* 传输层：与OSI模型的传输层功能相同，提供端到端的可靠数据传输服务。
* 应用层：对应于OSI模型的会话层、表示层和应用层，为用户提供各种网络应用服务。

网络分层架构的优点包括：

* 模块化设计：每个层次都有明确的功能和接口，便于设计、实现和维护。
* 独立性：各层次可以独立发展和更新，互不影响。
* 易于理解：分层架构使得网络通信的过程更加清晰和易于理解。
* 灵活性：可以根据需要在不同层次上添加或修改功能。

通过这种分层架构，网络通信变得更加有序和高效，不同层次的技术可以协同工作，为用户提供可靠的网络服务。

## 网络分层架构
### 为什么要分层？
从客户端到服务器的各节点

![tcpip_layer](/assets/img/blog/blogs_tcpip_layer.png)

网络不稳定，所以需要分层。

比如客户端往服务端发起请求的过程中，中间某个节点如果损坏，客户端需要知道信息没发过去，再次发起重传。
但是如果很大的数据，就会传很多次，原本50ms的时间，可能需要传2s才能完成。解决：把这个大的数据切成5块，这5块分别来传，先把能传成功的全部发过去，如果检索到某一块没有收到，再把对应的块给传过去，就只需要多发20%，效率比较高。

![http](/assets/img/blog/blogs_network_layer_http.png)

分层：有分块传输所以需要分层。上层通信协议众多，http, ftp, mqtt等都有这种分块的需求。**所以把包的分发这个工作专门抽出来一层。上层不管传输了，他们只需要把所有要传的数据准备好，再丢给下层TCP去处理。**

那么有TCP了，为什么还要往下拉一层？

TCP叫传输层，用来传东西，其注重数据完整性。

![tcp](/assets/img/blog/blogs_network_layer_tcp.png)

但是并不是所有数据我们都需要重传，比如CS枪战游戏数据，如果网络卡顿了，这个数据不能再重传了，只需要不断将最新的数据传输过去就行了。这种需求所产生的协议叫UDP，强调传输性能而不是传输的完整性。

这两种协议又都有网络的需求，都需要从一个主机找到另一个主机。

TCP现在也不去传了，只是将数据分块，并全部按顺序的传输，并检测。UDP也一样，只管分块，不用管传输完整性与顺序。

![ip](/assets/img/blog/blogs_network_layer_ip.png)

而下一层的IP只管闷头传，负责寻址，找路由，上层有什么东西丢下来就直接传过去。

阶段小结：这三层都是共同的目的，将数据从一个地方传到另一个地方。 **分层原因都是网络不稳定** ，如果网络稳定，所有东西都可以一次性到达，那就不需要这么麻烦了。

数据链路层：这层就是实际的网络，以太网，比如网线，WIFI。其为网络提供显示的实质的支持。

![link](/assets/img/blog/blogs_network_layer_link.png)

另外还有七层网络模型，它把数据链路层分开了，数据链路层和物理层。物理层为网线，交换器。

具体的分层：
* Application Layer 应⽤层：HTTP、FTP、DNS
* Transport Layer 传输层：TCP、UDP
* Internet Layer ⽹络层：IP
* Link Layer 数据链路层：以太⽹、Wi-Fi

对于应用层工程师来说，可以只关心这四层模型。

## TCP连接
什么叫连接？

TCP是有状态的，他有很多小包需要发送。先建立起第一步通信，来共同确认数据传输包该怎么拼。

连接建立：

![tcp_connection](/assets/img/blog/blogs_tcp_connect.png){:width="200" height="400" loading="lazy"}

连接的关闭：

![blogs_tcp_disconnect.png](/assets/img/blog/blogs_tcp_disconnect.png){:width="200" height="400" loading="lazy"}

## 长连接
### 为什么需要长连接？
首先了解内网，一个网关，其内部有很多的主机，某个主机需要和外部的主机通信，网关会先开一个端口，走这个端口和外界主机通信。内网的主机所占用的端口实际是网关的端口。例如，我们的手机网络都是运行在运营商的内网里面的。
长连接：网关给内部主机开端口通信，需要耗费资源的。当内部主机一段时间里没有进行数据通信，网关会把这个端口给关闭掉。那么过一会，当外部主机再走这个端口想要通信时，就连不上了，网路就断了。为了突破这个限制，让网关不去主动关掉这个端口，就需要定时地通信一次，这就是心跳，实现长连接的方式。网关发现这个端口一直在用，就不会将这个端口给关掉了。
长连接很复杂，需要了解的东西相当多，实现很难。

### HTTPS
HTTP over SSL 的简称，即⼯作在 SSL （或 TLS）上的 HTTP。说⽩了就是加密通信的 HTTP，注意并不是一个单独的协议。

* SSL：Secure Socket Layer
* TSL: Transport Layer Secure

在HTTP之下增加一个安全层，其位于HTTP和TCP之间，更靠近应用层，作用是来加密解密。

本质：在客户端和服务器之间协商出⼀套对称密钥，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输。 **用非对称加密来商讨出一套对称式密钥，再用这个对称密钥来通信。**

为啥不直接用非对称加密通信？因为非对称加密效率低，速度慢。

实现流程:
* 客户端请求建立TLS连接
* 服务器发回证书
* 客户端验证服务器的证书
* 客户端新任服务器之后，和服务器协商对称密钥
* 最后使用对称密钥开始通信

最后一步才进入HTTP通信的范畴，前面均是TCP通信。

* Client Hello 客户端跟服务器请求建立连接，附带告诉服务器，我所支持的TLS版本，还有Cipher Suite加密套件，里面是客户端支持的对称加密算法，非对称加密算法，Hash算法。同时还有一个随机数X。
* Server Hello 服务器给客户端返回数据，选择好TLS版本，算法等。同时返回一个随机数Y。
* 服务器给客户端发送证书，里面核心是非对称加密的公钥，还有服务器的域名，地址，等信息，最后还有服务器的签名，对本次传输所有数据进行签名，表明确实是这个服务器所发。还有证书机构的公钥和证书机构的其他信息签名来对这个服务器的证明数据进行签名，即下图黄色机构对蓝色数据进行签名证明。但是只是可以说明数据确实是由这个公钥对应私钥的持有者所签发。还需要根证书机构的签名对证书机构的签名进行签名，即紫色根证书机构对黄色的证书机构进行签名证明。这个根证书机构的验证来自操作系统内部，到了这一层如果签名能对得上，就可以确定来源的可信了。

![blogs_network_https.png](/assets/img/blog/blogs_network_https.png)

>根证书的来源：在操作系统生产出的时候，被研发方所认证了的，级上方为一个信任链，到最底层的根证书列表就需要无条件信任。根证书机构很忙，需要一个中间机构去分担压力。

* 服务器证书验证就通过了。客户端浏览器拿到服务器公钥的时候，使用这个公钥加密一个信息：
Pre-master Secret，这也是一个随机数。整个通信过程中唯一一次非对称加密来处理的数据。现在就有三个随机数了，X， Y， Pre-master Secret。前两个随机数X, Y大家都能看见，虽然是明文传输，但加上之后就可以使密钥更安全。现在双方就有足够的信息来生产一个对称加密的密钥了。即Master Secret。这个密钥实际上包含四个东西：客户端加密密钥，服务端加密密钥，客户端Hash Key，服务端Hash Key。HMAC：hash-based message authenticate code，改良版的Hash算法。虽然是对称加密，服务端和客户端之间的通信仍然是用不同的加密密钥来通信，客户端发送时使用客户端加密密钥来加密，服务端接收到之后，使用客户端密钥来解密。用作证明身份，双方都会用MAC Secret来作签名和验证。
* 双方作一次验证，看上面沟通的加密算法能不能用。

简要的连接建立过程：
1. Client Hello
2. Server Hello
3. 服务器证书 信任建⽴
4. Pre-master Secret
5. 客户端通知：将使⽤加密通信
6. 客户端发送：Finished
7. 服务器通知：将使⽤加密通信
8. 服务器发送：Finished

问题：如果另一个拥有合法证书的机构把消息拦截下来，而且也发生给客户端一份完整的ServerHello返给客户端，这样可以建立起HTTPS连接吗？
客户端请求时，会将要访问的Host地址附加在报文里。同样，在服务端的证书包里，也会附加Host名。客户端收到之后，会对Host主机地址进行校验，只有两者域名一致才能通过验证继续往下建立连接。签发证书的机构会将证书和域名进行绑定。

### 在Android中使用时
一般都是正常用即可。

需要自己写证书验证过程的场景：
1. ⽤的是⾃签名证书（例如只⽤于内⽹的 https）
2. 证书信息不全，缺乏中间证书机构（可能性不⼤）
3. ⼿机操作系统较旧，没有安装最新加⼊的根证书