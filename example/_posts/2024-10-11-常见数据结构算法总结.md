---
layout: post
description: > 
  本文介绍了常见的数据结构和算法
image: 
  path: /assets/img/blog/blogs_ds_cover.png
  srcset: 
    1920w: /assets/img/blog/blogs_ds_cover.png
    960w:  /assets/img/blog/blogs_ds_cover.png
    480w:  /assets/img/blog/blogs_ds_cover.png
accent_image: /assets/img/blog/blogs_ds_cover.png
excerpt_separator: <!--more-->
sitemap: false
---
# 常见数据结构算法总结
## 八大数据结构
### 数组
数组是一种线性表数据结构，它使用一组连续的内存空间，来存储一组具有相同类型的数据。

C++举例：

```cpp
#include <iostream>

int main() {
    // 定义一个整型数组，大小为5
    int arr[5] = {1, 2, 3, 4, 5};

    // 访问数组元素
    std::cout << "第一个元素: " << arr[0] << std::endl;
    std::cout << "第二个元素: " << arr[1] << std::endl;

    // 修改数组元素
    arr[2] = 10;
    std::cout << "修改后的第三个元素: " << arr[2] << std::endl;

    return 0;
}
```

数组的优点

* 随机访问：由于数组在内存中是连续存储的，因此可以通过索引快速访问任何元素，时间复杂度为O(1)。
* 缓存友好：连续的内存空间使得数组在缓存中更容易被加载和访问，提高了访问效率。
* 简单易用：数组的定义和使用非常简单，易于理解和实现。

数组的缺点

* 大小固定：数组的大小在定义时就确定了，无法动态扩展或缩小。如果需要存储更多的元素，就需要重新定义一个更大的数组，并将原数组的元素复制到新数组中。
* 插入和删除效率低：在数组中插入或删除元素时，需要移动大量的元素，时间复杂度为O(n)。
* 内存浪费：如果数组的大小定义得过大，可能会导致内存浪费；如果定义得过小，可能会导致数据溢出。

数组是一种简单而高效的数据结构，适用于需要快速随机访问元素的场景。然而，由于其 **大小固定和插入删除效率低** 的缺点，在需要动态调整大小或频繁插入删除元素的场景中，可能需要使用其他数据结构，如 **链表** 、 **动态数组** （如C++中的std::vector）等。

### 链表
链表是一种非连续存储的线性结构，每个元素包含 **数据** 和**指向下一个元素的指针**。链表的优点是**插入和删除操作高效**，但**访问速度较慢**。

单向链表每个节点包含数据和指向下一个节点的指针。双向链表每个节点包含数据和 **指向前一个节点和后一个节点** 的指针。

```cpp
#include <iostream>

// 定义链表节点
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

int main() {
    // 创建链表
    ListNode* head = new ListNode(1);
    ListNode* second = new ListNode(2);
    ListNode* third = new ListNode(3);

    head->next = second;
    second->next = third;

    // 访问链表元素
    ListNode* current = head;
    while (current != NULL) {
        std::cout << current->val << " ";
        current = current->next;
    }

    return 0;
}
```

链表的优点

* 动态大小：链表的大小可以动态增长或缩小，不需要预先分配固定大小的内存。
插入和删除高效：在链表中插入或删除元素时，只需要修改指针，不需要移动大量的元素，时间复杂度为O(1)。

链表的缺点

* 随机访问效率低：由于链表的元素不是连续存储的，因此无法通过索引快速访问元素，需要从头开始遍历链表，时间复杂度为O(n)。
* 额外的内存开销：链表的每个节点需要额外的指针来指向下一个节点，增加了内存开销。

链表是一种灵活的数据结构，适用于需要 **频繁插入和删除元素** 的场景。然而，由于其随机访问效率低的缺点，在需要快速随机访问元素的场景中，可能需要使用其他数据结构，如数组、动态数组（如C++中的std::vector）等。

### 栈
栈（Stack）是一种后进先出（LIFO, Last In First Out）的数据结构，它只允许在一端进行插入和删除操作。这一端通常被称为栈顶。栈的操作主要有两种：压入（push）和弹出（pop）。压入操作将元素添加到栈顶，弹出操作则从栈顶移除元素。

```cpp
#include <iostream>
#include <stack>

int main() {
    // 创建一个栈
    std::stack<int> myStack;

    // 压入元素
    myStack.push(1);
    myStack.push(2);
    myStack.push(3);

    // 访问栈顶元素
    std::cout << "栈顶元素: " << myStack.top() << std::endl;

    // 弹出栈顶元素
    myStack.pop();

    // 再次访问栈顶元素
    std::cout << "弹出一个元素后，栈顶元素: " << myStack.top() << std::endl;

    return 0;
}
```

栈的优点

* 简单高效：栈的操作非常简单，只需要在栈顶进行插入和删除操作，时间复杂度为O(1)。
* 内存管理方便：栈的内存管理由系统自动完成，不需要手动分配和释放内存。
* 支持递归：栈在递归算法中非常有用，因为递归调用的返回地址和局部变量都存储在栈中。

栈的缺点

* 大小固定：栈的大小通常是固定的，如果栈满了，再进行压入操作就会导致栈溢出。
* 不支持随机访问：栈不支持随机访问，只能访问栈顶元素。

栈是一种简单而高效的数据结构，适用于需要 **后进先出** 操作的场景，如函数调用、表达式求值等。然而，由于其 **大小固定和不支持随机访问** ，在需要动态调整大小或随机访问元素的场景中，可能需要如动态数组（如C++中的std::vector）等的数据结构。

### 队列
队列（Queue）是一种先进先出（FIFO, First In First Out）的数据结构，它只允许在一端进行插入操作（队尾），在另一端进行删除操作（队头）。队列常用于广度优先搜索和任务调度等场景。

```cpp
#include <iostream>
#include <queue>

int main() {
    // 创建一个队列
    std::queue<int> myQueue;

    // 入队操作
    myQueue.push(1);
    myQueue.push(2);
    myQueue.push(3);

    // 访问队头元素
    std::cout << "队头元素: " << myQueue.front() << std::endl;

    // 出队操作
    myQueue.pop();

    // 再次访问队头元素
    std::cout << "出队一个元素后，队头元素: " << myQueue.front() << std::endl;

    return 0;
}
```

队列的优点

* 简单高效：队列的操作非常简单，只需要在队尾进行插入操作，在队头进行删除操作，时间复杂度为O(1)。
* 顺序性：队列能够保持元素的顺序，先进入队列的元素先被处理，这对于需要按照顺序处理数据的场景非常有用。
* 支持并发：在多线程环境中，队列可以用于实现线程安全的数据共享，例如生产者-消费者模型。

队列的缺点

* 大小固定：队列的大小通常是固定的，如果队列满了，再进行插入操作就会导致队列溢出。
* 不支持随机访问：队列不支持随机访问，只能访问队头和队尾的元素。

### 树
树（Tree）是一种非线性的数据结构，它由 **节点（Node）和边（Edge）** 组成。每个节点可以有 **零个或多个** 子节点，而每个子节点又可以有零个或多个子节点，以此类推。树的顶部节点称为根节点（Root），没有子节点的节点称为叶子节点（Leaf）。树结构常用于表示 **层次关系** 的数据，如文件系统。

**二叉树（Binary Tree）**是一种特殊的树结构，它的每个节点 **最多有两个** 子节点，通常称为左子节点和右子节点。

**二叉树的特点**

* 每个节点最多有两个子节点：这是二叉树的定义，也是它与其他树结构的主要区别。
* 子节点的顺序：左子节点和右子节点是有顺序的，不能随意交换。即二叉树是有序树
* 递归定义：二叉树可以递归地定义为一个节点，该节点有一个数据元素和两个指向子二叉树的指针。

**二叉树的类型**

* 满二叉树：除了叶子节点外， **每个节点都有两个子节点** ，并且所有叶子节点都在同一层。
* 完全二叉树：除了最后一层外，其他层的节点数都是满的，并且最后一层的节点都靠左排列。
* 平衡二叉树：左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

![](/assets/img/blog/blogs_data_strcut_full_binary_tree.png){:width="300" height="200" loading="lazy"}
![](/assets/img/blog/blogs_data_strcut_complete_binary_tree.png){:width="300" height="200" loading="lazy"}
![](/assets/img/blog/blogs_data_strcut_balance_binary_tree.png){:width="300" height="200" loading="lazy"}

**二叉树的遍历**

* 前序遍历：先访问根节点，然后递归遍历左子树，最后递归遍历右子树。
* 中序遍历：先递归遍历左子树，然后访问根节点，最后递归遍历右子树。
* 后序遍历：先递归遍历左子树，然后递归遍历右子树，最后访问根节点。
* 层序遍历：从根节点开始，按照从上到下、从左到右的顺序依次访问每个节点。

前三种称为深度优先遍历（DFS），层序遍历为广度优先遍历（BFS）。

```cpp
#include <iostream>

// 定义二叉树节点
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// 前序遍历
void preorderTraversal(TreeNode* root) {
    if (root == NULL) return;
    std::cout << root->val << " ";
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}

// 中序遍历
void inorderTraversal(TreeNode* root) {
    if (root == NULL) return;
    inorderTraversal(root->left);
    std::cout << root->val << " ";
    inorderTraversal(root->right);
}

// 后序遍历
void postorderTraversal(TreeNode* root) {
    if (root == NULL) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    std::cout << root->val << " ";  
}

// 层序遍历
void levelOrderTraversal(TreeNode* root) {
    if (root == NULL) return;
    std::queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        std::cout << node->val << " ";
        if (node->left != NULL) q.push(node->left);
        if (node->right != NULL) q.push(node->right);
    }
}
int main() {
    // 创建二叉树
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    // 前序遍历二叉树
    std::cout << "前序遍历结果: ";
    preorderTraversal(root);
    std::cout << std::endl;
    // 中序遍历二叉树
    std::cout << "中序遍历结果: ";
    inorderTraversal(root);
    std::cout << std::endl;
    // 后序遍历二叉树
    std::cout << "后序遍历结果: ";
    postorderTraversal(root);
    std::cout << std::endl;
    // 层序遍历二叉树
    std::cout << "层序遍历结果: ";
    levelOrderTraversal(root);
    std::cout << std::endl;
    return 0;
}
```

树的优点

* 层次结构清晰：树结构能够清晰地表示数据之间的层次关系，例如文件系统、组织结构等。
* 高效的搜索和插入操作：对于平衡树（如二叉搜索树），搜索、插入和删除操作的平均时间复杂度为O(log n)，其中n是树中节点的数量。
* 动态数据结构：树的大小可以动态增长或缩小，不需要预先分配固定大小的内存。

树的缺点

* 实现复杂：相比于线性数据结构（如数组、链表），树的实现通常更加复杂，需要更多的代码和逻辑。
* 空间开销较大：树的每个节点需要额外的指针来指向其子节点，这增加了内存开销。
* 不支持随机访问：树不支持像数组那样的随机访问，访问特定节点需要从根节点开始遍历。

树是一种非常有用的数据结构，适用于表示 **层次关系和需要高效搜索、插入操作** 的场景。然而，由于其 **实现复杂和空间开销较大** 的缺点，在简单的线性数据结构能够满足需求的情况下，可能不需要使用树。

### 哈希表
哈希表（Hash Table）是一种根据关键码值（Key value）而直接进行访问的数据结构。它通过哈希函数 **将键映射到数组** 中的位置，从而实现快速查找。。这个映射函数叫做哈希函数，存放记录的数组叫做哈希表。哈希表的优点是查找速度快，但需要处理哈希冲突。

```cpp
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    // 创建一个哈希表
    std::unordered_map<std::string, int> hashTable;

    // 插入键值对
    hashTable["apple"] = 1;
    hashTable["banana"] = 2;
    hashTable["cherry"] = 3;

    // 查找键值对
    std::cout << "The value of 'apple' is: " << hashTable["apple"] << std::endl;

    // 删除键值对
    hashTable.erase("banana");

    // 遍历哈希表
    for (const auto& pair : hashTable) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

哈希表的优点

* 快速查找：哈希表的查找、插入和删除操作的平均时间复杂度为O(1)，这使得它在处理大量数据时非常高效。
* 灵活性：哈希表可以存储不同类型的数据，并且可以动态调整大小以适应数据的增长或减少。
* 高效的内存使用：哈希表通常比其他数据结构（如树）更节省内存，因为它们不需要维护复杂的指针结构。

哈希表的缺点

* 哈希冲突：不同的关键码值可能映射到相同的哈希表位置，这称为哈希冲突。解决哈希冲突需要额外的处理，这可能会增加时间和空间复杂度。
* 不支持顺序访问：哈希表不支持像数组或链表那样的顺序访问，因此在需要按顺序遍历数据的场景中可能不太适用。
* 哈希函数的选择：哈希表的性能很大程度上取决于哈希函数的选择。一个好的哈希函数应该能够均匀地分布关键码值，以减少哈希冲突的可能性。

哈希表是一种非常有用的数据结构，适用于需要快速查找和插入操作的场景。然而，由于其 **哈希冲突和灵活性，不保证顺序** 的缺点，在需要 **顺序访问** 或需要 **维护复杂指针结构** 的场景中，可能需要使用其他数据结构，如树或数组等。

### 堆
堆（Heap）是一种特殊的树结构，通常是一个 **完全二叉树** 。堆分为最大堆和最小堆，其中最大堆的每个节点的值都大于或等于其子节点的值，最小堆的每个节点的值都小于或等于其子节点的值。堆常用于实现优先队列，其中最大堆用于实现最大优先队列，最小堆用于实现最小优先队列。

```cpp
#include <iostream>
#include <queue>

int main() {
    // 创建一个最大堆
    std::priority_queue<int> maxHeap;

    // 插入元素
    maxHeap.push(3);
    maxHeap.push(1);
    maxHeap.push(4);
    maxHeap.push(1);
    maxHeap.push(5);

    // 访问最大元素
    std::cout << "最大元素: " << maxHeap.top() << std::endl;

    // 删除最大元素
    maxHeap.pop();

    // 再次访问最大元素
    std::cout << "删除最大元素后，最大元素: " << maxHeap.top() << std::endl;

    return 0;
}
```

堆的优点

* 高效的插入和删除操作：在堆中插入和删除元素的时间复杂度为O(log n)，其中n是堆中元素的数量。这使得堆在处理大量数据时非常高效。
* 快速访问最大或最小元素：在最大堆中，根节点始终是最大元素；在最小堆中，根节点始终是最小元素。因此，可以在O(1)时间内访问最大或最小元素。
* 动态调整大小：堆可以动态调整大小，以适应数据的增长或减少。

堆的缺点

* 不支持随机访问：堆不支持像数组那样的随机访问，因此在需要按顺序遍历数据的场景中可能不太适用。
* 不保证元素的顺序：堆只保证根节点是最大或最小元素，而不保证其他元素的顺序。
* 空间开销：堆的每个节点需要额外的空间来存储其子节点的指针，这增加了内存开销。

堆是一种非常有用的数据结构，适用于需要快速访问最大或最小元素的场景，如优先队列。然而，由于其不支持随机访问和不保证元素顺序的特点，在某些特定场景下可能需要考虑其他数据结构。

### 图
图（Graph）是一种非线性的数据结构，由顶点（Vertex）和边（Edge）组成。顶点表示对象，边表示对象之间的关系。图分为有向图和无向图。图可以用来表示各种复杂的关系，如社交网络、交通网络、计算机网络等。

```cpp
#include <iostream>
#include <vector>
#include <list>

class Graph {
private:
    int numVertices;
    std::vector<std::list<int>> adjLists;

public:
    Graph(int vertices) : numVertices(vertices) {
        adjLists.resize(numVertices);
    }

    void addEdge(int src, int dest) {
        adjLists[src].push_back(dest);
        // 如果是无向图，需要添加反向边
        // adjLists[dest].push_back(src);
    }

    void printGraph() {
        for (int i = 0; i < numVertices; ++i) {
            std::cout << "Vertex " << i << ": ";
            for (int neighbor : adjLists[i]) {
                std::cout << neighbor << " ";
            }
            std::cout << std::endl;
        }
    }
};

int main() {
    Graph g(5);
    g.addEdge(0, 1);
    g.addEdge(0, 4);
    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 3);
    g.addEdge(3, 4);

    g.printGraph();

    return 0;
}
```

图的优点

* 强大的表示能力：图可以表示各种复杂的关系，如社交网络中的朋友关系、交通网络中的道路连接等。
* 灵活性：图可以是有向的（边有方向）或无向的（边无方向），可以是加权的（边有权重）或无权的（边无权重）。
* 广泛的应用领域：图在许多领域都有广泛的应用，如计算机科学、数学、物理学、生物学、社会学等。

图的缺点

* 实现复杂：图的实现通常比其他数据结构更复杂，需要更多的代码和逻辑。
* 空间开销大：图的存储通常需要更多的空间，尤其是在处理大规模图时。
* 算法复杂度高：许多图算法的时间复杂度较高，如最短路径算法、最小生成树算法等。

图是一种非常强大的数据结构，适用于表示各种复杂的关系。然而，由于其实现复杂和空间开销大的缺点，在处理小规模数据或简单关系时，可能不需要使用图。

## 算法
### 排序算法
#### 冒泡排序
冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。

每一轮，从原乱序的数组头部开始，每两个元素比较大小并进行交换，直到这一轮当中最大或最小的元素被放置在数组的尾部，然后不断地重复这个过程，直到所有元素都排好位置。

冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。

```cpp
#include <iostream>
#include <vector>

void bubbleSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                // 交换 arr[j] 和 arr[j + 1]
                // 将比较大的元素往后移动
                std::swap(arr[j], arr[j + 1]);
            }
        }
    }
}

int main() {
    std::vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
    bubbleSort(arr);
    std::cout << "排序后的数组: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

冒泡排序的优点

* 简单易懂：冒泡排序的实现非常简单，易于理解和实现，适合初学者学习排序算法的基本概念。
* 稳定性：冒泡排序是一种稳定的排序算法，即相等元素的相对顺序在排序后不会改变。

冒泡排序的缺点

* 效率较低：冒泡排序的时间复杂度为O(n^2)，其中n是要排序的元素数量。这意味着当处理大量数据时，冒泡排序的效率会非常低。
* 不适合大规模数据：由于其时间复杂度较高，冒泡排序不适合用于大规模数据的排序。

冒泡排序是一种简单但效率较低的排序算法，适用于小规模数据的排序或作为学习排序算法的入门示例。在实际应用中，对于大规模数据的排序，通常会使用更高效的排序算法，如快速排序、归并排序等。

#### 快速排序
快速排序（Quick Sort）是一种高效的排序算法，它基于分治的策略来对数组进行排序。快速排序的基本思想是选择一个基准元素，将数组分为两部分，一部分的所有元素都比基准元素小，另一部分的所有元素都比基准元素大，然后对这两部分分别进行排序。

```cpp
#include <iostream>
#include <vector>

// 划分函数，选择一个基准元素，将数组分为两部分
int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high]; // 选择最后一个元素作为基准
    int i = low - 1; // 指向小于基准元素的最后一个位置

    for (int j = low; j < high; ++j) {
        if (arr[j] < pivot) {
            ++i;
            std::swap(arr[i], arr[j]);
        }
    }

    std::swap(arr[i + 1], arr[high]); // 将基准元素放到正确的位置
    return i + 1; // 返回基准元素的索引
}

// 快速排序函数
void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high); // 获取基准元素的索引

        // 对基准元素左边的子数组进行排序
        quickSort(arr, low, pivotIndex - 1);

        // 对基准元素右边的子数组进行排序
        quickSort(arr, pivotIndex + 1, high);
    }
}

int main() {
    std::vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
    int n = arr.size();

    quickSort(arr, 0, n - 1);

    std::cout << "排序后的数组: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

> partition函数：选择一个基准元素（通常是数组的最后一个元素），将数组分为两部分，左边的元素都小于基准元素，右边的元素都大于基准元素。
quickSort函数：递归地对划分后的子数组进行排序。
main函数：在main函数中，我们创建了一个包含一些整数的向量，并调用quickSort函数对其进行排序。最后，我们输出排序后的数组。

快速排序的优点

* 高效性：快速排序的平均时间复杂度为O(n log n)，在大多数情况下比其他排序算法（如冒泡排序、插入排序等）更快。
* 原地排序：快速排序是一种原地排序算法，它不需要额外的存储空间来存储临时数据。
* 适应性：快速排序可以根据数据的分布情况进行自适应调整，对于已经部分有序的数据也能表现出较好的性能。

快速排序的缺点

* 不稳定性：快速排序是一种不稳定的排序算法，即相等元素的相对顺序在排序后可能会改变。
* 最坏情况性能：在**最坏情况下**，快速排序的时间复杂度为O(n^2)，这种情况发生在数组已经有序或接近有序时。
* 递归深度：快速排序是一种递归算法，在处理大规模数据时，可能会导致栈溢出的问题。

快速排序是一种高效的排序算法，适用于大规模数据的排序。然而，在最坏情况下，快速排序的性能可能会受到影响，因此在实际应用中，通常会使用更稳定的排序算法，如归并排序。

#### 归并排序
