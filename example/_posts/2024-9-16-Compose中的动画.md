---
layout: post
description: > 
  本文介绍了Jetpack Compose中一系列动画API的使用
image: 
  path: /assets/img/blog/blogs_compose_cover.png
  srcset: 
    1920w: /assets/img/blog/blogs_compose_cover.png
    960w:  /assets/img/blog/blogs_compose_cover.png
    480w:  /assets/img/blog/blogs_compose_cover.png
accent_image: /assets/img/blog/blogs_compose_cover.png
excerpt_separator: <!--more-->
sitemap: false
---
# Compose中的动画
### 出现消失动画
**AnimatedVisibility** 是Jetpack Compose中一个非常有用的动画API，它可以让我们在Composable函数中实现元素的出现和消失动画。它的使用非常简单，只需要在需要添加动画效果的元素上使用AnimatedVisibility即可。

AnimatedVisibility 的方法签名如下：

```kotlin
@Composable
fun ColumnScope.AnimatedVisibility(
    visible: Boolean,
    modifier: Modifier = Modifier,
    enter: EnterTransition = fadeIn() + expandVertically(),
    exit: ExitTransition = fadeOut() + shrinkVertically(),
    label: String = "AnimatedVisibility",
    content: @Composable AnimatedVisibilityScope.() -> Unit
) {
    val transition = updateTransition(visible, label)
    AnimatedVisibilityImpl(transition, { it }, modifier, enter, exit, content = content)
}
```

> visible是一个布尔值，用于控制元素的出现和消失。
modifier是一个Modifier对象，用于修改元素的外观。
enter是一个EnterTransition对象，用于控制元素出现时的动画效果。
exit是一个ExitTransition对象，用于控制元素消失时的动画效果。
label是一个字符串，用于标识元素。
content是一个Composable函数，用于定义元素的内容。

举例，设置两个text，上面那个text点击后开始退场，2s后重新出现。

![](/assets/img/blog/blogs_compose_anim_visibility.png){:width="300" height="200" loading="lazy"}

源码如下：

```kotlin
@Composable
fun AnimatedVisibilityDemo() {
    Column(modifier = Modifier.width(IntrinsicSize.Max)) {

        val scope = rememberCoroutineScope()

        val isShow = remember { mutableStateOf(true) }

        AnimatedVisibility(visible = isShow.value) {
            Text(
                text = "How are you?",
                color = Color.White,
                modifier = Modifier
                    .fillMaxWidth(1f)
                    .background(Color.Red)
                    .clip(RoundedCornerShape(10))
                    .clickable {
                        isShow.value = false // 点击后消失
                        scope.launch {
                            delay(2000)
                            isShow.value = true // 2秒后重新出现
                        }
                    }
                    .padding(20.dp)
            )
        }

        Text(
            text = "I'm fine, thank you! And you?",
            color = Color.White,
            modifier = Modifier
                .fillMaxWidth(1f)
                .background(Color.Blue)
                .clip(RoundedCornerShape(10))
                .padding(20.dp)
        )
    }
}
```

可以看到 Compose 为了简化使用，已经预设了进出场的动画，进场是fadeIn() + expandVertically()，出场是fadeOut() + shrinkVertically()。如果需要自定义动画效果，可以手动声明并传入 AnimatedVisibility 的enter和exit参数。enter参数是一个EnterTransition对象，用于控制元素出现时的动画效果。

可以像官方例程里那样，自定义这两个参数传入：

```kotlin
AnimatedVisibility(visible = isShow.value,
            enter = slideInVertically {
                // Slide in from 40 dp from the top.
                with(density) { -40.dp.roundToPx() }
            } + expandVertically(
                // Expand from the top.
                expandFrom = Alignment.Top
            ) + fadeIn(
                // Fade in with the initial alpha of 0.3f.
                initialAlpha = 0.3f
            ),
            exit = slideOutVertically() + shrinkVertically() + fadeOut()) {

}
```

进场参数自定义，设定以top为基准，扩张的时候从上往下，滑动的时候从上往下。

#### 更改动画时长
AnimatedVisibility 中的动画时长可以通过修改 enter 和 exit 中的动画参数来控制。例如，我们可以使用 fadeIn() 动画，并将持续时间设置为 2 秒：

```kotlin
AnimatedVisibility(
    visible = isShow.value,
    enter = fadeIn(
        animationSpec = tween(2000)
    ),
    exit = fadeOut(
        animationSpec = tween(2000)
    )
)
```

#### 使用MutableTransitionState控制动画
AnimatedVisibility 还可以使用 MutableTransitionState 来控制动画。MutableTransitionState 是一个可变的 TransitionState，它可以在运行时更改其目标状态。通常可以用作在一开始就触发动画，还可以实时地 **观察到动画状态** 。

```kotlin
@Composable
fun AnimatedVisibilityDemo() {
    Column(modifier = Modifier.width(IntrinsicSize.Max)) {

        val scope = rememberCoroutineScope()

        val state = remember {
            MutableTransitionState(false).apply {
                // Start the animation immediately.
                targetState = true
            }
        }

        AnimatedVisibility(visibleState = state) {
            Text(
                text = "How are you?",
                color = Color.White,
                modifier = Modifier
                    .fillMaxWidth(1f)
                    .background(Color.Red)
                    .clip(RoundedCornerShape(10))
                    .clickable {
                        state.targetState = !state.targetState
                        scope.launch {
                            delay(2000)
                            state.targetState = !state.targetState
                        }
                    }
                    .padding(20.dp)
            )
        }

        Text(
            text = when {
                state.isIdle && state.currentState -> "Visible"
                !state.isIdle && state.currentState -> "Disappearing"
                state.isIdle && !state.currentState -> "Invisible"
                else -> "Appearing"
            },
            color = Color.White,
            modifier = Modifier
                .fillMaxWidth(1f)
                .background(Color.Blue)
                .clip(RoundedCornerShape(10))
                .padding(20.dp)
        )
    }
}
```

观察效果：

![](/assets/img/blog/blogs_compose_anim_state_listen.png){:width="300" height="200" loading="lazy"}

#### 给子项添加动画
有时候我们需要给子项单独添加动画，以获得更灵活的效果。AnimatedVisibility 里面的子项可以使用  animateEnterExit 修饰符，来添加更精细的动画效果。

```kotlin
    AnimatedVisibility(
        visible = isShow.value,
        enter = EnterTransition.None,
        exit = ExitTransition.None
    ) {
        Text(
            text = "How are you?",
            color = Color.White,
            modifier = Modifier
                .fillMaxWidth(1f)
                .animateEnterExit(
                    // Slide in/out the inner box.
                    enter = slideInVertically(),
                    exit = slideOutVertically()
                )
                .background(Color.Red)
                .clip(RoundedCornerShape(10))
                .clickable {
                    isShow.value = false // 点击后消失
                    scope.launch {
                        delay(2000)
                        isShow.value = true // 2秒后重新出现
                    }
                }
                .padding(20.dp)
        )
    }
```

需要注意的是AnimatedVisibility和其子项设置的动画效果是叠加的，我们如果不想要外面父组合项自带的动画效果，可以显示的传入EnterTransition.Noneh和ExitTransition.None。

#### 添加自定义动画
通过 AnimatedVisibility 的内容 lambda 内的 `transition` 属性访问底层 Transition 实例。添加到 Transition 实例的所有动画状态都将与 AnimatedVisibility 的进入和退出动画同时运行。AnimatedVisibility 会等到 Transition 中的所有动画都完成后再移除其内容。对于独立于 Transition（例如使用 animate*AsState）创建的退出动画，AnimatedVisibility 将无法解释这些动画，因此可能会在完成之前移除内容可组合项。

例如在原有进场动画的基础上，添加一个颜色的动画：
```kotlin
 AnimatedVisibility(
) {
     val background by transition.animateColor(label = "color") { state ->
        if (state == EnterExitState.Visible) Color.Blue else Color.Gray
    }
        Text(
            text = "How are you?",
            color = Color.White,
            modifier = Modifier
               .fillMaxWidth(1f)
               .background(background)
               .clip(RoundedCornerShape(10))
        )
    }
```

#### 使用 Crossfade 在两个布局之间添加动画效果
Crossfade 可使用淡入淡出动画在两个布局之间添加动画效果。通过切换传递给 current 参数的值，可以使用淡入淡出动画来切换内容。

```kotlin
var currentPage by remember { mutableStateOf("A") }
Crossfade(targetState = currentPage, label = "cross fade") { screen ->
    when (screen) {
        "A" -> Text("Page A")
        "B" -> Text("Page B")
    }
}
```

### 尺寸改变动画
使用 `animateContentSize` 修饰符可以让Composable函数在大小发生变化时进行动画效果。注意需要添加在任何尺寸修饰符之前，以防止动画效果被错误地应用。

```kotlin
@Composable
fun AnimatedVisibilityDemo() {
    Column(modifier = Modifier.width(IntrinsicSize.Max)) {

        val scope = rememberCoroutineScope()

        var state by remember { mutableStateOf(false) }

        Text(
            text = "How are you?",
            color = Color.White,
            modifier = Modifier
                .animateContentSize()
                .fillMaxWidth(1f)
                .height(if (state) 160.dp else 80.dp)
                .background(Color.Red)
                .clip(RoundedCornerShape(10))
                .clickable {
                    state = true
                    scope.launch {
                        delay(2000)
                        state = false
                    }
                }
                .padding(20.dp)
        )

        Text(
            text = "I am fine.",
            color = Color.White,
            modifier = Modifier
                .fillMaxWidth(1f)
                .background(Color.Blue)
                .clip(RoundedCornerShape(10))
                .padding(20.dp)
        )
    }
}
```

### 列表项动画
为列表的每个项添加动画效果，使用 `animateItem` 修饰符。

```kotlin
@Composable
fun ListItemAnimateDemo() {
    val listState = remember { mutableStateListOf<ListItem>() }

    LaunchedEffect(Unit) {
        repeat(10) {
            listState.add(ListItem(it, "Item $it"))
            delay(1000)
        }
        delay(1000)
        listState.removeAt(5)
    }

    LazyColumn(modifier = Modifier.fillMaxSize()) {
        items(listState, key = { it.id }) { item ->
            Text(
                text = item.title,
                color = Color.White,
                modifier = Modifier
                    .fillMaxWidth(1f)
                    .animateItem()
                    .background(Color.Blue)
                    .clip(RoundedCornerShape(10))
            )
        }
    }
}

data class ListItem(
    val id: Int,
    val title: String,
)
```

## 进度
https://developer.android.google.cn/develop/ui/compose/animation/value-based?hl=zh-cn