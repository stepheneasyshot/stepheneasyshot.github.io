---
layout: post
description: > 
  本文介绍Kotlin协程挂起和恢复的原理
image: 
  path: /assets/img/blog/blogs_kotlin_cover2.png
  srcset: 
    1920w: /assets/img/blog/blogs_kotlin_cover2.png
    960w:  /assets/img/blog/blogs_kotlin_cover2.png
    480w:  /assets/img/blog/blogs_kotlin_cover2.png
accent_image: /assets/img/blog/blogs_kotlin_cover2.png
excerpt_separator: <!--more-->
sitemap: false
---
# Kotlin协程挂起和恢复的原理
## 协程简介
协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。协程 是在 1.3 版中添加到 Kotlin 的，基于既定的从其他语言转换成的概念。

在 `Android` 上，协程有助于管理长时间运行的任务，如果管理不当，这些任务可能会阻塞主线程并导致应用无响应。使用协程的专业开发者中有超过 50% 的人反映使用协程提高了工作效率。本主题介绍如何使用 `Kotlin` 协程解决以下问题，从而让您能够编写出更清晰、更简洁的应用代码。

### 协程和线程
#### 线程

* 线程是操作系统级别的概念
* 我们开发者通过编程语言(Thread.java)创建的线程，本质还是操作系统内核线程的映射
* JVM 中的线程与内核线程的存在映射关系，有“一对一”，“一对多”，“M对N”。* JVM 在不同操作系统中的具体实现会有差别，“一对一”是主流
* 一般情况下，我们说的线程，都是内核线程，线程之间的切换，调度，都由操作系统负责
* 线程也会消耗操作系统资源，但比进程轻量得多
* 线程，是抢占式的，它们之间能共享内存资源，进程不行
* 线程共享资源导致了多线程同步问题
* 有的编程语言会自己实现一套线程库，从而能在一个内核线程中实现多线程效果，早期 JVM 的“绿色线程” 就是这么做的，这种线程被称为“用户线程”

#### 协程

* 协程不是操作系统级别的概念，无需操作系统支持
* 协程有点像上面提到的“绿色线程”，一个线程上可以运行成千上万个协程
* 协程是用户态的(userlevel)，内核对协程无感知
* 协程是协作式的，由开发者管理，不需要操作系统进行调度和切换，也没有抢占式的消耗，因此它更加高效
* 协程它底层基于状态机实现，多协程之间共用一个实例，资源开销极小，因此它更加轻量
* 协程本质还是运行于线程之上，它通过协程调度器，可以运行到不同的线程上

### 项目使用实例
最常见的使用方式，在 `ViewModel` 或者 `Controller` 里写业务逻辑，在 `Activity` 里调用，这样就可以在IO线程执行网络请求，拿到结果后自动切换到主线程更新UI。

```kotlin
// viewModel或者controller里获取数据逻辑
// 使用suspend限制在协程里使用；withContext切换调度器，指定在IO线程执行下面的任务
suspend fun getUserName() = withContext(Dispatchers.IO) {
    debugLog("thread name: ${Thread.currentThread().name}")
    ServiceCreator.createService<UserService>()
        .getUserName("2cd1e3c5ee3cda5a")
        .execute()
        .body()
}

// Activity调用处
override fun onCreate(savedInstanceState: Bundle?){
    // 最直接的声明方法，在主线程执行下面的逻辑
    lifeCycleScope.launch {
        // 相当于get这一半是在IO线程执行
        //拿到结果后的变量赋值这一半操作由调度器自动切换到主线程来执行了
        val userName = mViewModel.getUserName()
        infoLog("userName: $userName")
        binding.tvUserName.text = userName
    }
}
```

## API介绍
### 四个基础概念
* suspend function。即挂起函数，delay() 就是协程库提供的一个用于实现非阻塞式延时的挂起函数
* CoroutineScope。即协程作用域，GlobalScope 是 CoroutineScope 的一个实现类，用于指定协程的作用范围，可用于管理多个协程的生命周期，所有协程都需要通过 CoroutineScope 来启动
* CoroutineContext。即协程上下文，包含多种类型的配置参数。`Dispatchers.IO` 就是 CoroutineContext 这个抽象概念的一种实现，用于指定协程的运行载体，即用于指定协程要运行在哪类线程上
* CoroutineBuilder。即协程构建器，协程在 CoroutineScope 的上下文中通过 launch、async 等协程构建器来进行声明并启动。launch、async 均被声明为 CoroutineScope 的扩展方法

Kotlin 协程（Coroutines）提供了一套丰富的 API 方法，用于简化异步编程。以下是一些常用的 API 方法及其简要说明：

### 协程构建器
用于启动协程的主要方法。

- **`launch`**  
  启动一个不会返回结果的协程（`Job` 类型）。  
  ```kotlin
  GlobalScope.launch {
      // 协程代码
  }
  ```

- **`async`**  
  启动一个会返回结果的协程（`Deferred` 类型），结果可以通过 `await()` 获取。  
  ```kotlin
  val deferred = GlobalScope.async {
      // 协程代码
      "Result"
  }
  val result = deferred.await()
  ```

- **`runBlocking`**  
  阻塞当前线程，直到协程执行完毕。通常用于测试或主函数中。  
  ```kotlin
  runBlocking {
      // 协程代码
  }
  ```

### 协程上下文与调度器
用于控制协程的执行线程或上下文。

- **`Dispatchers.Default`**  
  用于 CPU 密集型任务的默认线程池。  
  ```kotlin
  launch(Dispatchers.Default) {
      // 在后台线程执行
  }
  ```

- **`Dispatchers.IO`**  
  用于 IO 密集型任务的线程池。  
  ```kotlin
  launch(Dispatchers.IO) {
      // 执行 IO 操作
  }
  ```

- **`Dispatchers.Main`**  
  用于在主线程（如 Android 的 UI 线程）执行任务。  
  ```kotlin
  launch(Dispatchers.Main) {
      // 更新 UI
  }
  ```

- **`Dispatchers.Unconfined`**  
  不限制协程的执行线程，根据调用点决定。  
  ```kotlin
  launch(Dispatchers.Unconfined) {
      // 不限制线程
  }
  ```

- **`withContext`**  
  切换协程的上下文。  
  ```kotlin
  withContext(Dispatchers.IO) {
      // 在 IO 线程执行
  }
  ```

### 协程作用域
用于管理协程的生命周期。

- **`GlobalScope`**  
  全局作用域，协程的生命周期与应用程序一致。  
  ```kotlin
  GlobalScope.launch {
      // 全局协程
  }
  ```

- **`CoroutineScope`**  
  自定义作用域，通常与 `lifecycleScope` 或 `viewModelScope` 结合使用。  
  ```kotlin
  val scope = CoroutineScope(Dispatchers.Main)
  scope.launch {
      // 协程代码
  }
  ```

- **`lifecycleScope`**（Android）  
  与 `Lifecycle` 绑定的作用域，协程在 `Lifecycle` 销毁时自动取消。  
  ```kotlin
  lifecycleScope.launch {
      // 协程代码
  }
  ```

- **`viewModelScope`**（Android）  
  与 `ViewModel` 绑定的作用域，协程在 `ViewModel` 销毁时自动取消。  
  ```kotlin
  viewModelScope.launch {
      // 协程代码
  }
  ```

### 协程取消与超时
用于控制协程的执行时间或取消协程。

- **`cancel()`**  
  取消协程。  
  ```kotlin
  val job = launch {
      // 协程代码
  }
  job.cancel()
  ```

- **`isActive`**  
  检查协程是否仍处于活动状态。  
  ```kotlin
  if (isActive) {
      // 协程仍在运行
  }
  ```

- **`withTimeout`**  
  设置协程的超时时间，超时后抛出 `TimeoutCancellationException`。  
  ```kotlin
  withTimeout(1000) {
      // 协程代码
  }
  ```

- **`withTimeoutOrNull`**  
  设置协程的超时时间，超时后返回 `null` 而不是抛出异常。  
  ```kotlin
  val result = withTimeoutOrNull(1000) {
      // 协程代码
  }
  ```

### 协程挂起函数
用于在协程中挂起执行。

- **`delay`**  
  挂起协程一段时间。  
  ```kotlin
  delay(1000) // 挂起 1 秒
  ```

- **`yield`**  
  挂起当前协程，让出执行权给其他协程。  
  ```kotlin
  yield()
  ```

### 协程异常处理
用于处理协程中的异常。

- **`try-catch`**  
  捕获协程中的异常。  
  ```kotlin
  try {
      // 协程代码
  } catch (e: Exception) {
      // 处理异常
  }
  ```

- **`CoroutineExceptionHandler`**  
  全局异常处理器。  
  ```kotlin
  val handler = CoroutineExceptionHandler { _, exception ->
      // 处理异常
  }
  launch(handler) {
      // 协程代码
  }
  ```

### 协程组合与并发
用于处理多个协程的组合与并发。

- **`awaitAll`**  
  等待多个 `Deferred` 完成并返回结果列表。  
  ```kotlin
  val deferred1 = async { 1 }
  val deferred2 = async { 2 }
  val results = awaitAll(deferred1, deferred2)
  ```

- **`supervisorScope`**  
  创建一个子作用域，子协程的失败不会影响其他子协程。  
  ```kotlin
  supervisorScope {
      launch {
          // 子协程 1
      }
      launch {
          // 子协程 2
      }
  }
  ```

- **`coroutineScope`**  
  创建一个子作用域，子协程的失败会传播到父协程。  
  ```kotlin
  coroutineScope {
      launch {
          // 子协程 1
      }
      launch {
          // 子协程 2
      }
  }
  ```

### Flow API
Flow API 是 Kotlin 协程库中的一部分，主要用于处理数据流。

- **`flow`**  
  创建一个冷流（Cold Flow）。  
  ```kotlin
  val flow = flow {
      emit(1)
      emit(2)
  }
  ```

- **`collect`**  
  收集流中的数据。  
  ```kotlin
  flow.collect { value ->
      // 处理数据
  }
  ```

- **`map`**  
  对流中的数据进行转换。  
  ```kotlin
  flow.map { value -> value * 2 }
  ```

- **`filter`**  
  过滤流中的数据。  
  ```kotlin
  flow.filter { value -> value > 1 }
  ```

- **`flatMapConcat`**  
  将流中的每个值映射为一个新流，并按顺序连接。  
  ```kotlin
  flow.flatMapConcat { value -> flowOf(value, value * 2) }
  ```

- **`zip`**  
  将两个流合并为一个流。  
  ```kotlin
  val flow1 = flowOf(1, 2)
  val flow2 = flowOf("A", "B")
  flow1.zip(flow2) { a, b -> "$a$b" }
  ```

关于更多Flow的基础和进阶使用，此前也写过更详细的一篇文章。

[Kotlin Flow全面总结](/example/_posts/2025-2-5-Kotlin%20Flow全面总结.md)