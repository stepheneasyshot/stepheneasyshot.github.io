---
layout: post
description: > 
  本文介绍了在Android应用层开发过程中，日常使用的重要的依赖库知识点总结梳理
image: 
  path: /assets/img/blog/blogs_android_common_cover.png
  srcset: 
    1920w: /assets/img/blog/blogs_android_common_cover.png
    960w:  /assets/img/blog/blogs_android_common_cover.png
    480w:  /assets/img/blog/blogs_android_common_cover.png
accent_image: /assets/img/blog/blogs_android_common_cover.png
excerpt_separator: <!--more-->
sitemap: false
---
# Android热门依赖库知识点总结
## 官方组件
### ViewModel & Lifecycle
#### onSaveInstanceState 存储数据原理
onSaveInstanceState 是 Android 中用于临时保存 Activity 或 Fragment 状态的重要机制，主要用于应对**系统配置变更(如屏幕旋转)或系统资源回收**等情况。
* 当 Activity 可能被销毁时(如配置变更或后台回收)，系统会调用 onSaveInstanceState(Bundle outState)
* 开发者可以重写此方法，将需要保存的状态数据存入提供的 Bundle 对象
* 当 Activity 重新创建时，系统会将保存的 Bundle 传递给 onCreate(Bundle savedInstanceState) 或 onRestoreInstanceState(Bundle savedInstanceState)
* 内部使用 ArrayMap 实现键值存储，支持基本数据类型、String、Parcelable 和 Serializable 对象，数据会被序列化为字节流
* 系统使用 Binder 事务缓冲区传输这些数据(大小限制约1MB)
* 数据临时保存在系统进程中，不是持久化存储，进程终止后数据会丢失
* onSaveInstanceState 被调用的频率可能增加

#### ViewModel 存数据的原理
ViewModel 是 Android Jetpack 架构组件的一部分，它能在配置变更（如屏幕旋转）时保留数据，但在应用进程被完全终止时数据会丢失。
* 每个 Activity/Fragment 拥有一个 ViewModelStore 实例
* ViewModelStore 内部使用 HashMap 存储 ViewModel 实例
* 配置变更时，ViewModelStore 被保留在内存中
* ViewModel 的生命周期比创建它的 Activity/Fragment 更长
* 当 Activity 因配置变更销毁重建时，ViewModel 不会被清除，当 Activity 真正完成（finish()）时，ViewModel 会被清除

底层实现原理
ViewModelProvider 工作机制：
```java
// 获取 ViewModel 的简化流程
ViewModelProvider(owner).get(MyViewModel::class.java)

// 内部实现关键步骤：
1. 检查 owner（Activity/Fragment）的 ViewModelStore
2. 如果不存在对应 ViewModel 实例，则通过 Factory 创建新实例
3. 将新实例存入 ViewModelStore 的 HashMap
```

#### 配置变更可以保存数据原理
配置变更场景：
* 当 Activity 因配置变更被销毁时，系统保留了一个特殊的"非配置实例"
* 这个非配置实例持有 ViewModelStore
* 新创建的 Activity 实例会获取前一个实例的 ViewModelStore

#### ViewModeProvider 的作用
* 负责实例化 ViewModel 对象
* 确保不会重复创建相同的 ViewModel 实例
* 将 ViewModel 与特定的 Activity/Fragment 生命周期关联
* 确保 ViewModel 在配置变更时不会被销毁
* 与 ViewModelStore 协作管理 ViewModel 实例的存储

#### ViewModel 的工厂模式(ViewModelProvider.Factory)有什么作用
ViewModelProvider.Factory 是 ViewModelProvider 的工厂接口，用于创建 ViewModel 实例。
* 当 ViewModelProvider 找不到已存在的 ViewModel 实例时，会调用 Factory 的 create 方法创建新实例
* 可以通过实现 Factory 接口，根据不同的构造参数创建不同的 ViewModel 实例
* 可以通过依赖注入框架（如 Dagger、Hilt）来提供 Factory 的实现，实现 ViewModel 的依赖注入
* 可以通过自定义的 ViewModelFactory 来实现不同的 ViewModel 实例创建逻辑，如根据不同的参数创建不同的 ViewModel 实例

#### Lifecycle 工作机制
Lifecycle 是 Android Jetpack 架构组件的一部分，用于管理 Activity 和 Fragment 的生命周期。
* 每个 Activity/Fragment 都有一个 LifecycleRegistry 实例
* LifecycleRegistry 内部维护了一个 LifecycleOwner 和 Lifecycle 的对应关系
* 当 Activity/Fragment 生命周期状态改变时，LifecycleRegistry 会通知所有的 LifecycleObserver
* LifecycleObserver 可以通过注解或手动注册来监听特定的生命周期事件

底层实现原理
LifecycleRegistry 工作机制：
```java
// 生命周期状态变化时的简化流程
1. 调用 LifecycleRegistry.markState(Lifecycle.State.CREATED)
2. 遍历所有 LifecycleObserver，调用其对应的生命周期方法（如 onStart()）

// 内部实现关键步骤：
1. 维护一个 LifecycleOwner 和 Lifecycle 的对应关系
2. 当 LifecycleOwner 生命周期状态改变时，遍历所有 LifecycleObserver，调用其对应的生命周期方法
```

#### ViewModel如何感知生命周期
ViewModel 的生命周期感知主要依赖于以下组件协作：
* ViewModelStoreOwner：Activity/Fragment 实现的接口，提供 ViewModelStore
* ViewModelStore：实际存储 ViewModel 实例的容器
* LifecycleOwner：Activity/Fragment 提供的生命周期来源

#### Fragment共享viewmodel
Fragment 间共享数据, 实际使用中，可以通过以下方式来实现：
```kotlin
// 多个 Fragment 通过 activity 获取同一个 ViewModel
val sharedViewModel = ViewModelProvider(requireActivity()).get(SharedViewModel::class.java)
```

### LiveData & Flow
#### 什么是 LiveData？它的主要特点是什么？
* LiveData 是一种可观察的数据持有者类，具有生命周期感知能力
* 特点：生命周期感知、自动更新UI、避免内存泄漏、数据始终保持最新状态

#### LiveData 与 RxJava/Observable 有什么区别？
* LiveData 是生命周期感知的，专为 Android 设计
* RxJava 更强大但更复杂，需要手动管理订阅生命周期
* LiveData 自动处理订阅和取消订阅

#### LiveData 的生命周期感知是如何实现的？
* 通过 LifecycleOwner 关联组件生命周期
* 在 STARTED 或 RESUMED 状态时激活观察者
* 在 DESTROYED 状态时自动移除观察者

#### LiveData 的观察者模式是如何工作的？
* 使用 Observer 接口注册观察者
* 数据变化时通知处于活跃状态的观察者
* 新观察者注册时会立即收到当前值

#### LiveData 的 setValue() 和 postValue() 有什么区别？
* setValue() 必须在主线程调用
* postValue() 可以在后台线程调用，内部会切换到主线程

#### LiveData 如何保证数据不丢失？
* 新观察者注册时会立即收到最后一次的数据
* 配置更改时不会丢失数据(与 ViewModel 配合)

#### 如何合并多个 LiveData 源？
* 使用 MediatorLiveData 可以观察多个 LiveData 源
* 将多个源添加为 MediatorLiveData 的源

#### 在 Repository 层应该返回 LiveData 吗？
* 不建议，Repository 应保持框架无关性
* 建议返回 suspend 函数或 Flow，由 ViewModel 转换为 LiveData

#### LiveData 在 View 和 ViewModel 之间如何分工？
* ViewModel 暴露 LiveData
* View(Activity/Fragment) 观察 LiveData 并更新UI
* 业务逻辑应放在 ViewModel 中

#### LiveData 与数据绑定(Data Binding)如何配合？
* 直接在布局文件中绑定 LiveData
* 需要设置生命周期所有者 binding.lifecycleOwner = this

#### LiveData 与 StateFlow/SharedFlow 如何选择？
* LiveData 适合 Android UI 层，简单场景
* StateFlow/SharedFlow 适合复杂数据流，跨平台逻辑层
* LiveData 自动生命周期感知，Flow 需要手动收集

### Room

### Navigation

### DataStore & SharedPreferences & MMKV

### WorkManager
### 动态权限
### Lottie

### ViewBinding & DataBinding

### ViewPager2

### Gson & Moshi & KotlinX Serialization

### Proguard

### Jetpack Compose

## 三方组件
### RecyclerView

### Retrofit + Okhttp

#### HTTP 和 HTTPS 的区别？HTTPS 的加密流程？

### Ktor

### Hilt & Dagger & Koin 依赖导入

### Glide & Coil

### RxJava

### EventBus

### LeakCanary 

## Kotlin

### lateinit 和 by lazy 的区别

### 协程

### apply & with & let & run