---
layout: post
description: > 
  本文介绍了链表类型经典算法的学习记录
image: 
  path: /assets/img/blog/blogs_cpp.png
  srcset: 
    1920w: /assets/img/blog/blogs_cpp.png
    960w:  /assets/img/blog/blogs_cpp.png
    480w:  /assets/img/blog/blogs_cpp.png
accent_image: /assets/img/blog/blogs_cpp.png
excerpt_separator: <!--more-->
sitemap: false
---
# 【算法】链表刷题定向进阶
## 合并两个有序链表
https://leetcode.cn/problems/merge-two-sorted-lists/description/

```
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
示例 1：
    输入：l1 = [1,2,4], l2 = [1,3,4]
    输出：[1,1,2,3,4,4]
示例 2：
    输入：l1 = [], l2 = []
    输出：[]
示例 3：
    输入：l1 = [], l2 = [0]
    输出：[0]
 
提示：
• 两个链表的节点数目范围是 [0, 50]
• -100 <= Node.val <= 100
• l1 和 l2 均按 非递减顺序 排列
```

思路：
将其当作模拟题，新建一个头，将两个链表挨个遍历，比较大小，将较小的一个添加进新链表，再往后移动。
```cpp
class Solution {
public:
        ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
            ListNode* p = list1;
            ListNode* q = list2;
            if(p == nullptr){
                return q;
            }
            if(q == nullptr){
                return p;
            }
            // 选定p为基准
            ListNode* newHead = new ListNode(0,nullptr);
            ListNode* x = newHead;
            while(p!= nullptr || q != nullptr){
                if(p!= nullptr){
                    if(q == nullptr || p->val <= q->val){
                        x->next = p;
                        p = p->next;
                        x = x->next;
                    }
                }
                if(q!= nullptr){
                    if(p == nullptr || q->val < p->val){
                        x->next = q;
                        q = q->next;
                        x = x->next;
                    }
                }
            }
            return newHead->next;
        }
};
```

## 找到两个相交链表的交点节点
https://leetcode.cn/problems/3u1WK4/description/
```
给定两个单链表的头节点 headA 和 headB ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
图示两个链表在节点 c1 开始相交：
题目数据 保证 整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构 。
 
示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
示例 2：
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
示例 3：
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

思路：
先判断二者中有无空链表；两个链表相交必是同一个尾节点；计算是否共尾节点，同时计算出各自的长度，比较出长度差，将较长的那个先移动这个差值的距离，然后两个链表再一起移动，两个指针就会慢慢指向同节点，判断相等了返回即可。
```cpp
class Solution {
public:
       ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
            if(headA == nullptr || headB == nullptr){
                return nullptr;
            }
            ListNode *p = headA;
            ListNode *q = headB;
            int lenthA = 0;
            int lenthB = 0;
            while(p->next != nullptr) {
                p = p->next;
                lenthA++;
            }
            while(q->next != nullptr) {
                q = q->next;
                lenthB++;
            }
            if(p != q){
                return nullptr;
            }
            p = headA;
            q = headB;
            if(lenthA > lenthB){
                int diff = lenthA-lenthB;
                while(diff>0){
                    p = p->next;
                    diff--;
                }
            }
            if(lenthA < lenthB){
                int diff = lenthB-lenthA;
                while(diff>0){
                    q = q->next;
                    diff--;
                }
            }
            while(p != q){
                p = p->next;
                q = q->next;
            }
            return p;
        }
};
```

## 翻转链表
https://leetcode.cn/problems/UHnkqh/description/
```
给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。
 
示例 1：
    输入：head = [1,2,3,4,5]
    输出：[5,4,3,2,1]
示例 2：
    输入：head = [1,2]
    输出：[2,1]
示例 3：
    输入：head = []
    输出：[]
 
提示：
• 链表中节点的数目范围是 [0, 5000]
• -5000 <= Node.val <= 5000
 
进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？
```

思路
使用栈来暂存所有数据，出栈的时候新建一个头节点，来创建逆序链表。
使用容器处理，空间复杂度O(n)
```cpp
        ListNode* reverseList(ListNode* head) {
            stack<int> temp;
            ListNode * p = head;
            while(p != nullptr){
                cout<<"value: "<<p->val<<endl;
                temp.push(p->val);
                p = p->next;
            }
            ListNode* newHead = new ListNode();
            ListNode* q = newHead;

            while(!temp.empty()){
                cout<<"stack value: "<<temp.top()<<endl;
                ListNode* tempNode = new ListNode(temp.top());
                q->next = tempNode;
                q = q->next;
                temp.pop();
            }
            return newHead->next;
        }
```

## 思路2
官方题解，遍历链表，使用两个指针来保存当前值和上一个的值，同时在循环中需要暂时存储下一个节点地址，防止断链。
循环时，将当前节点的next节点的next指针指向当前节点，当前节点的next指针指向上一个节点，然后当前节点和上一个节点都往后走。
```cpp
// 只用了两个变量，空间复杂度 O(1)
        ListNode* reverseList2(ListNode* head) {
            ListNode* current = head;
            ListNode* priv = nullptr;
            while(current!=nullptr){
                ListNode* next = current->next;
                current->next = priv;
                priv = current;
                current = next;
            }
            return priv;
        }
```

## 翻转链表2
https://leetcode.cn/problems/UHnkqh/description/
```
给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
 
示例 1：
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
示例 2：
输入：head = [5], left = 1, right = 1
输出：[5]
 
提示：
• 链表中节点数目为 n
• 1 <= n <= 500
• -500 <= Node.val <= 500
• 1 <= left <= right <= n
 
进阶： 你可以使用一趟扫描完成反转吗？
```

思路
将要反转的区间掐断，采用上一题的方法来翻转，关键提前存储好区间左侧和右侧的第一个节点，方便再拼接回去，但是注意这里可能并没有前一个节点，所以加一个虚拟头节点，来承接翻转后的区间，免去多余判断。区间右侧的第一个节点为nullptr没有关系。
```cpp
class Solution {
public:
     ListNode* reverseList(ListNode* head) {
        ListNode* current = head;
        ListNode* priv = nullptr;
        while(current!=nullptr){
            ListNode* next = current->next;
            current->next = priv;
            priv = current;
            current = next;
        }
        return priv;
    }

        ListNode* reverseBetween(ListNode* head, int left, int right) {
            if(left==right){
                return head;
            }
            ListNode* dummyHead = new ListNode(-1);
            dummyHead->next = head;
            ListNode* p = dummyHead;
            ListNode* q = dummyHead;
            ListNode* first;
            ListNode* last;

            for(int i = 0;i<left-1;i++){
                p = p->next;
            }
            first = p->next;
            for(int j = 0;j<right;j++){
                q = q->next;
            }
            last = q;
            // 将q移到区间外第一个元素位置
            q = q->next;
            p->next = last;
            last->next = nullptr;
            ListNode* corridor = reverseList(first);
            while(corridor->next!=nullptr){
                corridor = corridor->next;
            }
            corridor->next = q;
            return dummyHead->next;
        }
};
```

## 翻转链表3（k个一组）
https://leetcode.cn/problems/reverse-nodes-in-k-group/description/
```
给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。
k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
 
示例 1：
    输入：head = [1,2,3,4,5], k = 2
    输出：[2,1,4,3,5]
示例 2：
    输入：head = [1,2,3,4,5], k = 3
    输出：[3,2,1,4,5]
 
提示：
• 链表中的节点数目为 n
• 1 <= k <= n <= 5000
• 0 <= Node.val <= 1000
 
进阶：你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？
```

思路
基于1 & 2版本，更需要控制好每一组之间的链接，尤其是循环后的翻转和善后工作。
记录了区间的头尾，区间的上一个，还有区间的下一个，用于断链后重新链接翻转后的区间。有别于官方题解，本地编译器用不了pair等C++11以后的库，所以区间翻转后，是通过移动区间头指针来找到翻转后的区间尾节点，来链接下一个点的。
```cpp
class Solution {
public:
    ListNode *reverseList(ListNode *head)
    {
        ListNode *current = head;
        ListNode *priv = nullptr;
        while (current != nullptr)
        {
            ListNode *next = current->next;
            current->next = priv;
            priv = current;
            current = next;
        }
        return priv;
    }

    ListNode *reverseKGroup(ListNode *head, int k)
    {
        ListNode *dummyHead = new ListNode(-1);
        dummyHead->next = head;
        ListNode *priv;
        ListNode *p = dummyHead;
        while (p != nullptr)
        {
            priv = p;
            ListNode *reverseHead = priv->next;
            for (int i = 0; i < k; i++)
            {
                p = p->next;
                if (p == nullptr)
                {
                    return dummyHead->next;
                }
            }
            ListNode *reverseTail = p;
            ListNode *nextNode = p->next;
            reverseTail->next = nullptr;
            ListNode *reversed = reverseList(reverseHead);
            priv->next = reversed;
            while (reversed->next != nullptr)
            {
                reversed = reversed->next;
            }
            p = reversed;
            reversed->next = nextNode;
        }
        return dummyHead->next;
    }
};
```

## 复制带随机指针的链表
https://leetcode.cn/problems/copy-list-with-random-pointer/description/
```
给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。
返回复制链表的头节点。
用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
• val：一个表示 Node.val 的整数。
• random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
你的代码 只 接受原链表的头节点 head 作为传入参数。
 
示例 1：
    输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
    输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
示例 2：
    输入：head = [[1,1],[2,1]]
    输出：[[1,1],[2,1]]
示例 3：
    输入：head = [[3,null],[3,0],[3,null]]
    输出：[[3,null],[3,0],[3,null]]
 
提示：
• 0 <= n <= 1000
• -104 <= Node.val <= 104
• Node.random 为 null 或指向链表中的节点。
```

### 思路1
使用一个map，键为原始链表节点 A ，值为新建的节点 A' ，在遍历原始链表的时候，看看原始节点的指针指向了哪里，通过map寻找对应节点key的value，就可以完全复制。
```cpp
class Solution {
    public:
        Node* copyRandomList(Node* head) {
            unordered_map<Node*, Node*> nodeMap;
            Node* p = head;
            while(p!=nullptr){
                nodeMap[p] = new Node(p->val);
                p = p->next;
            }
            p = head;
            while(p!=nullptr){
                // 映射的next等于next的映射
                nodeMap[p]->next = nodeMap[p->next];
                nodeMap[p]->random = nodeMap[p->random];
                p = p->next;
            }
            return nodeMap[head];
        }
    };
```

缺点：
> 使用了多一个的map空间，需要遍历两次，先添加一次，再根据映射关系来设置指向关系。

### 官方优化
一样使用了哈希表，但是使用了回溯算法，在第一个节点检查时就去创建指向的两个节点，如果为未创建过就新建一个填进map，如果已创建就不能再刷新value来了，而是直接复用这个值。少遍历了一遍执行时间从11ms，优化到了8ms。
```cpp
class Solution {
public:
    unordered_map<Node*, Node*> cachedNode;

    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        if (!cachedNode.count(head)) {
            Node* headNew = new Node(head->val);
            cachedNode[head] = headNew;
            headNew->next = copyRandomList(head->next);
            headNew->random = copyRandomList(head->random);
        }
        return cachedNode[head];
    }
};
```

### 思路2
以上空间复杂度O(n)，需要额外使用一个大map来存储节点，我们可以将新节点挨个插到每一个原始节点中间，然后遍历的时候，使用该节点指向原始节点的next指针来寻找刚刚新建的新节点，最后将新节点剥离出来。
```cpp
        Node* copyRandomList2(Node* head) {
            Node* p = head;
            // 第一遍将random指针复制完毕
            while(p!=nullptr){
                Node* newNode = new Node(p->val);
                newNode->next = p->next;
                newNode->random = p->random;
                p->next = newNode;
                p = newNode->next;
            }
            // 第二遍根据原链表的结构，步长为2，抽离出所有新节点
            Node* ans = head->next;
            Node* q = ans;
            Node* x = head;
            while(q->next!=nullptr){
                x->next = x->next->next;
                q->next = q->next->next;
                q = q->next;
            }
            return ans;
        }
```
官方运行未通过，反馈不可对原链表进行修改。这样操作后，原链表其实已经零散断开了。
## 判断环形链表
https://leetcode.cn/problems/linked-list-cycle/description/
```
给你一个链表的头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。
 
示例 1：
    输入：head = [3,2,0,-4], pos = 1
    输出：true
    解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：
    输入：head = [1,2], pos = 0
    输出：true
    解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：
    输入：head = [1], pos = -1
    输出：false
    解释：链表中没有环。
 
提示：
• 链表中节点的数目范围是 [0, 104]
• -105 <= Node.val <= 105
• pos 为 -1 或者链表中的一个 有效索引 。
 
进阶：你能用 O(1)（即，常量）内存解决此问题吗？
```

### 思路1
使用不可存在相同元素的set数据结构来存储每个节点的next地址，如果有相同的已经出现过，则说明有环，否则无环；
```cpp
class Solution {
public:
        bool hasCycle(ListNode *head) {
            set<ListNode*>  tempset;
            ListNode* p = head;
            tempset.insert(head);
            while(p!=nullptr){
                if(tempset.count(p->next)>0){
                    return true;
                }
                tempset.insert(p->next);
                p = p->next;
            }
            return false;
        }
};
```

这种方法空间复杂度为O(n)，执行时长也拍到了末尾；
### 思路2
使用快慢指针，快指针一次走两个，慢指针一次走一个，如果能碰到一起，说明肯定有环存在；
```cpp
    bool hasCycle2(ListNode *head)
    {
        ListNode *fast = head;
        ListNode *slow = head;
        while (slow != nullptr && fast != nullptr && fast->next != nullptr)
        {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast)
            {
                return true;
            }
        }
        return false;
    }
```
### 优化
while中使用三个判断条件，发现耗时有点长，将快指针的next空判断移到循环内部，可以进一步减少耗时。
```cpp
    bool hasCycle2(ListNode *head)
    {
        ListNode *fast = head;
        ListNode *slow = head;
        while (slow != nullptr && fast != nullptr)
        {
            if (fast->next != nullptr)
            {
                slow = slow->next;
                fast = fast->next->next;
                if (slow == fast)
                {
                    return true;
                }
            }
            else
            {
                return false;
            }
        }
        return false;
    }
```

## 找到环形链表的入环节点
https://leetcode.cn/problems/c32eOV/description/
```
给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。
 
示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
 
提示：
• 链表中节点的数目范围在范围 [0, 104] 内
• -105 <= Node.val <= 105
• pos 的值为 -1 或者链表中的一个有效索引
 
进阶：是否可以使用 O(1) 空间解决此题？
```

### 思路
还是使用set，当判断存在相同的地址时，直接返回这个节点地址即可。
```cpp
class Solution
{
public:
    ListNode *detectCycle(ListNode *head)
    {
        set<ListNode *> tempset;
        ListNode *p = head;
        tempset.insert(head);
        while (p != nullptr)
        {
            if (tempset.count(p->next) > 0)
            {
                return p->next;
            }

            tempset.insert(p->next);
            p = p->next;
        }
        return nullptr;
    }
};
```
> 同样多创建了一个空间来存储地址

### 思路2
这个只需完整记忆，证明过程太复杂。使用快慢指针，当他们相遇时，将快指针还原到头节点。而后，快指针也变成一次跳一步，继续循环，当快慢指针第二次相遇时，就是在入环的节点位置。
```cpp
  ListNode *detectCycle2(ListNode *head)
    {
        ListNode *fast = head;
        ListNode *slow = head;
        int meet_count = 0;
        while (fast != nullptr && slow != nullptr)
        {
            if (fast->next != nullptr)
            {
                slow = slow->next;
                if (meet_count == 0)
                {
                    fast = fast->next->next;
                    if (slow == fast)
                    {
                        fast = head;
                        meet_count++;
                    }
                }
                else
                {
                    fast = fast->next;
                    if (slow == fast)
                    {
                        return fast;
                    }
                }
            }
            else
            {
                return nullptr;
            }
        }
        return nullptr;
    }
```

> 在两个节点互相循环时有问题，可以说是互为入口，index是0，算出来是1.

## 链表排序
https://leetcode.cn/problems/7WHec2/
```
给定链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
 
示例 1：
    输入：head = [4,2,1,3]
    输出：[1,2,3,4]
示例 2：
    输入：head = [-1,5,3,4,0]
    输出：[-1,0,3,4,5]
示例 3：
    输入：head = []
    输出：[]
 
提示：
• 链表中节点的数目在范围 [0, 5 * 104] 内
• -105 <= Node.val <= 105
 
进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
```

思路1
使用multiset，可以添加重复元素，可以自动排序。
```cpp
class Solution
{
public:
    ListNode *sortList(ListNode *head)
    {
        if (head == nullptr)
        {
            return head;
        }
        multiset<int> sort_set;
        ListNode *p = head;
        while (p != nullptr)
        {
            sort_set.insert(p->val);
            p = p->next;
        }
        auto iterator = sort_set.begin();
        ListNode *newHead = new ListNode(*iterator);
        p = newHead;
        iterator++;
        while (iterator != sort_set.end())
        {
            ListNode *node = new ListNode(*iterator);
            p->next = node;
            p = p->next;
            iterator++;
        }
        return newHead;
    }
};
```

> 性能较差

### 思路2
自上而下归并排序，不断二分排序，完成后再将所有排序后的子链表合并
```cpp
```

> 时间复杂度：O(nlogn)，其中 n 是链表的长度。
空间复杂度：O(logn)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间。

### 思路3
自下而上归并排序，步长为1，遍历排序，步长为2，再次排序。
```cpp
```

> 时间复杂度：O(nlogn)，其中 n 是链表的长度。
空间复杂度：O(1)。

## 回文链表判断
https://leetcode.cn/problems/aMhZSa/description/
```
给定一个链表的 头节点 head ，请判断其是否为回文链表。
如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。
示例 1：
输入: head = [1,2,3,3,2,1]
输出: true
示例 2：
输入: head = [1,2]
输出: false
提示：
• 链表 L 的长度范围为 [1, 105]
• 0 <= node.val <= 9
 
进阶：能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
```

### 思路1
回文即正反看起来相同，第一种解法使用栈来压入所有元素，然后弹出栈元素同时遍历链表，看看二者每一个值是否一样。耗时224ms。
```cpp
class Solution
{
public:
    bool isPalindrome(ListNode *head)
    {
        ListNode *p = head;
        stack<int> temp_stack;
        while (p != nullptr)
        {
            temp_stack.push(p->val);
            p = p->next;
        }
        p = head;
        while (!temp_stack.empty())
        {
            if (p->val != temp_stack.top())
            {
                return false;
            }
            p = p->next;
            temp_stack.pop();
        }
        return true;
    }
};
```

### 思路2
快慢指针找中点，将慢指针置于中点或中点已左，快指针到末尾。翻转慢指针右侧节点，左侧子链表和右侧翻转过的两个链表进行比较，两链表的长度差值必须为1或0，相同位置元素必须相等。耗时160ms，中间如果有cout打印耗时220ms，这个看来也比较占时间。
```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* priv = nullptr;
        ListNode* p = head;
        while (p != nullptr) {
            ListNode* nextTemp = p->next;
            p->next = priv;
            priv = p;
            p = nextTemp;
        }
        return priv;
    }

    bool isPalindrome(ListNode* head) {
        if (head->next == nullptr) {
            return true;
        }
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast != nullptr) {
            if (fast->next != nullptr && fast->next->next != nullptr) {
                fast = fast->next->next;
            } else {
                break;
            }
            slow = slow->next;
        }
        // slow为中点，slow下一个为头，fast做尾，翻转链表
        ListNode* reverseHead = slow->next;
        slow->next = nullptr;
        ListNode* newSubList = reverseList(reverseHead);
        ListNode* p = head;
        ListNode* q = newSubList;
        while (p != nullptr && q != nullptr) {
            if (p->val != q->val) {
                return false;
            }
            p = p->next;
            q = q->next;
            if (p == nullptr && q != nullptr && q->next != nullptr) {
                return false;
            }
            if (q == nullptr && p != nullptr && p->next != nullptr) {
                return false;
            }
        }
        return true;
    }
};
```