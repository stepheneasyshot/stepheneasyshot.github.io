---
layout: post
description: > 
  本文介绍了Compose声明式框架从可组合项方法的编写到最终屏显的流程解析
image: 
  path: /assets/img/blog/blogs_cmp_new_cover.png
  srcset: 
    1920w: /assets/img/blog/blogs_cmp_new_cover.png
    960w:  /assets/img/blog/blogs_cmp_new_cover.png
    480w:  /assets/img/blog/blogs_cmp_new_cover.png
accent_image: /assets/img/blog/blogs_cmp_new_cover.png
excerpt_separator: <!--more-->
sitemap: false
---
# Compose编译到显示的流程解析
Jetpack Compose 是 Google 推出的用于构建原生 Android UI 的现代声明式框架，它简化了 Android 应用的 UI 开发过程。

将XMl+Java的开发方式转变为Kotlin语法的Compose的开发方式，让开发者可以使用更简洁、更直观的代码来构建用户界面，开发体验上极致的统一。

那么一个 `@Composable` 方法是如何变成屏幕上的显示内容的呢？下面从Android平台为切入点，从编译阶段到运行时阶段，详细解析 `Compose` 的显示流程。再看看`Compose Multiplatform`这个跨平台框架和 `Android` 平台上的原型`Jetpack Compose`有何异同。

## 回顾View架构
我们的应用要加载一个显示界面时，会经历以下几个阶段。首先将xml的布局文件，按照内部的父控件子控件的包含关系，将它们解析成View树，然后将View树交给WindowManager进行显示。

具体的：

### 1. xml文件解析构建View树
当调用 `setContentView(R.layout.xxx)` 或 `LayoutInflater.inflate()` 时，系统会通过 `LayoutInflater` 解析 XML 文件。

使用 `XmlPullParser` 逐行解析 XML 标签，转换为内存中的视图对象（如 TextView、LinearLayout 等）。

根据标签属性（如 android:text、android:layout_width）设置视图的初始参数。

解析后的 XML 会生成一个对应的 视图树（View Hierarchy），根节点是顶层布局（如 ConstraintLayout），子节点是嵌套的视图。

每个视图的构造函数会被调用，并通过 `AttributeSet` 读取 XML 中的属性值（如 textSize、background）。

### 2. 测量(Measure)
`onMeasure(int widthMeasureSpec, int heightMeasureSpec)` ，父视图通过 MeasureSpec 向子视图传递尺寸约束（如 match_parent、wrap_content 或固定值）。

视图根据约束计算自身尺寸（可能需要多次测量，尤其是嵌套布局）。

最终通过 `setMeasuredDimension()` 保存测量结果。

### 3. 布局(Layout)
`onLayout(boolean changed, int l, int t, int r, int b)` ，父视图根据测量结果确定子视图的位置（左上右下坐标）。

例如：LinearLayout 会按垂直/水平方向依次排列子视图。

### 4. 绘制(Draw)
`onDraw(Canvas canvas)` ，视图通过 Canvas 和 Paint 绘制自身内容（如文本、背景、边框）。

绘制顺序：背景 → 主体内容（如文本/图片） → 子视图 → 前景（如滚动条）。

支持硬件加速时，绘制指令会转为 RenderNode 并交由 GPU 处理。

### 5. 合成送显
`SurfaceFlinger` 合成。各层的绘制结果（Surface）由 SurfaceFlinger 合成为最终帧。提交到屏幕时，通过 VSync 信号同步，将帧数据发送到屏幕缓冲区显示。

一般View架构的应用，在做布局相关性能优化时，有如下手段：

> 减少布局层级：避免嵌套过深，用 ConstraintLayout 替代多层 LinearLayout。

> 避免过度绘制：通过 onDraw() 优化或设置 android:background=null。

> 使用 ViewStub：延迟加载复杂但非立即显示的布局。

## Compose 的 UI Tree
### 前言一 Gap Buffer
Gap Buffer 是一种用于优化局部更新的高效数据结构。其核心思想是通过维护一个 **可移动的“间隙”** 来优化局部性操作，在数组中预留一个空白区域（Gap）来实现高效的插入和删除操作，可以减少内存移动的开销。

#### **最常见的应用——文本编辑器**
​缓冲区结构​​，将内存分为三部分：左文本区、间隙（Gap）和右文本区。
初始时，间隙通常位于缓冲区末尾（如 `[文本][间隙]` ），但随着输入的光标移动，这个间隙会动态调整位置。

* ​当在光标处插入字符时，直接将数据填入间隙。若间隙不足，则扩展间隙（如重新分配更大的内存）。
* 删除字符时，通过调整间隙边界“吸收”被删除的字符，避免立即移动数据。
* ​​光标移动​​：移动光标时，间隙会同步移动到新位置，此时需要将原间隙两侧的文本交换位置（例如，光标右移时，将右文本区的左端字符移到左文本区末尾）。

关键操作示例​​:
```
​​插入字符​​：
假设缓冲区状态：[Hello][ ][World]（[]表示间隙）。
在Hello后插入! → [Hello!][ ][World]，间隙缩小。

​​移动光标​​：
光标从Hello!后移动到W前：
原状态：[Hello!][ ][World]
移动后：[Hello! ][W][orld]（间隙移动到W前，W从右文本区移到左文本区）。

​​删除字符​​：
删除W → [Hello! ][][orld]，间隙扩展“吸收”W。
```

其优势主要为高效的局部操作，劣势为大范围的操作时，需要移动大量数据调整间隙的位置，最坏的情况下可能需要O(n)的时间复杂度。同时间隙填满后，扩展的成本也较高。

### 前言二 Slot Table
#### **数据结构描述**
SlotTable 是 Compose 里的内部数据结构，用于跟踪 **组合层次结构** 中的视图数据，包括 **节点、组、键和记忆值** 。这个数据结构上的各个组的结构及其值由编译器决定，并在运行时随着层次结构和应用状态的建立和更新而变化。

SlotTable 是一个 **树形结构** ，其中每个节点都是一个组，且内部可能有子项。其每个元素被称作“插槽（Slot）”。每个插槽能存储特定类型的数据，像组件的类型、属性、状态等信息。它以扁平化的方式存储 UI 树的信息，取代了传统的树形结构，从而简化了 UI 的管理与更新操作。

组（Groups）包含以下信息：
1. **键**： 用于区分组的识别符，通过快速识别组的变化来帮助重新组合。它不需要是唯一的。
2. **标志**： 有关分组的元数据，包括分组所含节点数的计数器。
3. **槽**： 为组存储的值的有序列表，可以修改或删除。槽支持引用类型和基元，可独立跟踪以避免自动排序惩罚。实用槽由槽表管理，其他槽则由金豪编译器生成，跟踪记忆值和可编译函数参数。

还有以下的可选属性：
1. **节点**：与组相关联的节点，由 Applier 使用。Composer 通过 SlotTable 在内部维护这些节点。
2. **对象键**：补充标准整数键的可选键。
3. **辅助值***：与节点相关联的辅助数据值，设置与组的其他槽无关。它用于记录 CompositionLocal 地图。

SlotTable 的实现是一个基于页面的链接表，它将组信息编码成整数，并将其打包成数组，以避免额外的分配。组内部维护了 **几个指针** 指向其父组、第一个子组和下一个同级组的指针，编码为指向页面的地址和页面内的索引。

该数据结构返回和使用的所有 GroupAddresses 都是稳定的。一旦分配，地址将不会改变，除非将组删除并重新添加到表中。

一个 SlotTable 可以与另一个 SlotTable 共享地址空间，这样就可以通过指针重新分配而不是内存复制，在表之间有效地移动组。

### 编译器对 Composable 函数的转换
我们编写界面UI时，使用的可组合项都会添加一个 `@Composable` 注解，被 @Composable 所注解的函数称为 `可组合函数` 。

添加该注解的函数会被真实地改变类型，改变方式与 suspend 类似，在编译期进行处理，只不过 Compose 并非语言特性，无法采用语言关键字的形式进行实现。

示例：
```kotlin
@Composable
fun Greeting(name: String) {
    Text("Hello $name")
}

// 编译器生成的近似结构（概念性表示）
fun Greeting(name: String, parentComposer: Composer, changed: Int) {
    val composer = parentComposer.startRestartGroup(GROUP_HASH)

    val dirty = calculateState(changed)
    
    if (stateHasChanged(dirty) || composer.skipping) {
        Text("Hello $name", composer = composer, changed = ...)
    } else {
        composer.skipToGroupEnd()
    }

    composer.endRestartGroup()?.updateScope {
        Greeting(name, changed)
    }
}
```

可见被 `@Composable` 注解后，函数增添了额外的参数，其中的 `Composer` 类型参数 **作为运行环境** 贯穿在整个可组合函数调用链中，所以可组合函数无法在普通函数中调用，因为 **不包含相应的环境** 。

可组合函数实现的起始与结尾通过 `Composer.startRestartGroup()` 与 `Composer.endRestartGroup()` 在 Slot Table 中创建 Group，而可组合函数内部所调用的可组合函数在两个调用之间创建新的 Group，从而 **在 Slot Table 内部完成视图树的构建** 。

Composer 根据当前是否正在修改视图树而确定这些调用的实现类型。

在视图树构建完成后，若数据更新导致部分视图需要刷新，此时非刷新部分对应可组合函数的调用就不再是进行视图树的构建，而是视图树的访问，正如代码中的 `Composer.skipToGroupEnd()` 调用，表示在访问过程中直接跳到当前 Group 的末端。

Composer 对 Slot Table 的操作是读写分离的，只有写操作完成后才将所有写入内容更新到 Slot Table 中。

除此之外，可组合函数还将通过 **传入标记参数的位运算** 判断内部的可组合函数执行或跳过，这可以 **避免访问无需更新的节点** ，提升执行效率。

#### **Gap Buffer在 Compose 中的应用**
Gap Buffer 是 Compose 内部用于管理 Slot Table 的核心数据结构。

Compose 编译器会将 `@Composable` 函数编译成上面的形式。当Compose 运行时执行这些函数，并将组合项的信息添加到一个名为 Slot Table 的数据结构中。`Slot Table` 的每个槽可以存储关于 Composable 的信息，如其参数、内部状态（如 `remember` 持有的值）以及其他组合细节。它本质上是记录组合过程的。

而 `Gap Buffer` 是 `Slot Table` 的底层实现。在 Slot Table 的上下文中，当 UI 由于状态变化而需要更新时（重组），Compose 需要更新 Slot Table 中的特定部分。由于移动 gap 本身是一个 `O(n)` 操作，这在典型的 UI 更改中并不频繁。大多数 UI 更新涉及的为小的、局部化的修改，Gap Buffer 在这些场景中非常高效。

Compose 不直接构建传统的 "view tree" 像 Android Views 那样，但它确实在 **Composition 阶段** 构建了一个 **UI tree** (node tree) 。这个 UI tree 代表了 UI 元素的层次结构。Slot Table会使用 Gap Buffer 来存储与这个 UI tree 相关的元数据和状态信息。当状态改变时，Compose 会确定哪些 `@Composable` 函数需要重组。即基于 Slot Table 中的信息来确定哪些部分的 UI tree 需要更新。由于 gap buffer 的高效性，Compose 可以在 Slot Table 中高效地插入、删除或移动 "组" 中的 composables 可组合项，而不需要重建整个 UI tree。这就是 Compose 实现 "smart recomposition" 的关键所在，即只更新受状态变化影响的部分，从而显著提高性能。

整体结构的工作流程如下： 

**1. 组合阶段**
在首次运行或状态改变时，Composable 函数会被执行，生成 UI 描述树。此时，Composer 会遍历这个 UI 描述树，把相关信息写入 Slot Table。例如，可组合函数实现的起始与结尾通过 Composer.startRestartGroup() 与 Composer.endRestartGroup() 在 Slot Table 中创建 Group，以此来表示 UI 树的层次结构。

**2. 差异比较阶段**
当可组合项所观测的 `mutableStateOf` 值发生变化，导致部分组合无效。
Compose 重新执行受到影响的 `@Composable` 函数。即触发了重组，Composer 会将新生成的 UI 描述树与 Slot Table 里存储的上一次组合结果进行比较，找出需要更新的部分，生成一个变更列表（Change List）。

**3. 更新阶段**
依据变更列表，Composer 对 Slot Table 进行更新，仅修改那些发生变化的插槽，而不改变未变化的部分。这可能涉及插入新的槽来表示新的 composables，删除槽来表示移除的 composables，或者更新现有槽的数据以反映参数/状态的变化。这种局部更新的方式提升了 UI 更新的效率。

## Compose的测量过程
