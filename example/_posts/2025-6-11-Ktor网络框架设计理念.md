---
layout: post
description: > 
  本文介绍了更适配Kotlin的网络框架Ktor的设计理念和实现原理
image: 
  path: /assets/img/blog/blogs_ktor_cover.png
  srcset: 
    1920w: /assets/img/blog/blogs_ktor_cover.png
    960w:  /assets/img/blog/blogs_ktor_cover.png
    480w:  /assets/img/blog/blogs_ktor_cover.png
accent_image: /assets/img/blog/blogs_ktor_cover.png
excerpt_separator: <!--more-->
sitemap: false
---
# Ktor网络框架设计理念
Ktor 是一个由 JetBrains 开发的，用于在 Kotlin 中构建连接应用的异步框架。它旨在提供一个轻量级、灵活且高度可扩展的网络应用框架，既可以用于构建服务器端应用（如 RESTful API、微服务、Web 网站），也可以用于构建多平台 HTTP 客户端应用。
## Android平台上的基础使用
首先添加gradle依赖：
```groovy
implementation "io.ktor:ktor-client-core:$ktor_version"
implementation "io.ktor:ktor-client-android:$ktor_version"
```

之后就可以使用HttpClient定制化，例如添加日志、内容协商、序列化等功能。然后就可以使用HttpClient发送请求了。

```kotlin
class KtorClient {

    companion object {
        const val TAG = "KtorClient"
    }

    private val client = HttpClient(CIO) {
        install(Logging) {
            level = LogLevel.ALL
        }
        install(ContentNegotiation) {
            json(Json {
                prettyPrint = true
                isLenient = true
            })
        }
    }

    suspend fun getGithubRepos(userName: String) = withContext(Dispatchers.IO) {
        client.get("https://api.github.com/users/${userName}/repos")
            .body<List<GithubRepoItem>>()
    }

    fun release() {
        client.close()
    }
}
```

> CIO 是 Ktor 自己的纯 Kotlin 实现的 I/O 引擎。它的设计目标是轻量级、无额外依赖、并完全基于 Kotlin 协程构建。这意味着它能最大程度地利用 Kotlin 协程的异步特性，提供高效且非阻塞的 I/O 操作。它直接利用 Kotlin 协程的调度和挂起机制来处理网络事件。它的内部实现尽可能地避免了阻塞操作，并且通过协程调度来管理并发连接。

## 设计理念
### 纯 Kotlin 和协程优先（Kotlin and Coroutines First）
Ktor 完全基于 Kotlin 语言构建，充分利用 Kotlin 的语言特性，例如 DSL（领域特定语言）、扩展函数、协程等。

Ktor 的异步编程模型是基于 Kotlin 协程实现的。这意味着开发者可以使用看似 **同步的命令式代码来编写异步逻辑** ，极大地简化了并发编程的复杂性，避免了回调地狱，并提高了代码的可读性和可维护性。每个请求都会在 Ktor 中启动一个新的协程来处理，从而实现高效的并发。
### 轻量级和非侵入式（Lightweight and Unopinionated）
Ktor 不强加固定的项目结构或技术栈。它允许开发者根据自己的需求选择日志、模板引擎、消息队列、持久化、序列化、依赖注入等各种技术。

它提供了一个松散耦合的架构，你可以只使用你需要的功能，而不是一个庞大的全功能框架。这种灵活性使得 Ktor 非常适合构建微服务或需要高度定制化的应用。

Ktor 的 API 大多是函数调用和 Lambda 表达式，结合 Kotlin 的 DSL 能力，使代码看起来声明式且简洁。
### 高度可扩展性（Highly Extensible via Plugins/Features）
Ktor 采用 “插件” 机制来实现其核心功能和可扩展性。诸如内容协商、身份验证、日志、会话管理、压缩等功能都是通过安装插件来实现的。

这种统一的拦截机制允许在请求/响应处理管道的不同阶段插入自定义逻辑。开发者可以轻松地编写自己的插件来扩展 Ktor 的功能，或者集成第三方库。
### 多平台支持（Multiplatform Support）
Ktor 不仅仅局限于 JVM。Ktor Client 模块支持 Kotlin Multiplatform Mobile (KMM)，允许在 Android、iOS、桌面以及服务器端共享网络逻辑。这使得 Ktor 成为构建跨平台应用的理想选择。
### 类型安全路由（Type-Safe Routing）
Ktor 提供了类型安全的路由机制，允许通过类而不是字符串来定义 API 结构和路由参数。这在编译时就可以验证路由参数和路径，减少了常见的运行时错误，并使得重构更加安全和可管理。
## 实现方式
Ktor 的实现方式主要围绕以下几个关键概念：

1.  **应用程序（Application）和模块（Module）**：
    * 一个 Ktor 应用通常由一个或多个 `Application` 实例构成。`Application` 是 Ktor 应用的入口点，负责配置服务器、注册路由和安装插件。
    * `Module` 是一个函数，通常以 `Application.module()` 形式定义，用于组织应用程序的逻辑，例如定义路由、安装插件、配置依赖等。这种模块化有助于保持代码的整洁和可维护性。

2.  **嵌入式服务器和引擎（Embedded Server and Engines）**：
    * Ktor 可以作为自包含的包运行，也可以部署到 Servlet 容器（如 Tomcat 或 Jetty）中。
    * 对于自包含的应用，Ktor 通过 `embeddedServer` 函数来创建和运行服务器。它支持多种底层的服务器引擎，如 Netty（默认）、Jetty、CIO（基于 Kotlin 协程的纯 Kotlin I/O 引擎）。开发者可以根据需求选择不同的引擎。
    * 这些引擎利用异步 I/O 功能来避免线程阻塞，与 Ktor 的协程模型完美结合。

3.  **请求/响应管道（Request/Response Pipeline）**：
    * Ktor 的核心是一个灵活的请求/响应处理管道。当一个 HTTP 请求到达 Ktor 服务器时，它会经过一系列的管道阶段，每个阶段都可以由插件进行拦截和处理。
    * 这些阶段包括：
        * **Setup**：应用程序初始化和配置阶段。
        * **Features**：安装的插件在此阶段执行它们的逻辑，例如身份验证、内容协商、压缩等。
        * **Call**：处理实际的 `ApplicationCall` 对象，这是 Ktor 中表示单个 HTTP 请求和响应的上下文。
        * **Routing**：根据定义的路由规则匹配请求并分派到相应的处理程序。
        * **Application**：应用程序的业务逻辑执行。
        * **Fallback**：处理未被其他阶段处理的请求。
    * 插件可以在管道的不同阶段注册拦截器，从而在请求处理过程中执行自定义操作，例如在请求到达路由之前进行身份验证，或者在响应发送给客户端之前进行数据转换。

4.  **路由（Routing）**：
    * Ktor 的路由系统使用 Kotlin 的 DSL 功能，提供了一种流畅的、层次化的方法来定义路由。
    * 路由可以通过 `get()`, `post()`, `route()` 等函数来定义，支持路径参数、查询参数、表单数据和文件上传。
    * 可以通过扩展函数将相关的路由逻辑分组到单独的文件中，实现更好的模块化。

5.  **协程和挂起函数（Coroutines and Suspending Functions）**：
    * Ktor 的所有 I/O 操作（网络通信、文件读写、数据库访问等）都设计为非阻塞的，并利用 Kotlin 协程的挂起函数 (`suspend` 关键字)。
    * 当一个挂起函数被调用时，如果当前操作需要等待（例如等待网络响应），协程会暂停执行并释放底层线程，允许该线程处理其他任务。当等待的操作完成后，协程会在同一个或不同的线程上恢复执行。
    * 这种模型使得 Ktor 能够以很少的线程处理大量的并发请求，从而提高资源利用率和吞吐量。

6.  **插件（Plugins）**：
    * 插件是 Ktor 中实现功能扩展的主要方式。它们通过 `install()` 函数添加到 `Application` 或 `Route` 中。
    * Ktor 提供了许多内置插件，例如 `ContentNegotiation`（用于 JSON/XML 序列化与反序列化）、`Authentication`、`Sessions`、`Logging`、`CORS` 等。
    * 开发者也可以编写自定义插件来满足特定需求，通过实现 `Plugin` 接口或使用 `createApplicationPlugin` 函数。

7.  **`ApplicationCall` 对象**：
    * `ApplicationCall` 对象是 Ktor 中处理单个请求的核心上下文。它封装了 HTTP 请求（`request`）和响应（`response`）的所有信息。
    * 在路由处理程序中，你可以通过 `call.request` 访问请求头、请求体、查询参数、路径参数等；通过 `call.respond()` 发送各种类型的响应（文本、JSON、文件、HTML 等）。

通过以上设计理念和实现方式，Ktor 提供了一个强大、灵活且高效的框架，使得使用 Kotlin 构建现代网络应用程序变得简单而愉快。


## 跨平台支持
Ktor 客户端在 Kotlin Multiplatform (KMP) 环境中实现网络请求是一个非常巧妙且强大的设计。它的核心思想是提供一个统一的、类型安全的 API，这个 API 在不同的目标平台（JVM、Android、iOS、JS、Native）上会利用各自平台最佳的网络实现，从而达到“一次编写，多处运行”的效果。

### Ktor 客户端跨平台网络请求的核心实现方式

Ktor 客户端的跨平台实现主要依赖于 Kotlin Multiplatform 的以下关键特性和 Ktor 自身的设计：

1.  **期望/实际声明（`expect`/`actual` declarations）**：
    * 这是 KMP 实现跨平台的核心机制。Ktor 利用 `expect` 关键字在 `common` 模块（共享代码）中声明通用的接口或类（例如 `HttpClient` 的具体实现细节）。
    * 然后，在每个特定平台的模块（例如 `jvmMain`、`androidMain`、`iosMain`、`jsMain` 等）中，使用 `actual` 关键字提供这些 `expect` 声明的具体实现。
    * **Ktor 的应用：** Ktor 的 `HttpClient` 本身是 `common` 模块的一部分，它提供了发送 HTTP 请求的通用 API（如 `get()`, `post()`, `request()` 等）。然而，真正的网络 I/O 操作（如建立 TCP 连接、发送 HTTP 字节流、接收响应字节流）是平台相关的。Ktor 在 `expect`/`actual` 机制的帮助下，为每个目标平台提供了不同的底层网络引擎的 `actual` 实现。

2.  **抽象与封装：**
    * Ktor 客户端在 `common` 模块中提供了一层高级抽象，如 `HttpClient`、`HttpRequestBuilder`、`HttpResponse` 等。这些抽象定义了网络请求和响应的通用概念和行为。
    * 开发者在共享代码中编写网络请求时，使用的是这些通用的抽象，而无需关心底层具体的网络实现。

3.  **可插拔的引擎（Pluggable Engines）：**
    * 如前所述，Ktor 客户端通过 **“引擎”** 的概念来适配不同平台的底层网络库。
    * `HttpClient` 的构造函数可以接收一个 `HttpClientEngineFactory` 参数，用于指定要使用的引擎。
    * 例如：
        * 在 JVM 上，你可以选择 `CIO`、`Apache`、`OkHttp` 或 `JettyHttp2Engine`。
        * 在 Android 上，你可以选择 `OkHttp` 或 Ktor 提供的 Android 专用引擎。
        * 在 iOS 上，Ktor 会使用 `NSURLSession` 作为底层引擎。
        * 在 Web 浏览器上，Ktor 会使用 `fetch` API 或 `XMLHttpRequest`。
        * 在 Kotlin/Native 桌面应用上，可以使用 `Curl` 或 `CIO`。
    * 当你在 `common` 模块中创建 `HttpClient` 实例时，通常不会直接指定具体的引擎，而是让构建系统根据目标平台自动选择合适的 `actual` 引擎实现。或者，你可以通过 KMP 项目的依赖管理在特定平台的 `build.gradle.kts` 中明确引入并指定引擎。

4.  **协程驱动的异步模型：**
    * 无论底层引擎如何，Ktor 客户端的 API 都设计为协程驱动的。所有的网络请求方法都是 `suspend` 函数。
    * 这意味着在共享代码中，你可以使用线性、同步风格的代码来编写异步网络请求逻辑，而 Kotlin 编译器和运行时会在幕后处理线程切换、挂起和恢复，从而避免了回调地狱，提高了代码的可读性和可维护性。

### 客户端网络请求的流程示例

让我们以一个简单的 GET 请求为例，看看它是如何在 Ktor 客户端中跨平台工作的：

1.  **共享模块 (`commonMain`) 中的代码：**
    ```kotlin
    // commonMain/src/main/kotlin/com/example/shared/ApiClient.kt
    package com.example.shared

    import io.ktor.client.*
    import io.ktor.client.call.*
    import io.ktor.client.request.*
    import io.ktor.client.statement.* // For HttpResponse

    class ApiClient {
        private val httpClient = HttpClient() // 默认会选择合适的引擎

        suspend fun fetchGreeting(): String {
            val response: HttpResponse = httpClient.get("https://api.example.com/greeting")
            return response.body<String>() // 假设响应是纯文本
        }
    }
    ```
    * 在这段代码中，我们创建了一个 `HttpClient` 实例，并使用它的 `get()` 挂起函数发送了一个 GET 请求。`body<String>()` 也是一个挂起函数，用于解析响应体。
    * 这段代码是纯 Kotlin，可以在所有 KMP 目标平台编译和运行。

2.  **特定平台模块中的实现 (`actual` 引擎选择)：**

    * **JVM/Android (`jvmMain`/`androidMain`):**
        在 `build.gradle.kts` 中，你可能会这样配置依赖：
        ```kotlin
        // build.gradle.kts (common part)
        kotlin {
            sourceSets {
                commonMain.dependencies {
                    implementation("io.ktor:ktor-client-core:x.y.z")
                    implementation("io.ktor:ktor-client-content-negotiation:x.y.z")
                    // ... other common dependencies
                }
                jvmMain.dependencies {
                    implementation("io.ktor:ktor-client-okhttp:x.y.z") // 或者 ktor-client-apache, ktor-client-cio
                }
                androidMain.dependencies {
                    implementation("io.ktor:ktor-client-okhttp:x.y.z") // Android 通常推荐 OkHttp
                }
            }
        }
        ```
        当 JVM 或 Android 应用程序运行时，Ktor 的 `HttpClient` 内部会自动检测到 `ktor-client-okhttp`（或你配置的其他引擎）的存在，并使用其 `actual` 实现来执行网络请求。OkHttp 会负责底层的 Socket 连接、HTTP 协议解析、SSL/TLS 握手等。

    * **iOS (`iosMain`):**
        在 `build.gradle.kts` 中：
        ```kotlin
        // build.gradle.kts (common part)
        kotlin {
            sourceSets {
                // ...
                iosMain.dependencies {
                    implementation("io.ktor:ktor-client-darwin:x.y.z") // Darwin 引擎，基于 NSURLSession
                }
            }
        }
        ```
        当 iOS 应用程序运行时，`ktor-client-darwin` 模块中的 `actual` 实现会被使用。这个实现会调用 iOS 系统的 `NSURLSession` API 来发起网络请求。`NSURLSession` 负责在 iOS 设备上执行网络 I/O。

    * **Web (`jsMain`):**
        在 `build.gradle.kts` 中：
        ```kotlin
        // build.gradle.kts (common part)
        kotlin {
            sourceSets {
                // ...
                jsMain.dependencies {
                    implementation("io.ktor:ktor-client-js:x.y.z") // JS 引擎
                }
            }
        }
        ```
        当 JavaScript 应用程序（在浏览器或 Node.js 中）运行时，`ktor-client-js` 模块中的 `actual` 实现会被使用。这个实现通常会利用浏览器内置的 `fetch` API 或 `XMLHttpRequest` 来发送 HTTP 请求。

### 总结

Ktor 客户端通过以下机制实现了跨平台网络请求：

* **API 统一：** `common` 模块提供统一的、协程驱动的 HTTP 客户端 API。
* **引擎抽象：** 定义了可插拔的“引擎”接口，用于封装平台特定的网络实现。
* **`expect`/`actual` 实现：** 利用 Kotlin Multiplatform 的 `expect`/`actual` 机制，在每个目标平台提供引擎接口的具体 `actual` 实现，这些实现会调用平台原生的网络库。
* **编译时选择：** 在编译时，Kotlin 编译器会根据目标平台，将 `common` 模块中的 `expect` 调用替换为对应平台模块中的 `actual` 实现。

这种设计使得开发者可以在共享代码中编写高性能、可读性强的网络逻辑，同时又能充分利用各个平台底层网络库的性能和特性，无需为每个平台重复编写网络通信代码。这大大提高了开发效率和代码的可维护性，尤其对于构建同时面向移动、桌面和 Web 平台的应用而言，Ktor 客户端是理想的选择。