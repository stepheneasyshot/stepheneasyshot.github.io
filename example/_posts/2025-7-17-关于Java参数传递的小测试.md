---
layout: post
description: > 
  本文介绍了Java方法参数传递过程中的一些规则，理清了一些流程
image: 
  path: /assets/img/blog/blogs_android_video_cover.jpg
  srcset: 
    1920w: /assets/img/blog/blogs_android_video_cover.jpg
    960w:  /assets/img/blog/blogs_android_video_cover.jpg
    480w:  /assets/img/blog/blogs_android_video_cover.jpg
accent_image: /assets/img/blog/blogs_android_video_cover.jpg
excerpt_separator: <!--more-->
sitemap: false
---
# 关于Java参数传递的小测试
很早之前就了解到，Java方法传递参数是值传递，不是引用传递。

在C++中，我们可以把参数设置为外部变量的引用，就可以直接通过这个引用操作外部变量。例如C++的函数参数，如果在合适的时机，按引用传递，可以省去变量复制的步骤，优化性能。

```cpp
#include <iostream>
using namespace std;

void GetSquare(int& number)
{
   number *= number;
}

int main()
{
   cout << "Enter a number you wish to square: ";
   int number = 0;
   cin >> number;

   GetSquare(number);
   cout << "Square is: " << number << endl;

   return 0;
}
```

Java是没有这样的机制的。
## 🧠 一、Java 是值传递，不是引用传递

首先明确一点：

> **Java 中所有的参数传递都是值传递（pass by value），没有引用传递（pass by reference）。**

这句话还有两个扩展结论：
- 当你传递一个基本类型（如 `int`, `boolean` 等）给方法时，传递的是它的值的副本。
- 当你传递一个对象（如 `String`, `Activity` 等）给方法时，传递的是该对象的**引用的副本**，而不是对象本身的副本。

举个例子：

```java
void modifyObject(MyObject obj) {
    obj.setValue(100);  // 修改的是原对象的内容
    obj = new MyObject(); // 修改的是局部变量 obj 的引用，不影响外部
}

MyObject myObj = new MyObject();
modifyObject(myObj);
// myObj 指向的对象被修改了，但 myObj 本身还是原来的引用
```

在这个例子中：

- `obj` 是 `myObj` **引用的一个副本**，它们指向同一个对象。
- 所以通过 `obj.setValue(100)` 可以修改原对象的内容。
- 但是 `obj = new MyObject()` 只是让局部变量 `obj` 指向了一个新对象，**不会影响外部的 `myObj`**。


## 🤔 二、为什么 Activity 作为参数“看起来”没有被复制？

你观察到：

> 在 Android 中，当把一个 `Activity` 作为参数传递给某个方法时，似乎没有复制一个新的 `Activity` 对象，而是直接操作了原来的 `Activity`。

这其实**正是 Java 值传递的正常表现**，并不是什么特殊现象。

### 具体解释：

假设你有如下代码：

```java
startSomeProcess(MainActivity.this);
```

这里的 `MainActivity.this` 是当前 `Activity` 的引用（即指向 `Activity` 对象的一个指针）。当你把这个引用作为参数传递给方法时：

```java
void startSomeProcess(Activity activity) {
    activity.setTitle("New Title"); // 修改的是原 Activity 的标题
    activity = new Activity();     // 这里只是修改了局部变量 activity 的指向
}
```

- `activity` 是 `MainActivity.this` 引用的一个副本（即引用的值被复制了一份）。
- 所以 `activity.setTitle("New Title")` 修改的是原来的 `Activity` 对象。
- 但是 `activity = new Activity()` 只是让方法内部的局部变量 `activity` 指向了一个新的 `Activity` 对象，**不会影响外部的 `MainActivity.this`**。

这完全符合 Java 的值传递机制。

---

## ❓ 为什么你感觉 "Activity 没有被复制"？

你之所以觉得 “Activity 没有被复制”，可能是因为：

1. **你观察到方法内部对 `Activity` 的修改影响了外部的 `Activity`**  
   这是因为你传递的是 `Activity` 的引用副本，而这个副本和原引用指向的是同一个对象。所以通过这个引用修改对象的内容，外部自然也会看到变化。

2. **你没有在方法内部重新赋值 `Activity` 引用**  
   如果你在方法内部写了类似 `activity = new Activity()` 的代码，你会发现外部的 `Activity` 并不会被影响，因为这只是改变了局部变量的指向，而不是原引用。

---

## ⚠️ 特别注意：Activity 是一个特殊的对象

虽然 `Activity` 作为参数传递时遵循 Java 的值传递规则，但需要特别注意：

### 1. `Activity` 是一个重量级对象，通常不应该作为方法参数频繁传递

- `Activity` 本身包含大量状态信息、视图层次结构、生命周期管理等。
- 将 `Activity` 作为参数传递，尤其是跨组件传递（如从 Fragment 传递到工具类、Service 等），是一种不好的实践，可能导致内存泄漏或逻辑混乱。

### 2. `Activity` 持有 `Context`，而 `Context` 是与生命周期强相关的

- 如果你在一个**长生命周期对象**（如单例、静态变量、Service 等）中持有 `Activity` 的引用，可能会导致 `Activity` 无法被回收，从而引发内存泄漏。
- 这也是为什么 Android Lint 会对 `static` 字段持有 `Activity` 发出警告（`StaticFieldLeak`）。

---

## ✅ 正确做法建议

如果你需要在多个地方使用 `Activity` 的功能，建议：

1. **避免直接传递 `Activity` 对象**  
   尽量通过接口、回调或者 `Context`（非 `Activity` 类型）来解耦。

2. **使用 Application Context 替代 Activity Context（如果可以）**  
   比如加载资源、启动 Service 等操作可以使用 `getApplicationContext()`，避免持有 `Activity`。

3. **使用弱引用（WeakReference）来持有 Activity（必要时）**  
   如果确实需要在某个长生命周期对象中引用 `Activity`，可以使用 `WeakReference<Activity>`，这样即使 `Activity` 被销毁，也不会阻止垃圾回收。

示例：

```java
private WeakReference<Activity> activityRef;

public void setActivity(Activity activity) {
    this.activityRef = new WeakReference<>(activity);
}

public void doSomething() {
    Activity activity = activityRef.get();
    if (activity != null && !activity.isFinishing()) {
        activity.setTitle("Safe Title Change");
    }
}
```

---

## 🧾 总结

| 问题 | 解释 |
|------|------|
| Java 是值传递还是引用传递？ | Java 只有值传递，没有引用传递。传递对象时，传递的是引用的副本。 |
| 为什么 Activity 作为参数“看起来”没有被复制？ | 因为传递的是引用的副本，这个副本和原引用指向同一个对象，所以通过它修改对象内容会反映到外部。 |
| 方法内部重新赋值 `Activity` 会影响外部吗？ | 不会，因为只是改变了局部变量的指向，原引用不受影响。 |
| Activity 作为参数传递是否推荐？ | 不推荐，尤其是跨组件传递。应尽量使用解耦方式，如接口、回调、Context 等。 |
| 如何避免 Activity 内存泄漏？ | 避免在长生命周期对象中直接持有 `Activity` 引用，必要时使用 `WeakReference`。 |

---

如果你有具体的代码场景，比如在哪里传递 `Activity` 参数、为什么要传递它，也可以贴出来，我可以进一步帮你分析是否合理以及如何优化。


