---
layout: post
description: > 
  本文记录了我学习C++的一些基础条目知识
image: 
  path: /assets/img/blog/blogs_cpp.png
  srcset: 
    1920w: /assets/img/blog/blogs_cpp.png
    960w:  /assets/img/blog/blogs_cpp.png
    480w:  /assets/img/blog/blogs_cpp.png
accent_image: /assets/img/blog/blogs_cpp.png
excerpt_separator: <!--more-->
sitemap: false
---
# C++基础记录（二）
本文是C++扫盲的第二篇记录，从STL标准模板往后的一些进阶内容。

前面的相关文章：

[C++基础记录](./2024-9-25-C++基础记录.md)

[【算法刷题】C++常见容器使用集合](./2025-4-5-【算法刷题】C++常见容器使用集合.md)

## STL容器
**STL 顺序容器** 如下所示。
* std::vector：操作与动态数组一样，在最后插入数据；可将 vector 视为书架，您可在一端添加和拿走图书。
* std::deque：与 std::vector 类似，但允许在开头插入或删除元素。
* std::list：操作与双向链表一样。可将它视为链条，对象被连接在一起，您可在任何位置添加或删除对象。
* std::forward_list：类似于 std::list，但是单向链表，只能沿一个方向遍历。

STL 提供的 **关联容器** 如下所示。
* std::set：存储各不相同的值，在插入时进行排序；容器的复杂度为对数。
* std::unordered_set：存储各不相同的值，在插入时进行排序；容器的复杂度为常数。这种容器是 C++11 新增的。
* std::map：存储键-值对，并根据唯一的键排序；容器的复杂度为对数。
* std::unordered_map：存储键-值对，并根据唯一的键排序；容器的复杂度为对数。这种容器是C++11 新增的。
* std::multiset：与 set 类似，但允许存储多个值相同的项，即值不需要是唯一的。
* std::unordered_multiset：与 unordered_set 类似，但允许存储多个值相同的项，即值不需要是唯一的。这种容器是 C++11 新增的。
* std::multimap：与 map 类似，但不要求键是唯一的。
* std::unordered_multimap：与 unordered_map 类似，但不要求键是唯一的。这种容器是 C++11新增的。

**容器适配器（Container Adapter）** 是顺序容器和关联容器的变种，其功能有限，用于满足特定的需
求。主要的适配器类如下所示。
* std::stack：以 LIFO（后进先出）的方式存储元素，让您能够在栈顶插入（压入）和删除（弹出）元素。
* std::queue：以 FIFO（先进先出）的方式存储元素，让您能够删除最先插入的元素。
* std::priority_queue：以特定顺序存储元素，因为优先级最高的元素总是位于队列开头。

## 迭代器
在C++中，**迭代器（Iterator）** 是一种通用概念，它提供了一种访问容器（如数组、列表、树等）中元素的方式，而无需暴露容器的底层实现细节。你可以把它想象成一个“智能指针”，它指向容器中的某个元素，并且可以**向前或向后移动**来遍历容器中的所有元素。

迭代器的主要作用就是将算法和容器分离。这样，你可以编写通用的算法（如排序、查找），这些算法可以应用于任何支持迭代器的容器，而不需要为每一种容器类型（如 `std::vector` 或 `std::list`）重复编写相同的代码。

### 迭代器的核心功能

一个典型的迭代器通常会提供以下操作：
* **解引用操作符 (`*`)**：获取迭代器当前指向的元素。
* **自增操作符 (`++`)**：将迭代器移动到下一个元素。
* **相等/不相等比较操作符 (`==`, `!=`)**：判断两个迭代器是否指向同一个位置。
* **自减操作符 (`--`)**：将迭代器移动到上一个元素（仅限部分类型）。

---

### STL 迭代器

**STL (Standard Template Library) 迭代器** 是 C++ 标准库中定义的一组特定的迭代器，它们是STL容器和算法之间的桥梁。

STL迭代器不是一个单一的类，而是一组概念和接口的集合。它们被分为五种主要类型，每种类型都有不同的功能，可以用于不同的场景：

1.  **输入迭代器 (Input Iterator)**
    * **用途：** 只能向前遍历容器一次，用于读取数据。
    * **例子：** 输入流迭代器 (`std::istream_iterator`)。

2.  **输出迭代器 (Output Iterator)**
    * **用途：** 只能向前遍历容器一次，用于写入数据。
    * **例子：** 输出流迭代器 (`std::ostream_iterator`)。

3.  **前向迭代器 (Forward Iterator)**
    * **用途：** 只能向前遍历容器，可以遍历多次。
    * **例子：** `std::forward_list` 的迭代器。

4.  **双向迭代器 (Bidirectional Iterator)**
    * **用途：** 可以向前和向后遍历容器。
    * **例子：** `std::list` 和 `std::set` 的迭代器。

5.  **随机访问迭代器 (Random Access Iterator)**
    * **用途：** 功能最强大，可以像指针一样进行**任意位置的跳转**。支持`+`, `-`, `[]`等操作。
    * **例子：** `std::vector`, `std::string`, `std::deque` 和 C 风格数组的迭代器。

### 为什么 STL 迭代器如此重要？

STL 迭代器的存在使得 STL 算法库非常强大和灵活。例如，`std::sort` 算法要求其参数是**随机访问迭代器**，因为它需要随机访问元素以进行高效的排序。而 `std::find` 算法只需要**输入迭代器**，因为它只需要从头到尾遍历一次即可。

总结来说，**C++ 迭代器**是一个通用的抽象概念，而 **STL 迭代器**是这个概念在 C++ 标准库中的具体实现，它们是连接 STL 容器和算法的通用接口，是 C++ 泛型编程的基石。

## STL算法
查找、排序和反转等都是标准的编程需求，不应让程序员重复实现这样的功能。因此 STL 以 STL
算法的方式提供这些函数，通过结合使用这些函数和迭代器，程序员可对容器执行一些最常见的操作。
最常用的 STL 算法如下所示。
* std::find：在集合中查找值。
* std::find_if：根据用户指定的谓词在集合中查找值。
* std::reverse：反转集合中元素的排列顺序。
* std::remove_if：根据用户定义的谓词将元素从集合中删除。
* std::transform：使用用户定义的变换函数对容器中的元素进行变换。
这些算法都是 std 命名空间中的模板函数，要使用它们，必须包含标准头文件`<algorithm>`。

### 举例从vector中查找元素及其下标
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // 查找元素
    int value_to_find = 30;
    auto it = std::find(vec.begin(), vec.end(), value_to_find);

    if (it != vec.end()) {
        std::cout << "Found value: " << *it << std::endl;
        // 获取下标
        int index = std::distance(vec.begin(), it);
        std::cout << "Index of value: " << index << std::endl;
    } else {
        std::cout << "Value not found." << std::endl;
    }

    return 0;
}
```

### 对比

![](/assets/img/blog/blogs_cpp_container_cmp.png)

## 字符串使用演进
C++中字符串的使用经历了从C风格字符串到C++标准库字符串类的演进，主要包括以下几个阶段：
1. **C风格字符串（C-Style Strings）**：
   * 这是最早的字符串表示方式，使用字符数组和空字符（`'\0'`）来表示字符串的结束。
   * 例如：`char str[] = "Hello, World!";`
   * 缺点：容易出现缓冲区溢出、内存管理复杂、操作不便等问题。
   * 优点：兼容性好，与C语言库函数兼容。

C++支持动态分配内存，使用`new`和`delete`运算符可以在运行时分配和释放内存。

比如使用 `char * dynamicName = new char[arrayLen]` 来定义一个动态分配的字符数组，其中 `arrayLen` 是一个整数，用于指定动态分配的字符数组的长度。

然而，如果要在运行阶段改变数组的长度，必须首先释放以前分
配给它的内存，再重新分配内存来存储数据。

如果将 char*用作类的成员属性，情况将更复杂。将对象赋给另一个对象时，如果编写正确的复制构造函数和赋值运算符，两个对象将包含同一个指针的拷贝，该指针指向相同的缓冲区。其结果是，两个对象的字符串指针存储的地址相同，指向同一个内存单元。其中一个对象被销毁时，另一个对象中的指针将非法，让应用程序面临崩溃的危险。

2. **C++标准库字符串类（std::string）**：
   * 这是C++标准库提供的字符串类，使用起来更加方便和安全。
   * 例如：`std::string str = "Hello, World!";`
   * 优点：自动管理内存、提供丰富的操作方法、支持字符串拼接、比较等。
   * 缺点：与C风格字符串相比，性能较低。

## string实例化和复制
string 类提供了很多重载的构造函数，因此可以多种方式进行实例化和初始化。例如，可使用常量字符串初始化 STL string 对象或将常量字符串赋给 STL std::string 对象：

```cpp
const char* constCStyleString = "Hello String!";
std::string strFromConst (constCStyleString);
```

或：

```cpp
std::string strFromConst = constCStyleString;
// 上述代码与下面的代码类似：
std::string str2 ("Hello String!"); 
```

同样，可使用一个 string 对象来初始化另一个：

```cpp
std::string str2Copy (str2);
```

可让 string 的构造函数只接受输入字符串的前 n 个字符：
```cpp
// Initialize a string to the first 5 characters of another
std::string strPartialCopy (constCStyleString, 5);
```

还可这样初始化 string 对象，即使其包含指定数量的特定字符：

```cpp
// Initialize a string object to contain 10 'a's
std::string strRepeatChars (10, 'a'); 
```

## string元素访问
第一种：使用`[]`运算符

```cpp
std::string str = "Hello, World!";
char ch = str[7]; // ch now holds 'W'
// 遍历
for (size_t i = 0; i < str.size(); ++i) {
    std::cout << str[i] << ' ';
}
```

这种方式来访问string内容时，需要注意的是，访问的下标必须在字符串的有效范围内，否则会导致未定义行为。

第二种：使用迭代器

```cpp
std::string str = "Hello, World!";
// 遍历
for (std::string::iterator it = str.begin(); it != str.end(); ++it) {
    std::cout << *it << ' ';
}
```

这种方式更加灵活，可以方便地进行各种操作，如插入、删除等。迭代器很重要，因为很多 string 成员函数都以迭代器的方式返回其结果。

## 拼接string 
可以使用`+`运算符或`append`方法来拼接字符串。

```cpp
std::string str1 = "Hello, ";
std::string str2 = "World!";
std::string str3 = str1 + str2; // str3 now holds "Hello, World!"
```

```cpp
std::string str1 = "Hello, ";
std::string str2 = "World!";
str1.append(str2); // str1 now holds "Hello, World!"
```

## string中字符和子字符串的查找
可以使用`find`方法来查找字符或子字符串。

```cpp
std::string str = "Hello, World!";
size_t pos = str.find("World"); // pos now holds 7
if (pos != std::string::npos) {
    std::cout << "Found at position: " << pos << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

`find`方法返回子字符串首次出现的位置，如果未找到则返回`std::string::npos`。

> 在C++的 **std::string** 类中， **string::npos** 是一个静态成员常量，它的值是 string::size_type 类型所能表示的最大值。它的主要作用是作为一个 **“未找到”**（"not found"）的标志。当你在使用 std::string 的查找方法（如 find() 或 rfind()）时，如果子字符串或字符没有被找到，这些方法就会返回 string::npos。

如果string中有不止一个的子字符串，`find`方法只会返回第一个子字符串的位置。如果要查找所有子字符串的位置，需要使用循环来实现。

```cpp
std::string str = "Hello, World! World!";
size_t pos = str.find("World");
while (pos != std::string::npos) {
    std::cout << "Found at position: " << pos << std::endl;
    pos = str.find("World", pos + 1);
}
```

## string的截断
如果是获取子字符串，可以使用`substr`方法来截取字符串的一部分。

```cpp
std::string str = "Hello, World!";
std::string subStr = str.substr(7, 5); // subStr now holds "World"
```

如果是直接对原字符串操作，可以使用 `erase()` 方法来删除指定位置的字符或子字符串。

STL string 类提供了 erase()函数，具有以下用途。
* 在给定偏移位置和字符数时删除指定数目的字符。

```cpp
string sampleStr ("Hello String! Wake up to a beautiful day!");
sampleStr.erase (13, 28); // Hello String!
```

* 在给定指向字符的迭代器时删除该字符。

```cpp
sampleStr.erase (iCharS); // iterator points to a specific character
```

* 在给定由两个迭代器指定的范围时删除该范围内的字符。

```cpp
sampleStr.erase (sampleStr.begin (), sampleStr.end ()); // erase from begin
```

例如：

```cpp
std::string str = "Hello, World!";
// 删除从位置 7 开始的 5 个字符
str.erase(7, 5); // str now holds "Hello!"
```

删除某一个字符：

```cpp
std::string str = "Hello, World!";
auto iChar = str.find('W');
if (iChar != std::string::npos) {
    str.erase(iChar, 1); // 删除第一个 'W'
}
std::cout << str << std::endl; // 输出 "Hello, orld!"
```

删除指定迭代器范围内的所有字符：
```cpp
std::string str = "Hello, World!";
auto iStart = str.begin() + 7;
auto iEnd = str.begin() + 12;
str.erase(iStart, iEnd); // str now holds "Hello!"
```

## 字符串反转
有时需要反转字符串的内容。假设要判断用户输入的字符串是否为回文，方法之一是将其反转，再与原来的字符串进行比较。反转 STL string 很容易，只需使用泛型算法 `std::reverse() ` 即可：

```cpp
string sampleStr ("Hello String! We will reverse you!");
reverse (sampleStr.begin (), sampleStr.end ());
```

std::reverse()算法根据两个输入参数指定的边界反转边界内的内容。在这里，两个边界分别是 string 对象的开头和末尾，因此整个字符串都被反转。只要提供合适的输入参数，也可将字符串的一部分反转。注意，边界不能超过 end()。

## 大小写转换
要对字符串进行大小写转换，可使用算法 `std::transform()` 来实现。

下面这个例子，将用户输入的字符串分别进行大写和小写转换：

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>

int main() {
    std::string input;
    std::cout << "Enter a string: ";
    std::getline(std::cin, input);

    // 转换为大写
    std::string upperCaseStr = input;
    std::transform(upperCaseStr.begin(), upperCaseStr.end(), upperCaseStr.begin(),
                   [](unsigned char c) { return std::toupper(c); });

    // 转换为小写
    std::string lowerCaseStr = input;
    std::transform(lowerCaseStr.begin(), lowerCaseStr.end(), lowerCaseStr.begin(),
                   [](unsigned char c) { return std::tolower(c); });

    std::cout << "Uppercase: " << upperCaseStr << std::endl;
    std::cout << "Lowercase: " << lowerCaseStr << std::endl;

    return 0;
}
```

## C++14引入的操作符""s
C++14引入了一个新的操作符`""s`，它可以直接将字符串字面量转换为`std::string`类型。这使得字符串的创建更加简洁和直观。

如果字面量字符串中包含了空字符，需要使用`""s`操作符来创建字符串。

```cpp
#include <iostream>
#include <string>

int main() {
    string str1("Hello \0 World!");
    cout << str1 << endl;
    // 输出：Hello


    string str2("Hello \0 World!"s);
    cout << str2 << endl;
    // 输出：Hello \0 World!

}
```

## vector
vector 是一个模板类，提供了动态数组的通用功能，具有如下特点：
* 在数组末尾添加元素所需的时间是固定的，即在末尾插入元素的所需时间不随数组大小而异，在末尾删除元素也如此；
* 在数组中间添加或删除元素所需的时间与该元素后面的元素个数成正比；
* 存储的元素数是动态的，而 vector 类负责管理内存。

### vector实例化
vector是一个模板类，需要指定元素类型。

```cpp
vector<int> dynamicIntArray;
vector<string> stringArray;
vector<double> doubleArray;
```

声明const迭代器可以这样写：

```cpp
vector<int>::const_iterator iter = dynamicIntArray.begin();
```

如果需要可修改值的迭代器，需要使用`iterator`而不是`const_iterator`。

```cpp
vector<int>::iterator iter = dynamicIntArray.begin();
```

其他实例化方式：

```cpp
// 初始化列表
vector<int> dynamicIntArray = {1, 2, 3, 4, 5};

// 指定大小，默认初始化元素为0
vector<int> dynamicIntArray(5);

// 指定大小，指定初始化元素，内部元素均为50
vector<int> dynamicIntArray(5, 50);

// 通过另一个vector初始化
vector<int> dynamicIntArray2(dynamicIntArray);

// 通过迭代器，使用另一个数组的一部分来初始化
vector<int> dynamicIntArray3(dynamicIntArray.begin(), dynamicIntArray.begin() + 3);
```

### 使用push_back()添加元素 和 pop_back()删除元素
添加元素：

```cpp
vector<int> dynamicIntArray;
dynamicIntArray.push_back(10);
dynamicIntArray.push_back(20);
dynamicIntArray.push_back(30);

// size() 函数返回vector中元素的个数
for (int i = 0; i < dynamicIntArray.size(); i++)
{
    cout << dynamicIntArray[i] << endl;
}
```

使用 `pop_back()` 将元素从 vector 中删除所需的时间是固定的，即不随 vector 存储的元素个数而异。例如：

```cpp
dynamicIntArray.pop_back(); // 删除最后一个元素
// 现在 dynamicIntArray 只包含 10 和 20
```

### 使用insert()指定位置插入元素
有好几个重载版本：

1. 插入指定位置，例如在开头插入一个元素：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
dynamicIntArray.insert(dynamicIntArray.begin(), 5); // 在开头插入5
// 结果： 5 10 20 30
```

2. 指定插入位置，元素数量，元素数值（数值相同）：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
dynamicIntArray.insert(dynamicIntArray.begin() + 1, 2, 15); // 在第二个位置插入两个15
// 结果： 10 15 15 20 30
```

3. 将另一个vector插入指定位置：

```cpp
vector<int> dynamicIntArray1 = {10, 20, 30};
vector<int> dynamicIntArray2 = {40, 50};
dynamicIntArray1.insert(dynamicIntArray1.begin() + 1, dynamicIntArray2.begin(), dynamicIntArray2.end());
// 结果： 10 40 50 20 30
```

### 使用数组语法访问元素
可以使用数组语法来访问 vector 中的元素：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
cout << dynamicIntArray[0] << endl; // 输出 10
cout << dynamicIntArray[1] << endl; // 输出 20
cout << dynamicIntArray[2] << endl; // 输出 30

// 循环
for (int i = 0; i < dynamicIntArray.size(); i++)
{
    cout << dynamicIntArray[i] << endl;
}
```

### 使用at()访问元素
`at()` 方法提供了边界检查，如果访问越界会抛出异常。

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
cout << dynamicIntArray.at(0) << endl; // 输出 10
cout << dynamicIntArray.at(1) << endl; // 输出 20
cout << dynamicIntArray.at(2) << endl; // 输出 30
```

### 使用指针语法访问vector元素
可以使用迭代器以类似指针的方式访问vector元素：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
vector<int>::const_iterator it = dynamicIntArray.begin();

cout << *it << endl; // 输出 10

// 遍历
for (it = dynamicIntArray.begin(); it != dynamicIntArray.end(); it++)
{
    cout << *it << endl;
}

```

这里使用了 `++` 运算符移动位置，使用了 `*` 运算符解引用迭代器。

### vector的大小和容量
`size()` 方法返回 vector 中元素的个数，而 `capacity()` 方法返回 vector 分配的内存大小（即可以容纳的元素个数）。

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
cout << "Size: " << dynamicIntArray.size() << endl; // 输出 3
cout << "Capacity: " << dynamicIntArray.capacity() << endl; // 输出 3 或更大
```

如果 vector 需要频繁地给其内部动态数组重新分配内存，将对性能造成一定的影响。在很大程度上说，这种问题可以通过使用成员函数 `reserve (number)` 来解决。`reserve` 函数的功能基本上是增加分配给内部数组的内存，以免频繁地重新分配内存。通过减少重新分配内存的次数，还可减少复制对象的时间，从而提高性能，这取决于存储在 vector 中的对象类型。

```cpp
vector<int> dynamicIntArray;
dynamicIntArray.reserve(100); // 预留空间以容纳100个元素
dynamicIntArray.push_back(10);
dynamicIntArray.push_back(20);
dynamicIntArray.push_back(30);
cout << "Size: " << dynamicIntArray.size() << endl; // 输出 3
cout << "Capacity: " << dynamicIntArray.capacity() << endl; // 输出 100
```

## deque
deque（double-ended queue）是一个模板类，提供了双端队列的通用功能，除了兼顾 vector 的随机访问能力，还支持在队列的前端进行快速的插入和删除操作。

对比两种结构的底层实现：
### vector和deque实现对比
C++ 的 `std::vector` 和 `std::deque` 都是标准模板库（STL）中的容器，它们在底层使用了不同的数据结构来存储元素，这导致了它们在性能特性上的差异。
### `std::vector`
`std::vector` 的底层实现是一个**动态数组（Dynamic Array）**。它的所有元素都存储在一段连续的内存块中。

* **优点：**
    * **快速随机访问：** 由于内存连续，通过索引访问任何元素的时间复杂度为 $O(1)$，因为它只需要简单的指针算术运算。
    * **缓存友好：** 连续的内存布局使得它在遍历元素时具有很好的 CPU 缓存局部性（cache locality），这通常能带来更好的性能。
* **缺点：**
    * **插入和删除开销大：** 在数组的中间或开头插入或删除元素需要移动其后的所有元素，时间复杂度为 $O(n)$。
    * **扩容开销：** 当动态数组的容量不足时，`vector` 需要分配一块更大的新内存，将所有旧元素复制到新内存中，然后释放旧内存。这个操作的时间复杂度也是 $O(n)$。

### `std::deque`
和 vector 容器采用连续的线性空间不同，deque 容器存储数据的空间是由一段一段等长的连续空间构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。

为了管理这些连续空间，deque 容器用数组（数组名假设为 map）存储着各个连续空间的首地址。

也就是说，map 数组中存储的都是指针，指向那些真正用来存储数据的各个连续空间。

![](/assets/img/blog/blogs_dequeue_mem_model.png)

通过建立 map 数组，deque 容器申请的这些分段的连续空间就能实现“整体连续”的效果。

换句话说，当 deque 容器需要在头部或尾部增加存储空间时，它会申请一段新的连续空间，同时在 map 数组的开头或结尾添加指向该空间的指针，由此该空间就串接到了 deque 容器的头部或尾部。

有读者可能会问，如果 map 数组满了怎么办？很简单，再申请一块更大的连续空间供 map 数组使用，将原有数据（很多指针）拷贝到新的 map 数组中，然后释放旧的空间。

deque 容器的分段存储结构，提高了在序列两端添加或删除元素的效率，但也使该容器迭代器的底层实现变得更复杂。

### 使用push_front()和push_back()

```cpp
#include <iostream>
#include <deque>
using namespace std;

int main() {
    deque<int> myDeque;

    // 在队列末尾添加元素
    myDeque.push_back(10);
    myDeque.push_back(20);
    myDeque.push_back(30);

    // 在队列前端添加元素
    myDeque.push_front(5);
    myDeque.push_front(1);

    // 当前deque内容: 1 5 10 20 30

    // 删除队列末尾的元素
    myDeque.pop_back();

    // 删除队列前端的元素
    myDeque.pop_front();

    // 修改后的deque内容: 5 10 20

    return 0;
}
```

### 两种遍历方式

```cpp
#include <iostream>
#include <deque>
using namespace std;

int main() {
    deque<int> myDeque = {10, 20, 30, 40, 50};

    // 使用索引遍历
    cout << "Using index:" << endl;
    for (size_t i = 0; i < myDeque.size(); ++i) {
        cout << myDeque[i] << " ";
    }
    cout << endl;

    // 使用迭代器遍历
    cout << "Using iterator:" << endl;
    for (deque<int>::iterator it = myDeque.begin(); it != myDeque.end(); ++it) {
        // 使用distance计算偏移位置
        size_t offset = distance(myDeque.begin(), it);
        cout << "Offset: " << offset << ", Value: " << *it << " ";
    }
    cout << endl;

    return 0;
}
```

> size_t 是无符号整数类型，用于表示对象的大小或索引。

### 清空vector和deque
可以使用 `clear()` 方法清空vector和deque，可以使用 `empty()` 来判断容器是否为空的。

```cpp
#include <iostream>
#include <vector>
#include <deque>

using namespace std;

int main() {
    vector<int> myVector = {1, 2, 3, 4, 5};
    deque<int> myDeque = {10, 20, 30, 40, 50};

    // 清空vector
    myVector.clear();
    if (myVector.empty()) {
        cout << "Vector is empty." << endl;
    } else {
        cout << "Vector is not empty." << endl;
    }

    // 清空deque
    myDeque.clear();
    if (myDeque.empty()) {
        cout << "Deque is empty." << endl;
    } else {
        cout << "Deque is not empty." << endl;
    }

    return 0;
}
```

| 应该                                             | 不应该                                           |
|--------------------------------------------------|--------------------------------------------------|
| 在不知道需要存储多少个元素时，务必使用动态数组 vector 或 deque。 | 使用固定大小的数组，可能会浪费内存或导致溢出。               |
| 请牢记，vector 只能在一端扩容，为此可使用函数 push_back( )。 | 试图在 vector 的前端插入元素，可能导致性能问题。               |
| 请牢记，deque 可在两端扩容，为此可使用函数 push_back( )和 push_front( )。 | 忘记 deque 的双端特性，导致不必要的复杂操作。                   |
| 访问动态数组时，不要跨越其边界。                             | 使用索引访问时不检查边界，可能导致未定义行为。                   |
| 使用迭代器遍历容器，确保代码的通用性和安全性。                   | 直接使用指针操作容器，可能导致错误和不安全的代码。               |

别忘了，函数 `pop_back()` 删除集合中的最后一个元素。函数 `pop_front()` 删除 deque 的第一个元素。

## std::list
`std::list` 在C++中是一个双向链表（doubly linked list），它的核心实现依赖于节点（node）和指针（pointer）。

![](/assets/img/blog/blogs_stdlist_linkedlist.png)

`std::list` 通常使用一个 **虚拟的头节点（sentinel node）** 来简化操作。这个节点不存储任何实际数据，它的作用是：
* next指针永远指向链表的第一个真实节点。
* prev指针永远指向链表的最后一个真实节点。
* 当链表为空时，这个虚拟头节点的next和prev都指向它自己。

使用虚拟头节点的好处是，无论是插入、删除还是遍历，你都不需要对链表为空或在头尾进行特殊判断，所有操作都可以用统一的方式处理，这大大简化了代码逻辑。

要实例化模板 list，需要指定要在其中存储的对象类型，因此实例化 list 的语法类似于下面这样：

```cpp
std::list<int> linkInts; // list containing integers
std::list<float> listFloats; // list containing floats
std::list<Tuna> listTunas; // list containing objects of type Tuna 
```

要声明一个指向 list 中元素的迭代器，可以像下面这样做：

```cpp
std::list<int>::const_iterator elementInList;
```

如果需要一个这样的迭代器，即可以使用它来修改值或调用非 const 函数，可将 const_iterator 替换为 iterator。

### list实例化方式

```cpp
#include <iostream>
#include <list>
using namespace std;
int main() {
    // 使用初始化列表
    list<int> myList = {1, 2, 3, 4, 5};

    // 使用默认构造函数
    list<string> stringList;

    // 使用指定大小和初始值
    list<double> doubleList(5, 3.14); // 包含5个3.14

    // 使用另一个list初始化
    list<int> anotherList(myList);

    // 使用vector的元素来实例化一个list
    vector<int> vec = {10, 20, 30, 40, 50};
    list<int> listFromVec(vec.cbegin(), vec.cend());

    return 0;
}
```

> `begin()` 返回一个普通的可读写迭代器 (iterator)。这意味着你可以通过这个迭代器来读取或修改容器中的元素。 `cbegin()` 返回一个常量迭代器 (const_iterator)。这个迭代器只能用来读取容器中的元素，但不能修改它们。end同理。

您首先实例化了一个 vector，接下来，实例化了一个 list，它包含从 vector 复制而来的元素，这是使用 C++11 新增的 vector::cbegin()和 vector::cend()返回的 const 迭代器复制的。该程序清单表明，迭代器让容器的实现彼此独立，其通用功能让您能够使用 vector 中的值实例化 list。

### list的开头和末尾插入元素
可以使用 `push_front()` 方法在 list 的开头插入元素，使用 `push_back()` 方法在 list 的末尾插入元素。

```cpp
#include <iostream>
#include <list>
using namespace std;
int main() {
    list<int> myList;

    // 在开头插入元素
    myList.push_front(10);
    myList.push_front(20);

    // 在末尾插入元素
    myList.push_back(30);
    myList.push_back(40);

    // 输出列表内容
    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    return 0;
}
```

### list中间插入元素
可以使用 `insert()` 方法在 list 的中间插入元素。

成员函数 list::insert()有 3 种版本。
* 第 1 种版本：

```cpp
iterator insert(iterator pos, const T& x)
```

在这里，insert 函数接受的第 1 个参数是插入位置，第 2 个参数是要插入的值。该函数返回一个迭代器，它指向刚插入到 list 中的元素。

* 第 2 种版本：

```cpp
void insert(iterator pos, size_type n, const T& x)
```

该函数的第 1 个参数是插入位置，最后一个参数是要插入的值，而第 2 个参数是要插入的元素个数。

* 第 3 种版本：

```cpp
template <class InputIterator>
void insert(iterator pos, InputIterator f, InputIterator l)
```

该重载版本是一个模板函数，除一个位置参数外，它还接受两个输入迭代器，指定要将集合中相应范围内的元素插入到 list 中。注意，输入类型 InputIterator 是一种模板参数化类型，因此可指定任何集合（数组、vector 或另一个 list）的边界。

```cpp
#include <iostream>
#include <list>
using namespace std;
int main() {
    list<int> myList = {10, 20, 30, 40};

    // 在第二个位置插入元素
    auto it = myList.begin();
    advance(it, 1); // 移动到第二个位置
    myList.insert(it, 15); // 在第二个位置插入15

    // 此时的列表内容 10 15 20 30 40

    // 在第二个位置插入多个元素
    it = myList.begin();
    advance(it, 1); // 移动到第二个位置
    myList.insert(it, 2, 25); // 在第二个位置插入2个25

    // 此时的列表内容 10 15 25 25 20 30 40

    // 在第二个位置插入数组元素
    int arr[] = {35, 45};
    it = myList.begin();
    advance(it, 1); // 移动到第二个位置
    myList.insert(it, arr, arr + 2); // 在第二个位置插入数组元素

    // 此时的列表内容 10 15 25 25 35 45 20 30 40

    return 0;
}
```

### list删除元素
erase() 方法用于删除 list 中的元素。有两个重载版本：
* 接受一个迭代器参数，删除指定位置的元素；
* 接受两个迭代器参数，删除指定范围内的元素。

```cpp
#include <iostream>
#include <list>
using namespace std;
int main() {
    list<int> myList = {10, 20, 30, 40, 50};

    // 删除第二个元素
    auto it = myList.begin();
    advance(it, 1); // 移动到第二个位置
    myList.erase(it); // 删除第二个元素

    // 此时的列表内容 10 30 40 50

    // 删除第二个元素到第四个元素
    it = myList.begin();
    advance(it, 1); // 移动到第二个位置
    auto endIt = myList.begin();
    advance(endIt, 3); // 移动到第四个位置
    myList.erase(it, endIt); // 删除第二个元素到第四个元素

    // 此时的列表内容: 10 50

    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    return 0;
}
```

需要注意的是， `list::erase(first, last)` 删除的是 `[first, last)` 范围内的元素，即包含 first 指向的元素，但不包含 last 指向的元素。这也是为什么第二次删除会移除 30 和 40，而保留 50（在执行第二次删除前的列表中）。因为尾迭代器 endIt 指向的为50这个元素。

> 区分于it.end() ，it.end() 指向的其实是最后一个元素的下一个位置，所以使用it.end()来删除元素时，会删除到最后一个元素。

### list元素反转
可以使用 `reverse()` 方法来反转 list 中的元素。

```cpp
#include <iostream>
#include <list>
using namespace std;
int main() {
    list<int> myList = {10, 20, 30, 40, 50};

    // 反转列表元素
    myList.reverse();

    // 输出列表内容
    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    return 0;
}
```

### list进行排序
可以使用 `sort()` 方法对 list 中的元素进行排序。
有两个重载方法：
* 单独一个sort()方法，默认以升序排序
* 接受一个比较函数作为参数，以指定的标准排序

```cpp
#include <iostream>
#include <list>
using namespace std;

bool SortPredicate_Descending(const int& a, const int& b) {
    return a > b; // 降序排序
}

int main() {
    list<int> myList = {40, 10, 30, 20, 50};

    // 默认升序排序
    myList.sort();

    cout << "Sorted in ascending order: ";
    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    // 降序排序
    myList.sort(SortPredicate_Descending);

    cout << "Sorted in descending order: ";
    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    return 0;
}
```

定义了函数 `SortPredicate_Descending` ，它是一个二元谓词，帮助 list 的 `sort()` 函数判断一个元素是否比另一个元素小。如果不是，则交换这两个元素的位置。换句话说，您告诉了 list 如何解释小于，就这里而言，小于的含义是第一个参数大于第二个参数。这个谓词仅在第一个值比第二个值大时返回 true。也就是说，使用该谓词时，仅当第一个元素（lsh）的数字值比第二个元素（rsh）大时，sort()才认为第一个元素比第二个元素小。基于这种解释，sort()交换元素的位置，以满足谓词指定的标准。

### 包含对象的list进行排序
实际使用中，很少使用list来存储int等简单内置类型，而是存储自定义的类型，这是如何排序呢？

答案是采取下面两种方式之一：
* 在 list 包含的对象所属的类中，实现运算符<；
* 提供一个排序二元谓词—一个这样的函数，即接受两个输入值，并返回一个布尔值，指出第一个值是否比第二个值小。

```cpp
#include <iostream>
#include <list>
#include <string>

using namespace std;


class Tuna {
    int age;
    string name;
public:
    Tuna(int age, string name) {
        this->age = age;
        this->name = name;
    }
    int getAge() const {
        return age;
    }
    string getName() const {
        return name;
    }
    // 实现<操作符函数，实现按照名称name的长度升序排序
    bool operator<(const Tuna& other) const {
        return name.size() < other.name.size();
    }
};

bool SortPredicate_Age(const Tuna& a, const Tuna& b) {
    return a.getAge() < b.getAge(); // 按年龄升序排序
}

int main() {
    list<Tuna> tunaList;
    tunaList.push_back(Tuna(1, "Tunadfbdbn1"));
    tunaList.push_back(Tuna(2, "Tunafbdfbdbfsddvw2"));
    tunaList.push_back(Tuna(3, "Tuna3"));

    // 按年龄排序
    tunaList.sort(SortPredicate_Age);

    cout << "Sorted Tuna List by Age:" << endl;
    for (const auto& tuna : tunaList) {
        cout << "Name: " << tuna.getName() << ", Age: " << tuna.getAge() << endl;
    }

    tunaList.sort();
    cout << "Sorted Tuna List by < oprator:" << endl;
    for (const auto& tuna : tunaList) {
        cout << "Name: " << tuna.getName() << ", Age: " << tuna.getAge() << endl;
    }

    return 0;
}
```

### 包含对象的list进行删除
这时候需要使用list的 `remove()` 方法，但是需要注意的是，需要给 `remove()` 方法指定标准。在类中实现 `==` 比较运算符。

```cpp
#include <iostream>
#include <list>
#include <string>
using namespace std;

class Human {
    string name;
    int age;
public:
    Human(string name, int age) {
        this->name = name;
        this->age = age;
    }
    string getName() const {
        return name;
    }
    int getAge() const {
        return age;
    }
    bool operator==(const Human& other) {
        return name == other.name;
    }
};

int main() {
    list<Human> humanList;
    humanList.push_back(Human("张三", 18));
    humanList.push_back(Human("李四", 20));
    humanList.push_back(Human("王五", 22));

    for (const auto& human : humanList) {
        cout << "Name: " << human.getName() << ", Age: " << human.getAge() << endl;
    }

    humanList.remove(Human("李四", 20));

    cout << "=======> After remove: 李四 <==========" << endl;
    for (const auto& human : humanList) {
        cout << "Name: " << human.getName() << ", Age: " << human.getAge() << endl;
    }

    return 0;
}
```

实现的 Human::operator==将该对象与 list 中的元素进行比较。该运算符在姓名相同时返回 true，向 list::remove( )指出了匹配标准。

### std::forward_list 
`std::forward_list` 是 C++11 引入的一个单向链表容器，提供了类似于 `std::list` 的功能，但只支持单向遍历。它的底层实现依赖于节点（node）和指针（pointer）。

![](/assets/img/blog/blogs_stdlist_forward_list.png)

forward_list 的用法与 list 很像，但只能沿一个方向移动迭代器，且插入元素时只能使用函数 `push_front()`，而不能使用 `push_back()`。当然，总是可以使用 `insert()` 及其重载版本在指定位置插入元素。

下列代码演示了 forward_list 的实例化，添加元素和单向遍历：

```cpp
#include <iostream>
#include <forward_list>
using namespace std;
int main() {
    forward_list<int> myList;
    myList.push_front(1);
    myList.push_front(2);
    myList.push_front(3);
    // 现在 myList 包含 3, 2, 1
    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    auto it = myList.begin();
    myList.insert_after(it, 4);
    // 现在 myList 包含 3, 4, 2, 1
    for (auto singleIt = myList.begin(); singleIt != myList.end(); singleIt++) {
        cout << *singleIt << " ";
    }
    cout << endl;

    return 0;
}
```

> 鉴于 forward_list 不支持双向迭代，因此只能对迭代器使用运算符++，而不能使用--。

列表总结：

* 如果需要频繁地插入或删除元素（尤其是在中间插入或删除时），应使用 std::list，而不是 std::vetor。因为在这种情况下，vector 需要调整其内部缓冲区的大小，以支持数组语法，还需执行开销高昂的复制操作，而 list 只需建立或断开链接。

* 请记住，可使用成员方法 `push_front()` 和 `push_back()` 分别在 list 开头和末尾插入元素。

* 对于要使用 list 等 STL 容器存储其对象的类，别忘了在其中实现运算符<和==，以提供默认的排序和删除谓词。

* 请记住，像其他 STL 容器类一样，总是可以使用 `list::size()` 来确定 list 包含多少个元素。

* 请记住，像其他 STL 容器类一样，可使用方法 `list::clear()` 清空 list。

* 无需频繁在两端插入或删除元素，且不用在中间插入或删除元素时，请不要使用 list；在这些情况下，vector 和 deque 的速度要快得多。

* 如果不想根据默认标准进行删除或排序，别忘了给 `sort()` 和 `remove()` 提供一个谓词函数。

## std::set和std::multiset
set 是 C++ 标准库中的一个关联容器，用于存储唯一的元素，自动排序。它基于红黑树实现，提供了快速的插入、删除和查找操作。

multiset 是 set 的一个变体，允许存储重复的元素。

set 的常用方法包括：

* `insert()`：插入元素。
* `erase()`：删除元素。
* `find()`：查找元素。
* `size()`：返回元素数量。
* `empty()`：检查是否为空。
* `clear()`：清空容器。

multiset 的常用方法与 set 类似，只是允许存储重复元素。

为了实现快速搜索，STL set 和 multiset 的内部结构像二叉树，这意味着将元素插入到 set 或 multiset时将对其进行排序，以提高查找速度。这还意味着不像 vector 那样可以使用其他元素替换给定位置的元素，位于 set 中特定位置的元素不能替换为值不同的新元素，这是因为 set 将把新元素同内部树中的其他元素进行比较，进而将其放在其他位置。

### set和multiset的实例化
可以使用以下方式实例化：
```cpp
set<int> mySet;
multiset<int> myMultiset;

set<Tuna> myTunaSet;
multiset<Tuna> myTunaMultiset;
```

鉴于 set 和 multiset 都是在插入时对元素进行排序的容器，如果您没有指定排序标准，它们将使用默认谓词 std::less，确保包含的元素按升序排列。

要创建二元排序谓词，可在类中定义一个 `operator()`，让它接受两个参数（其类型与集合存储的数据类型相同），并根据排序标准返回 true。下面是一个这样的排序谓词，它按降序排列元素：

```cpp
// used as a template parameter in set / multiset instantiation
template <typename T>
struct SortDescending
{
 bool operator()(const T& lhs, const T& rhs) const
 {
     return (lhs > rhs);
 }
};
```

然后，在实例化 set 或 multiset 时指定该谓词，如下所示：

```cpp
// a set and multiset of integers (using sort predicate)
set <int, SortDescending<int>> setInts;
multiset <int, SortDescending<int>> msetInts; 
```

也可以使用迭代器来通过另一个容器的元素来初始化 set 或 multiset，如下所示：

```cpp
#include <iostream>
#include <set>
#include <vector>
using namespace std;

int main(){
    vector<int> vec = {1, 2, 3, 4, 5};
    set<int> setInts(vec.cbegin(), vec.cend());
    for (auto it = setInts.begin(); it != setInts.end(); it++) {
        cout << *it << " ";
    }
    cout << endl;
    return 0;
}
```

### set和multiset的插入元素
```cpp
#include <iostream>
#include <set>
#include <vector>
using namespace std;

template <typename T>
void DisplayContents(const T& container)
{
    for (auto element = container.cbegin(); element !=container.cend(); element++)
    {
        cout << *element << " ";
    }
    cout << endl;
}

int main(){
    // 使用 insert() 方法插入单个元素
    set<int> setInts;
    setInts.insert(1);
    setInts.insert(2);
    setInts.insert(3);
    DisplayContents(setInts);

    cout << endl;

    // 使用 insert() 方法插入多个元素
    cout << "======>use another insert to add item<======" << endl;
    vector<int> vec = {4, 5, 6};
    set<int> setInts2;
    setInts2.insert(vec.cbegin(), vec.cend());
    DisplayContents(setInts2);
    cout << endl;

    return 0;
}
```

> DisplayContents这个模板方法，用来打印一个容器里的内容。它接受一个容器作为参数，使用迭代器遍历容器中的元素，并打印每个元素。

### multiset中计算一个元素的数量有多少
使用 `count()` 函数可以计算 multiset 中特定元素的数量。

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    multiset<int> myMultiset = {1, 2, 2, 2, 3, 4, 5};

    // 计算元素3的数量
    int count = myMultiset.count(2);
    cout << "Count of 2 in set: " << count << endl;   // 输出 3
    // 尝试计算一个不存在的元素
    count = myMultiset.count(6);
    cout << "Count of 6 in set: " << count << endl;  // 输出 0

    return 0;
}
```

### set、multiset、map、multimap中查找元素
诸如 set、multiset、map 和 multimap 等关联容器都提供了成员函数 find( )，它让您能够根据给定的键来查找值：

```cpp
auto elementFound = setInts.find (-1);
// Check if found...
if (elementFound != setInts.end ())
 cout << "Element " << *elementFound << " found!" << endl;
else
 cout << "Element not found in set!" << endl; 
```

multiset 可包含多个值相同的元素，因此对于 multiset，这个函数查找第一个与给定键匹配的元素。

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    multiset<int> myMultiset = {1, 2, 2,3, 4, 2, 5};

    // 查找元素2
    auto it = myMultiset.find(2);
    if (it != myMultiset.end()) {
        cout << "Found element: " << *it << endl; // 输出 2
    } else {
        cout << "Element not found." << endl;
    }

    // 继续查找下一个元素2
    int count = myMultiset.count(2);
    for (int i = 0; i < count - 1; i++) {
        it++;
        cout << "Found another qualified element: " << *it << endl; // 输出 2
    }

    return 0;
}
```

鉴于 multiset 可能在 **相邻的位置** 存储多个值相同的元素，为了访问所有这些元素，可使用 find()返回的迭代器，并将迭代器前移 count()-1 次。

### set、multiset、map、multimap中删除元素
诸如 set、multiset、map 和 multimap 等关联容器都提供了成员函数 `erase()` ，它让您能够根据键删除值：

```cpp
setObject.erase (key);
```

erase()函数的另一个版本接受一个迭代器作为参数，并删除该迭代器指向的元素：

```cpp
setObject.erase (element);
```

通过使用迭代器指定的边界，可将指定范围内的所有元素都从 set 或 multiset 中删除：

```cpp
setObject.erase (iLowerBound, iUpperBound); 
```

```cpp
#include <iostream>
#include <set>
using namespace std;

template <typename T>
void DisplayContents(const T& container)
{
    for (auto element = container.cbegin(); element !=container.cend(); element++)
    {
        cout << *element << " ";
    }
    cout << endl;
}

int main() {
    multiset<int> myMultiset = {1, 2, 2, 3, 4, 2, 5};

    // 删除元素2
    myMultiset.erase(2);

    // 输出删除后的内容
    cout << "After erasing 2: ";
    DisplayContents(myMultiset);

    // 删除一个不存在的元素（不会报错）
    myMultiset.erase(6); // 不存在的元素

    auto it = myMultiset.find(3);
    myMultiset.erase(it);

    // 输出删除后的内容
    cout << "After erasing 3: ";
    DisplayContents(myMultiset);

    return 0;
}
```

### 使用set实现的简要电话薄
```cpp
#include <iostream>
#include <set>
#include <string>
using namespace std;

template <typename T>
void DisplayContents(const T& container)
{
    for (auto element = container.cbegin(); element !=container.cend(); element++)
    {
        cout << *element << " ";
    }
    cout << endl;
}

struct ContactItem {
    string name;
    string phone;
    string displayAs;

    ContactItem(string n, string p) : name(n), phone(p) {
        displayAs = name + "(" + phone + ")";
    }

    bool operator<(const ContactItem& other) const {
        return name < other.name;
    }

    bool operator==(const ContactItem& other) const {
        return name == other.name;
    }

    // Used in DisplayContents via cout
    operator const char*() const{
        return displayAs.c_str();
    }
};

int main () {
    set<ContactItem> setContacts;
    setContacts.insert(ContactItem("张三", "123456"));
    setContacts.insert(ContactItem("李四", "654321"));
    setContacts.insert(ContactItem("王五", "112233"));
    DisplayContents(setContacts);

    cout << "Enter a name you wish to delete: ";
    string nameToDelete;
    getline(cin, nameToDelete);
    
    auto contactFound = setContacts.find(ContactItem(nameToDelete, ""));
    if (contactFound != setContacts.end()) {
        setContacts.erase(contactFound);
        cout << "Contact deleted." << endl;
    } else {
        cout << "Contact not found." << endl;
    }

    DisplayContents(setContacts);
    return 0;
}
```

## unordered_set和unordered_multiset
底层实现
* set: 底层基于红黑树 (Red-Black Tree) 实现。红黑树是一种自平衡二叉查找树，它能保证插入、删除和查找操作的时间复杂度为 O(logN)。

* unordered_set: 底层基于哈希表 (Hash Table) 实现。它使用哈希函数将元素映射到哈希表的桶 (bucket) 中，通过哈希冲突处理机制来解决多个元素映射到同一个桶的情况。

元素存储顺序
* set: 元素是有序存储的。它会根据元素的键值进行排序（默认是升序）。当你遍历 set 中的元素时，你会得到一个有序的序列。

* unordered_set: 元素是无序存储的。元素的存储位置由其哈希值决定，因此遍历 unordered_set 得到的元素顺序是不确定的。

性能
* set:
    * 平均时间复杂度: 插入、删除、查找操作的时间复杂度都是 O(logN)。
    * 最坏时间复杂度: 也是 O(logN)，因为红黑树是自平衡的。

* unordered_set:
    * 平均时间复杂度: 插入、删除、查找操作的时间复杂度都是 O(1)。
    * 最坏时间复杂度: 在哈希冲突严重的情况下，所有元素都映射到同一个桶，哈希表会退化成链表，此时操作的时间复杂度会降为 O(N)。不过这种情况非常罕见，通常可以通过选择好的哈希函数和管理哈希表大小来避免。

使用 std::unordered_set 及其方法 insert( )、find( )、size( )、max_bucket_count( )、load_factor( )和 max_load_factor( ) 

```cpp
#include <iostream>
#include <unordered_set>
using namespace std;

int main() {
    unordered_set<int> mySet;

    // 插入元素
    mySet.insert(10);
    mySet.insert(20);
    mySet.insert(30);

    // 查找元素
    auto it = mySet.find(20);
    if (it != mySet.end()) {
        cout << "Element found: " << *it << endl;
    } else {
        cout << "Element not found." << endl;
    }

    // 元素数量
    cout << "Size: " << mySet.size() << endl;

    // 最大桶数量
    cout << "Max bucket count: " << mySet.max_bucket_count() << endl;

    // 负载因子
    cout << "Load factor: " << mySet.load_factor() << endl;

    // 最大负载因子
    cout << "Max load factor: " << mySet.max_load_factor() << endl;

    return 0;
}
```

程序方法解释：

---

`unordered_set` 和 `unordered_map` 的哈希表性能在很大程度上取决于其内部管理机制，`max_bucket_count`、`load_factor` 和 `max_load_factor` 就是其中几个关键参数。

### 1. `max_bucket_count`

* **作用**：表示**容器所能容纳的最大桶（bucket）数量**。
* **解释**：这是一个只读成员函数，用于获取哈希表当前能支持的最大桶数。这个值通常由 C++ 标准库实现决定，并不会轻易改变。它代表了容器容量的一个上限，保证哈希表不会无限膨胀。当容器需要重新哈希（rehash）时，它会选择一个新的桶数，但这个新桶数不会超过 `max_bucket_count`。

### 2. `load_factor`

* **作用**：衡量哈希表的**拥挤程度**。
* **计算方式**：`load_factor = 元素数量（size） / 桶数量（bucket_count）`
* **解释**：`load_factor` 是一个动态变化的指标。它告诉你平均每个桶里有多少个元素。
    * **低 `load_factor`**：哈希表很稀疏，冲突少，查询速度快，但会占用更多内存。
    * **高 `load_factor`**：哈希表很拥挤，冲突多，查询速度变慢，但内存利用率高。

### 3. `max_load_factor`

* **作用**：**控制哈希表自动重新哈希的阈值**。
* **解释**：这是一个可读写的参数，可以由你手动设置。当哈希表的 `load_factor` **超过** `max_load_factor` 时，容器会自动进行**重新哈希（rehash）**操作。
* **重新哈希**：这是一种代价较高的操作。容器会创建一个新的、更大的哈希表（通常桶数量是之前的两倍），然后把旧哈希表中的所有元素重新插入到新哈希表中。这个过程会消耗较多时间和计算资源。

---

### 三者关系及实际应用

这三个参数共同协作来平衡 `unordered_set` 的性能和内存使用：

1.  你通过 **`max_load_factor`** 设定一个“拥挤”的上限。
2.  容器在插入新元素时，会实时计算 **`load_factor`**。
3.  一旦 `load_factor` 超过你设定的 `max_load_factor`，容器就会触发重新哈希。
4.  重新哈希时，容器会增加桶的数量 (`bucket_count`)，从而降低 `load_factor`，使其重新回到 `max_load_factor` 以下。新的桶数不会超过 **`max_bucket_count`**。

对于 Android 开发者来说，如果你在 C++ 项目中使用了 `unordered_set` 或 `unordered_map`，并遇到了性能瓶颈，通常可以通过**手动调整 `max_load_factor`** 来优化。如果你的数据量是已知的，或者对性能要求极高，你可以在容器初始化时使用 `reserve()` 函数预留足够的空间，避免频繁的重新哈希，这比动态调整 `max_load_factor` 更高效。


* 请牢记，STL set 和 multiset 容器针对频繁查找
的情形进行了优化。
* 请牢记，std::multiset 可存储多个值相同的元素
（键），而 std::set 只能存储不同的值。
* 务必使用 multiset::count(value)确定有多少个元
素包含特定的值。
* 请牢记，set::size( )和 multiset::size( )指出容器包
含多少个元素。
* 对于其对象将存储在 set 或 multiset 等容器中的类，别忘了在其中实现运算符<和==。前者将成为排序谓词，而后者将用于 set::find( )等函数。
* 在需要频繁插入而很少查找的情形下，不要使用 std::set 或 std::multiset；在这种情形下，std::vector和 std::list 通常更适合。

## STL map和multimap
map 和 multimap 之间的区别在于，后者能够存储重复的键，而前者只能存储唯一的键。

为了实现快速查找，STL map 和 multimap 的内部结构看起来像棵二叉树。这意味着在 map 或 multimap 中插入元素时将进行排序。

![](/assets/img/blog/blogs_map_cpp.png)

### map的实例化
典型的 map 实例化语法如下：

```cpp
#include <map>
using namespace std;
...
map <keyType, valueType, Predicate=std::less <keyType>> mapObj;
multimap <keyType, valueType, Predicate=std::less <keyType>> mmapObj;
```

第三个模板参数是可选的。如果您值指定了键和值的类型，而省略了第三个模板参数，`std::map` 和 `std::multimap` 将把 `std::less<>` 用作排序标准。

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    map<int, string> myMap;
    myMap[1] = "one";
    myMap[2] = "two";
    myMap[3] = "three";

    for (auto it = myMap.begin(); it != myMap.end(); ++it) {
        cout << it->first << " => " << it->second << endl;
    }
    return 0;
}
```

### map中插入元素
可以使用 `insert()` 方法插入元素，例如：

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    map<int, string> myMap;
    myMap.insert(pair<int, string>(1, "one"));
    myMap.insert(pair<int, string>(2, "two"));
    myMap.insert(pair<int, string>(3, "three"));

    for (auto it = myMap.begin(); it != myMap.end(); ++it) {
        cout << it->first << " => " << it->second << endl;
    }
    return 0;
}
```

也可以采用数组方式添加元素，例如：

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    map<int, string> myMap;
    myMap[1] = "one";
    myMap[2] = "two";
    myMap[3] = "three";

    for (auto it = myMap.begin(); it != myMap.end(); ++it) {
        cout << it->first << " => " << it->second << endl;
    }
    return 0;
}
```

类似于multiset，multimap中也可以使用 `multimap::count()` 指出有多少个元素包含指定的键。

### map使用find()查找元素
find()函数总是返回一个迭代器。首先检查该迭代器，确保 find( )已成功，再使用它来访问找到的值。

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    map<int, string> myMap;
    myMap[1] = "one";
    myMap[2] = "two";
    myMap[3] = "three";

    map<int, string>::iterator it = myMap.find(2);
    if (it != myMap.end()) {
        cout << "Found: " << it->first << " => " << it->second << endl;
    } else {
        cout << "Not found" << endl;
    }
    return 0;
}
```

如果使用的是 multimap，容器可能包含多个键相同的键-值对，因此需要找到与指定键对应的所有值。为此，可使用 `multimap::count( )` 确定有多少个值与指定的键对应，再对迭代器递增，以访问这些相邻的值：

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    multimap<int, string> myMap;
    myMap.insert(pair<int, string>(1, "one"));
    myMap.insert(pair<int, string>(2, "two"));
    myMap.insert(pair<int, string>(2, "two2"));
    myMap.insert(pair<int, string>(3, "three"));

    // 查找键为2的元素
    multimap<int, string>::iterator it = myMap.find(2);
    if (it != myMap.end()) {
        cout << "Found: " << it->first << " => " << it->second << endl;
    } else {
        cout << "Not found" << endl;
    }
    // 查找键为2的元素的数量
    int count = myMap.count(2);
    cout << "Count: " << count << endl;
    for (int i = 0; i < count; i++) {
        cout << "Found Again: " << it->first << " => " << it->second << endl;
        it++;
    }
    return 0;
}
```

### 使用erase()删除元素
类似于set，multimap也可以使用erase()删除元素。并且都是有三种类似的重载函数。

直接接收元素，接收迭代器，接收两个迭代器中间的范围：

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    multimap<int, string> myMap;
    myMap.insert(pair<int, string>(1, "one"));
    myMap.insert(pair<int, string>(2, "two"));
    myMap.insert(pair<int, string>(2, "two2"));
    myMap.insert(pair<int, string>(3, "three"));

    // 删除键为2的元素
    myMap.erase(2);

    for (auto it = myMap.begin(); it != myMap.end(); ++it) {
        cout << it->first << " => " << it->second << endl;
    }

    auto it3 = myMap.find(3);
    // 删除迭代器指向的元素
    myMap.erase(it3);

    cout << "======>erase 3<========" << endl;

    for (auto it = myMap.begin(); it != myMap.end(); ++it) {
        cout << it->first << " => " << it->second << endl;
    }

    // 删除迭代器范围指向的元素
    myMap.erase(myMap.begin(), myMap.end());

    cout << "======>erase all<========" << endl;

    for (auto it = myMap.begin(); it != myMap.end(); ++it) {
        cout << it->first << " => " << it->second << endl;
    }

    return 0;
}
```

### map编写排序谓词
要提供不同的排序标准，可编写一个二元谓词—实现了 `operator()` 的类或结构：

```cpp
template<typename keyType>
struct Predicate
{
 bool operator()(const keyType& key1, const keyType& key2)
 {
 // your sort priority logic here
 }
};
```

例如一个电话薄场景，要求姓名 `string` 来对比的时候，不区分大小写，那么就可以编写一个谓词来实现：
```cpp
#include <iostream>
#include <map>
#include <string>
#include<algorithm> 
using namespace std;

struct PredIgnoreCase
{
    bool operator()(const string& s1, const string& s2) const
    {
        string s1Lower = s1;
        string s2Lower = s2;
        transform(s1Lower.begin(), s1Lower.end(), s1Lower.begin(), ::tolower);
        transform(s2Lower.begin(), s2Lower.end(), s2Lower.begin(), ::tolower);
        return s1Lower < s2Lower;
    }
};

int main() {
    map<string, string> contactMap;
    contactMap["John"] = "123456";
    contactMap["jane"] = "789012";
    contactMap["alice"] = "345678";
    contactMap["Amy"] = "124525";

    for (auto it = contactMap.begin(); it != contactMap.end(); ++it) {
        cout << it->first << " => " << it->second << endl;
    }

    // 按照姓名排序
    cout << "======>sort by name<========" << endl;
    map<string, string, PredIgnoreCase> sortedMap(contactMap.begin(), contactMap.end());
    for (auto it = sortedMap.begin(); it != sortedMap.end(); ++it) {
        cout << it->first << " => " << it->second << endl;
    }
    return 0;
}
```

### unordered_map
类似于unordered_set，unordered_map也可以使用哈希函数来存储元素，并且也可以使用自定义的哈希函数。

鉴于 unordered_map 将键-值对存储在桶中，在元素数达到或接近桶数时，它将自动执行负载均衡：

```cpp
cout << "Load factor: " << umapIntToStr.load_factor() << endl;
cout << "Max load factor = " << umapIntToStr.max_load_factor() << endl;
cout << "Max bucket count = " << umapIntToStr.max_bucket_count() << endl;
```

`load_factor()` 指出了 `unordered_map` 桶的填满程度。因插入元素导致 `load_factor()` 超过 `max_load_factor()` 时，`unordered_map` 将重新组织以增加桶数，并重建散列表。

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<int, string> umapIntToStr;
    umapIntToStr.insert(pair<int, string>(1, "one"));
    umapIntToStr.insert(pair<int, string>(2, "two"));
    umapIntToStr.insert(pair<int, string>(3, "three"));
    umapIntToStr.insert(pair<int, string>(4, "four"));
    umapIntToStr.insert(pair<int, string>(5, "five"));
    umapIntToStr.insert(pair<int, string>(6, "six"));
    umapIntToStr.insert(pair<int, string>(7, "seven"));
    umapIntToStr.insert(pair<int, string>(8, "eight"));
    umapIntToStr.insert(pair<int, string>(9, "nine"));
    umapIntToStr.insert(pair<int, string>(10, "ten"));
    umapIntToStr.insert(pair<int, string>(11, "eleven"));
    umapIntToStr.insert(pair<int, string>(12, "twelve"));
    umapIntToStr.insert(pair<int, string>(13, "thirteen"));
    
    cout << "Load factor: " << umapIntToStr.load_factor() << endl;
    cout << "Bucket Count:" << umapIntToStr.bucket_count() << endl;
    cout << "Max load factor = " << umapIntToStr.max_load_factor() << endl;
    cout << "Max bucket count = " << umapIntToStr.max_bucket_count() << endl;

    cout << "add 14th item" << endl;
 
    umapIntToStr.insert(pair<int, string>(14, "fourteen"));
    umapIntToStr.insert(pair<int, string>(15, "fifteen"));
    cout << "Load factor: " << umapIntToStr.load_factor() << endl;
     cout << "Bucket Count:" << umapIntToStr.bucket_count() << endl;
    cout << "Max load factor = " << umapIntToStr.max_load_factor() << endl;
    cout << "Max bucket count = " << umapIntToStr.max_bucket_count() << endl;
    return 0;
}
```

根据打印调整元素数量，一开始分配了13个bucket，当插入14个元素时，触发了rehash，分配了29个bucket。

注意：
* 无论使用的键是什么，都不要编写依赖于 unordered_map 中元素排列顺序的代码。在unordered_map 中，元素相对顺序取决于众多因素，其中包括键、插入顺序、桶数等。这些容器为提高查找性能进行了优化，遍历其中的元素时，不要依赖于元素的排列顺序。
* 在不发生冲突的情况下，std::unordered_map 的插入和查找时间几乎是固定的，不受包含的元素数的影响。然而，这并不意味着它优于在各种情形下复杂度都为对数的std::map。在包含的元素不太多的情况下，固定时间可能长得多，导致std::unordered_map 的速度比std::map 慢。选择容器类型时，务必执行模拟实际情况的基准测试。

### map小结
* 需要存储键-值对且键是唯一的时，务必使用map。
* 需要存储键-值对且键可能重复时（如电话簿），务必使用 multimap。
* 请牢记，与其他 STL 容器一样，map 和 multimap 都有成员方法 `size()` ，它指出容器包含多少个键-值对。
* 必须确保插入和查找时间固定时（通常是包含的元素非常多时），务必使用 unordered_map 或unordered_multimap。
* 别忘了， `multimap::count(key)` 指出容器中有多少个元素的键为 key。
* 别忘了检查 `find()` 的返回值—将其与容器的 `end()` 进行比较。

## 函数对象
