---
layout: post
description: > 
  本文记录了我学习C++的一些基础条目知识
image: 
  path: /assets/img/blog/blogs_cpp.png
  srcset: 
    1920w: /assets/img/blog/blogs_cpp.png
    960w:  /assets/img/blog/blogs_cpp.png
    480w:  /assets/img/blog/blogs_cpp.png
accent_image: /assets/img/blog/blogs_cpp.png
excerpt_separator: <!--more-->
sitemap: false
---
# C++基础记录（二）
本文是C++扫盲的第二篇记录，从STL标准模板往后的一些进阶内容。

前面的相关文章：

[C++基础记录](./2024-9-25-C++基础记录.md)

[【算法刷题】C++常见容器使用集合](./2025-4-5-【算法刷题】C++常见容器使用集合.md)

## STL容器
**STL 顺序容器** 如下所示。
* std::vector：操作与动态数组一样，在最后插入数据；可将 vector 视为书架，您可在一端添加和拿走图书。
* std::deque：与 std::vector 类似，但允许在开头插入或删除元素。
* std::list：操作与双向链表一样。可将它视为链条，对象被连接在一起，您可在任何位置添加或删除对象。
* std::forward_list：类似于 std::list，但是单向链表，只能沿一个方向遍历。

STL 提供的 **关联容器** 如下所示。
* std::set：存储各不相同的值，在插入时进行排序；容器的复杂度为对数。
* std::unordered_set：存储各不相同的值，在插入时进行排序；容器的复杂度为常数。这种容器是 C++11 新增的。
* std::map：存储键-值对，并根据唯一的键排序；容器的复杂度为对数。
* std::unordered_map：存储键-值对，并根据唯一的键排序；容器的复杂度为对数。这种容器是C++11 新增的。
* std::multiset：与 set 类似，但允许存储多个值相同的项，即值不需要是唯一的。
* std::unordered_multiset：与 unordered_set 类似，但允许存储多个值相同的项，即值不需要是唯一的。这种容器是 C++11 新增的。
* std::multimap：与 map 类似，但不要求键是唯一的。
* std::unordered_multimap：与 unordered_map 类似，但不要求键是唯一的。这种容器是 C++11新增的。

**容器适配器（Container Adapter）** 是顺序容器和关联容器的变种，其功能有限，用于满足特定的需
求。主要的适配器类如下所示。
* std::stack：以 LIFO（后进先出）的方式存储元素，让您能够在栈顶插入（压入）和删除（弹出）元素。
* std::queue：以 FIFO（先进先出）的方式存储元素，让您能够删除最先插入的元素。
* std::priority_queue：以特定顺序存储元素，因为优先级最高的元素总是位于队列开头。

## 迭代器
在C++中，**迭代器（Iterator）** 是一种通用概念，它提供了一种访问容器（如数组、列表、树等）中元素的方式，而无需暴露容器的底层实现细节。你可以把它想象成一个“智能指针”，它指向容器中的某个元素，并且可以**向前或向后移动**来遍历容器中的所有元素。

迭代器的主要作用就是将算法和容器分离。这样，你可以编写通用的算法（如排序、查找），这些算法可以应用于任何支持迭代器的容器，而不需要为每一种容器类型（如 `std::vector` 或 `std::list`）重复编写相同的代码。

### 迭代器的核心功能

一个典型的迭代器通常会提供以下操作：
* **解引用操作符 (`*`)**：获取迭代器当前指向的元素。
* **自增操作符 (`++`)**：将迭代器移动到下一个元素。
* **相等/不相等比较操作符 (`==`, `!=`)**：判断两个迭代器是否指向同一个位置。
* **自减操作符 (`--`)**：将迭代器移动到上一个元素（仅限部分类型）。

---

### STL 迭代器

**STL (Standard Template Library) 迭代器** 是 C++ 标准库中定义的一组特定的迭代器，它们是STL容器和算法之间的桥梁。

STL迭代器不是一个单一的类，而是一组概念和接口的集合。它们被分为五种主要类型，每种类型都有不同的功能，可以用于不同的场景：

1.  **输入迭代器 (Input Iterator)**
    * **用途：** 只能向前遍历容器一次，用于读取数据。
    * **例子：** 输入流迭代器 (`std::istream_iterator`)。

2.  **输出迭代器 (Output Iterator)**
    * **用途：** 只能向前遍历容器一次，用于写入数据。
    * **例子：** 输出流迭代器 (`std::ostream_iterator`)。

3.  **前向迭代器 (Forward Iterator)**
    * **用途：** 只能向前遍历容器，可以遍历多次。
    * **例子：** `std::forward_list` 的迭代器。

4.  **双向迭代器 (Bidirectional Iterator)**
    * **用途：** 可以向前和向后遍历容器。
    * **例子：** `std::list` 和 `std::set` 的迭代器。

5.  **随机访问迭代器 (Random Access Iterator)**
    * **用途：** 功能最强大，可以像指针一样进行**任意位置的跳转**。支持`+`, `-`, `[]`等操作。
    * **例子：** `std::vector`, `std::string`, `std::deque` 和 C 风格数组的迭代器。

### 为什么 STL 迭代器如此重要？

STL 迭代器的存在使得 STL 算法库非常强大和灵活。例如，`std::sort` 算法要求其参数是**随机访问迭代器**，因为它需要随机访问元素以进行高效的排序。而 `std::find` 算法只需要**输入迭代器**，因为它只需要从头到尾遍历一次即可。

总结来说，**C++ 迭代器**是一个通用的抽象概念，而 **STL 迭代器**是这个概念在 C++ 标准库中的具体实现，它们是连接 STL 容器和算法的通用接口，是 C++ 泛型编程的基石。

## STL算法
查找、排序和反转等都是标准的编程需求，不应让程序员重复实现这样的功能。因此 STL 以 STL
算法的方式提供这些函数，通过结合使用这些函数和迭代器，程序员可对容器执行一些最常见的操作。
最常用的 STL 算法如下所示。
* std::find：在集合中查找值。
* std::find_if：根据用户指定的谓词在集合中查找值。
* std::reverse：反转集合中元素的排列顺序。
* std::remove_if：根据用户定义的谓词将元素从集合中删除。
* std::transform：使用用户定义的变换函数对容器中的元素进行变换。
这些算法都是 std 命名空间中的模板函数，要使用它们，必须包含标准头文件`<algorithm>`。

### 举例从vector中查找元素及其下标
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // 查找元素
    int value_to_find = 30;
    auto it = std::find(vec.begin(), vec.end(), value_to_find);

    if (it != vec.end()) {
        std::cout << "Found value: " << *it << std::endl;
        // 获取下标
        int index = std::distance(vec.begin(), it);
        std::cout << "Index of value: " << index << std::endl;
    } else {
        std::cout << "Value not found." << std::endl;
    }

    return 0;
}
```

### 对比

![](/assets/img/blog/blogs_cpp_container_cmp.png)

## 字符串使用演进
C++中字符串的使用经历了从C风格字符串到C++标准库字符串类的演进，主要包括以下几个阶段：
1. **C风格字符串（C-Style Strings）**：
   * 这是最早的字符串表示方式，使用字符数组和空字符（`'\0'`）来表示字符串的结束。
   * 例如：`char str[] = "Hello, World!";`
   * 缺点：容易出现缓冲区溢出、内存管理复杂、操作不便等问题。
   * 优点：兼容性好，与C语言库函数兼容。

C++支持动态分配内存，使用`new`和`delete`运算符可以在运行时分配和释放内存。

比如使用 `char * dynamicName = new char[arrayLen]` 来定义一个动态分配的字符数组，其中 `arrayLen` 是一个整数，用于指定动态分配的字符数组的长度。

然而，如果要在运行阶段改变数组的长度，必须首先释放以前分
配给它的内存，再重新分配内存来存储数据。

如果将 char*用作类的成员属性，情况将更复杂。将对象赋给另一个对象时，如果编写正确的复制构造函数和赋值运算符，两个对象将包含同一个指针的拷贝，该指针指向相同的缓冲区。其结果是，两个对象的字符串指针存储的地址相同，指向同一个内存单元。其中一个对象被销毁时，另一个对象中的指针将非法，让应用程序面临崩溃的危险。

2. **C++标准库字符串类（std::string）**：
   * 这是C++标准库提供的字符串类，使用起来更加方便和安全。
   * 例如：`std::string str = "Hello, World!";`
   * 优点：自动管理内存、提供丰富的操作方法、支持字符串拼接、比较等。
   * 缺点：与C风格字符串相比，性能较低。

## string实例化和复制
string 类提供了很多重载的构造函数，因此可以多种方式进行实例化和初始化。例如，可使用常量字符串初始化 STL string 对象或将常量字符串赋给 STL std::string 对象：

```cpp
const char* constCStyleString = "Hello String!";
std::string strFromConst (constCStyleString);
```

或：

```cpp
std::string strFromConst = constCStyleString;
// 上述代码与下面的代码类似：
std::string str2 ("Hello String!"); 
```

同样，可使用一个 string 对象来初始化另一个：

```cpp
std::string str2Copy (str2);
```

可让 string 的构造函数只接受输入字符串的前 n 个字符：
```cpp
// Initialize a string to the first 5 characters of another
std::string strPartialCopy (constCStyleString, 5);
```

还可这样初始化 string 对象，即使其包含指定数量的特定字符：

```cpp
// Initialize a string object to contain 10 'a's
std::string strRepeatChars (10, 'a'); 
```

## string元素访问
第一种：使用`[]`运算符

```cpp
std::string str = "Hello, World!";
char ch = str[7]; // ch now holds 'W'
// 遍历
for (size_t i = 0; i < str.size(); ++i) {
    std::cout << str[i] << ' ';
}
```

这种方式来访问string内容时，需要注意的是，访问的下标必须在字符串的有效范围内，否则会导致未定义行为。

第二种：使用迭代器

```cpp
std::string str = "Hello, World!";
// 遍历
for (std::string::iterator it = str.begin(); it != str.end(); ++it) {
    std::cout << *it << ' ';
}
```

这种方式更加灵活，可以方便地进行各种操作，如插入、删除等。迭代器很重要，因为很多 string 成员函数都以迭代器的方式返回其结果。

## 拼接string 
可以使用`+`运算符或`append`方法来拼接字符串。

```cpp
std::string str1 = "Hello, ";
std::string str2 = "World!";
std::string str3 = str1 + str2; // str3 now holds "Hello, World!"
```

```cpp
std::string str1 = "Hello, ";
std::string str2 = "World!";
str1.append(str2); // str1 now holds "Hello, World!"
```

## string中字符和子字符串的查找
可以使用`find`方法来查找字符或子字符串。

```cpp
std::string str = "Hello, World!";
size_t pos = str.find("World"); // pos now holds 7
if (pos != std::string::npos) {
    std::cout << "Found at position: " << pos << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

`find`方法返回子字符串首次出现的位置，如果未找到则返回`std::string::npos`。

> 在C++的 **std::string** 类中， **string::npos** 是一个静态成员常量，它的值是 string::size_type 类型所能表示的最大值。它的主要作用是作为一个 **“未找到”**（"not found"）的标志。当你在使用 std::string 的查找方法（如 find() 或 rfind()）时，如果子字符串或字符没有被找到，这些方法就会返回 string::npos。

如果string中有不止一个的子字符串，`find`方法只会返回第一个子字符串的位置。如果要查找所有子字符串的位置，需要使用循环来实现。

```cpp
std::string str = "Hello, World! World!";
size_t pos = str.find("World");
while (pos != std::string::npos) {
    std::cout << "Found at position: " << pos << std::endl;
    pos = str.find("World", pos + 1);
}
```

## string的截断
如果是获取子字符串，可以使用`substr`方法来截取字符串的一部分。

```cpp
std::string str = "Hello, World!";
std::string subStr = str.substr(7, 5); // subStr now holds "World"
```

如果是直接对原字符串操作，可以使用 `erase()` 方法来删除指定位置的字符或子字符串。

STL string 类提供了 erase()函数，具有以下用途。
* 在给定偏移位置和字符数时删除指定数目的字符。

```cpp
string sampleStr ("Hello String! Wake up to a beautiful day!");
sampleStr.erase (13, 28); // Hello String!
```

* 在给定指向字符的迭代器时删除该字符。

```cpp
sampleStr.erase (iCharS); // iterator points to a specific character
```

* 在给定由两个迭代器指定的范围时删除该范围内的字符。

```cpp
sampleStr.erase (sampleStr.begin (), sampleStr.end ()); // erase from begin
```

例如：

```cpp
std::string str = "Hello, World!";
// 删除从位置 7 开始的 5 个字符
str.erase(7, 5); // str now holds "Hello!"
```

删除某一个字符：

```cpp
std::string str = "Hello, World!";
auto iChar = str.find('W');
if (iChar != std::string::npos) {
    str.erase(iChar, 1); // 删除第一个 'W'
}
std::cout << str << std::endl; // 输出 "Hello, orld!"
```

删除指定迭代器范围内的所有字符：
```cpp
std::string str = "Hello, World!";
auto iStart = str.begin() + 7;
auto iEnd = str.begin() + 12;
str.erase(iStart, iEnd); // str now holds "Hello!"
```

## 字符串反转
有时需要反转字符串的内容。假设要判断用户输入的字符串是否为回文，方法之一是将其反转，再与原来的字符串进行比较。反转 STL string 很容易，只需使用泛型算法 `std::reverse() ` 即可：

```cpp
string sampleStr ("Hello String! We will reverse you!");
reverse (sampleStr.begin (), sampleStr.end ());
```

std::reverse()算法根据两个输入参数指定的边界反转边界内的内容。在这里，两个边界分别是 string 对象的开头和末尾，因此整个字符串都被反转。只要提供合适的输入参数，也可将字符串的一部分反转。注意，边界不能超过 end()。

## 大小写转换
要对字符串进行大小写转换，可使用算法 `std::transform()` 来实现。

下面这个例子，将用户输入的字符串分别进行大写和小写转换：

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>

int main() {
    std::string input;
    std::cout << "Enter a string: ";
    std::getline(std::cin, input);

    // 转换为大写
    std::string upperCaseStr = input;
    std::transform(upperCaseStr.begin(), upperCaseStr.end(), upperCaseStr.begin(),
                   [](unsigned char c) { return std::toupper(c); });

    // 转换为小写
    std::string lowerCaseStr = input;
    std::transform(lowerCaseStr.begin(), lowerCaseStr.end(), lowerCaseStr.begin(),
                   [](unsigned char c) { return std::tolower(c); });

    std::cout << "Uppercase: " << upperCaseStr << std::endl;
    std::cout << "Lowercase: " << lowerCaseStr << std::endl;

    return 0;
}
```

## C++14引入的操作符""s
C++14引入了一个新的操作符`""s`，它可以直接将字符串字面量转换为`std::string`类型。这使得字符串的创建更加简洁和直观。

如果字面量字符串中包含了空字符，需要使用`""s`操作符来创建字符串。

```cpp
#include <iostream>
#include <string>

int main() {
    string str1("Hello \0 World!");
    cout << str1 << endl;
    // 输出：Hello


    string str2("Hello \0 World!"s);
    cout << str2 << endl;
    // 输出：Hello \0 World!

}
```

## vector
vector 是一个模板类，提供了动态数组的通用功能，具有如下特点：
* 在数组末尾添加元素所需的时间是固定的，即在末尾插入元素的所需时间不随数组大小而异，在末尾删除元素也如此；
* 在数组中间添加或删除元素所需的时间与该元素后面的元素个数成正比；
* 存储的元素数是动态的，而 vector 类负责管理内存。

### vector实例化
vector是一个模板类，需要指定元素类型。

```cpp
vector<int> dynamicIntArray;
vector<string> stringArray;
vector<double> doubleArray;
```

声明const迭代器可以这样写：

```cpp
vector<int>::const_iterator iter = dynamicIntArray.begin();
```

如果需要可修改值的迭代器，需要使用`iterator`而不是`const_iterator`。

```cpp
vector<int>::iterator iter = dynamicIntArray.begin();
```

其他实例化方式：

```cpp
// 初始化列表
vector<int> dynamicIntArray = {1, 2, 3, 4, 5};

// 指定大小，默认初始化元素为0
vector<int> dynamicIntArray(5);

// 指定大小，指定初始化元素，内部元素均为50
vector<int> dynamicIntArray(5, 50);

// 通过另一个vector初始化
vector<int> dynamicIntArray2(dynamicIntArray);

// 通过迭代器，使用另一个数组的一部分来初始化
vector<int> dynamicIntArray3(dynamicIntArray.begin(), dynamicIntArray.begin() + 3);
```

### 使用push_back()添加元素 和 pop_back()删除元素
添加元素：

```cpp
vector<int> dynamicIntArray;
dynamicIntArray.push_back(10);
dynamicIntArray.push_back(20);
dynamicIntArray.push_back(30);

// size() 函数返回vector中元素的个数
for (int i = 0; i < dynamicIntArray.size(); i++)
{
    cout << dynamicIntArray[i] << endl;
}
```

使用 `pop_back()` 将元素从 vector 中删除所需的时间是固定的，即不随 vector 存储的元素个数而异。例如：

```cpp
dynamicIntArray.pop_back(); // 删除最后一个元素
// 现在 dynamicIntArray 只包含 10 和 20
```

### 使用insert()指定位置插入元素
有好几个重载版本：

1. 插入指定位置，例如在开头插入一个元素：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
dynamicIntArray.insert(dynamicIntArray.begin(), 5); // 在开头插入5
// 结果： 5 10 20 30
```

2. 指定插入位置，元素数量，元素数值（数值相同）：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
dynamicIntArray.insert(dynamicIntArray.begin() + 1, 2, 15); // 在第二个位置插入两个15
// 结果： 10 15 15 20 30
```

3. 将另一个vector插入指定位置：

```cpp
vector<int> dynamicIntArray1 = {10, 20, 30};
vector<int> dynamicIntArray2 = {40, 50};
dynamicIntArray1.insert(dynamicIntArray1.begin() + 1, dynamicIntArray2.begin(), dynamicIntArray2.end());
// 结果： 10 40 50 20 30
```

### 使用数组语法访问元素
可以使用数组语法来访问 vector 中的元素：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
cout << dynamicIntArray[0] << endl; // 输出 10
cout << dynamicIntArray[1] << endl; // 输出 20
cout << dynamicIntArray[2] << endl; // 输出 30

// 循环
for (int i = 0; i < dynamicIntArray.size(); i++)
{
    cout << dynamicIntArray[i] << endl;
}
```

### 使用at()访问元素
`at()` 方法提供了边界检查，如果访问越界会抛出异常。

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
cout << dynamicIntArray.at(0) << endl; // 输出 10
cout << dynamicIntArray.at(1) << endl; // 输出 20
cout << dynamicIntArray.at(2) << endl; // 输出 30
```

### 使用指针语法访问vector元素
可以使用迭代器以类似指针的方式访问vector元素：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
vector<int>::const_iterator it = dynamicIntArray.begin();

cout << *it << endl; // 输出 10

// 遍历
for (it = dynamicIntArray.begin(); it != dynamicIntArray.end(); it++)
{
    cout << *it << endl;
}

```

这里使用了 `++` 运算符移动位置，使用了 `*` 运算符解引用迭代器。

### vector的大小和容量
`size()` 方法返回 vector 中元素的个数，而 `capacity()` 方法返回 vector 分配的内存大小（即可以容纳的元素个数）。

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
cout << "Size: " << dynamicIntArray.size() << endl; // 输出 3
cout << "Capacity: " << dynamicIntArray.capacity() << endl; // 输出 3 或更大
```

如果 vector 需要频繁地给其内部动态数组重新分配内存，将对性能造成一定的影响。在很大程度上说，这种问题可以通过使用成员函数 `reserve (number)` 来解决。`reserve` 函数的功能基本上是增加分配给内部数组的内存，以免频繁地重新分配内存。通过减少重新分配内存的次数，还可减少复制对象的时间，从而提高性能，这取决于存储在 vector 中的对象类型。

```cpp
vector<int> dynamicIntArray;
dynamicIntArray.reserve(100); // 预留空间以容纳100个元素
dynamicIntArray.push_back(10);
dynamicIntArray.push_back(20);
dynamicIntArray.push_back(30);
cout << "Size: " << dynamicIntArray.size() << endl; // 输出 3
cout << "Capacity: " << dynamicIntArray.capacity() << endl; // 输出 100
```

## deque
deque（double-ended queue）是一个模板类，提供了双端队列的通用功能，除了兼顾 vector 的随机访问能力，还支持在队列的前端进行快速的插入和删除操作。

对比两种结构的底层实现：
### vector和deque实现对比
C++ 的 `std::vector` 和 `std::deque` 都是标准模板库（STL）中的容器，它们在底层使用了不同的数据结构来存储元素，这导致了它们在性能特性上的差异。
### `std::vector`
`std::vector` 的底层实现是一个**动态数组（Dynamic Array）**。它的所有元素都存储在一段连续的内存块中。

* **优点：**
    * **快速随机访问：** 由于内存连续，通过索引访问任何元素的时间复杂度为 $O(1)$，因为它只需要简单的指针算术运算。
    * **缓存友好：** 连续的内存布局使得它在遍历元素时具有很好的 CPU 缓存局部性（cache locality），这通常能带来更好的性能。
* **缺点：**
    * **插入和删除开销大：** 在数组的中间或开头插入或删除元素需要移动其后的所有元素，时间复杂度为 $O(n)$。
    * **扩容开销：** 当动态数组的容量不足时，`vector` 需要分配一块更大的新内存，将所有旧元素复制到新内存中，然后释放旧内存。这个操作的时间复杂度也是 $O(n)$。

### `std::deque`
和 vector 容器采用连续的线性空间不同，deque 容器存储数据的空间是由一段一段等长的连续空间构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。

为了管理这些连续空间，deque 容器用数组（数组名假设为 map）存储着各个连续空间的首地址。

也就是说，map 数组中存储的都是指针，指向那些真正用来存储数据的各个连续空间。

![](/assets/img/blog/blogs_dequeue_mem_model.png)

通过建立 map 数组，deque 容器申请的这些分段的连续空间就能实现“整体连续”的效果。

换句话说，当 deque 容器需要在头部或尾部增加存储空间时，它会申请一段新的连续空间，同时在 map 数组的开头或结尾添加指向该空间的指针，由此该空间就串接到了 deque 容器的头部或尾部。

有读者可能会问，如果 map 数组满了怎么办？很简单，再申请一块更大的连续空间供 map 数组使用，将原有数据（很多指针）拷贝到新的 map 数组中，然后释放旧的空间。

deque 容器的分段存储结构，提高了在序列两端添加或删除元素的效率，但也使该容器迭代器的底层实现变得更复杂。

### 使用push_front()和push_back()

```cpp
#include <iostream>
#include <deque>
using namespace std;

int main() {
    deque<int> myDeque;

    // 在队列末尾添加元素
    myDeque.push_back(10);
    myDeque.push_back(20);
    myDeque.push_back(30);

    // 在队列前端添加元素
    myDeque.push_front(5);
    myDeque.push_front(1);

    // 当前deque内容: 1 5 10 20 30

    // 删除队列末尾的元素
    myDeque.pop_back();

    // 删除队列前端的元素
    myDeque.pop_front();

    // 修改后的deque内容: 5 10 20

    return 0;
}
```

### 两种遍历方式

```cpp
#include <iostream>
#include <deque>
using namespace std;

int main() {
    deque<int> myDeque = {10, 20, 30, 40, 50};

    // 使用索引遍历
    cout << "Using index:" << endl;
    for (size_t i = 0; i < myDeque.size(); ++i) {
        cout << myDeque[i] << " ";
    }
    cout << endl;

    // 使用迭代器遍历
    cout << "Using iterator:" << endl;
    for (deque<int>::iterator it = myDeque.begin(); it != myDeque.end(); ++it) {
        // 使用distance计算偏移位置
        size_t offset = distance(myDeque.begin(), it);
        cout << "Offset: " << offset << ", Value: " << *it << " ";
    }
    cout << endl;

    return 0;
}
```

> size_t 是无符号整数类型，用于表示对象的大小或索引。

### 清空vector和deque
可以使用 `clear()` 方法清空vector和deque，可以使用 `empty()` 来判断容器是否为空的。

```cpp
#include <iostream>
#include <vector>
#include <deque>

using namespace std;

int main() {
    vector<int> myVector = {1, 2, 3, 4, 5};
    deque<int> myDeque = {10, 20, 30, 40, 50};

    // 清空vector
    myVector.clear();
    if (myVector.empty()) {
        cout << "Vector is empty." << endl;
    } else {
        cout << "Vector is not empty." << endl;
    }

    // 清空deque
    myDeque.clear();
    if (myDeque.empty()) {
        cout << "Deque is empty." << endl;
    } else {
        cout << "Deque is not empty." << endl;
    }

    return 0;
}
```

| 应该                                             | 不应该                                           |
|--------------------------------------------------|--------------------------------------------------|
| 在不知道需要存储多少个元素时，务必使用动态数组 vector 或 deque。 | 使用固定大小的数组，可能会浪费内存或导致溢出。               |
| 请牢记，vector 只能在一端扩容，为此可使用函数 push_back( )。 | 试图在 vector 的前端插入元素，可能导致性能问题。               |
| 请牢记，deque 可在两端扩容，为此可使用函数 push_back( )和 push_front( )。 | 忘记 deque 的双端特性，导致不必要的复杂操作。                   |
| 访问动态数组时，不要跨越其边界。                             | 使用索引访问时不检查边界，可能导致未定义行为。                   |
| 使用迭代器遍历容器，确保代码的通用性和安全性。                   | 直接使用指针操作容器，可能导致错误和不安全的代码。               |

别忘了，函数 pop_back( )删除集合中的最后一个元素。函数 pop_front( )删除 deque 的第一个元素。

## std::list