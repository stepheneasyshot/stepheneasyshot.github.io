---
layout: post
description: > 
  本文记录了我学习C++的一些基础条目知识
image: 
  path: /assets/img/blog/blogs_cpp.png
  srcset: 
    1920w: /assets/img/blog/blogs_cpp.png
    960w:  /assets/img/blog/blogs_cpp.png
    480w:  /assets/img/blog/blogs_cpp.png
accent_image: /assets/img/blog/blogs_cpp.png
excerpt_separator: <!--more-->
sitemap: false
---
# C++基础记录（二）
本文是C++扫盲的第二篇记录，从STL标准模板往后的一些进阶内容。

前面的相关文章：

[C++基础记录](./2024-9-25-C++基础记录.md)

[【算法刷题】C++常见容器使用集合](./2025-4-5-【算法刷题】C++常见容器使用集合.md)

## STL容器
**STL 顺序容器** 如下所示。
* std::vector：操作与动态数组一样，在最后插入数据；可将 vector 视为书架，您可在一端添加和拿走图书。
* std::deque：与 std::vector 类似，但允许在开头插入或删除元素。
* std::list：操作与双向链表一样。可将它视为链条，对象被连接在一起，您可在任何位置添加或删除对象。
* std::forward_list：类似于 std::list，但是单向链表，只能沿一个方向遍历。

STL 提供的 **关联容器** 如下所示。
* std::set：存储各不相同的值，在插入时进行排序；容器的复杂度为对数。
* std::unordered_set：存储各不相同的值，在插入时进行排序；容器的复杂度为常数。这种容器是 C++11 新增的。
* std::map：存储键-值对，并根据唯一的键排序；容器的复杂度为对数。
* std::unordered_map：存储键-值对，并根据唯一的键排序；容器的复杂度为对数。这种容器是C++11 新增的。
* std::multiset：与 set 类似，但允许存储多个值相同的项，即值不需要是唯一的。
* std::unordered_multiset：与 unordered_set 类似，但允许存储多个值相同的项，即值不需要是唯一的。这种容器是 C++11 新增的。
* std::multimap：与 map 类似，但不要求键是唯一的。
* std::unordered_multimap：与 unordered_map 类似，但不要求键是唯一的。这种容器是 C++11新增的。

**容器适配器（Container Adapter）** 是顺序容器和关联容器的变种，其功能有限，用于满足特定的需
求。主要的适配器类如下所示。
* std::stack：以 LIFO（后进先出）的方式存储元素，让您能够在栈顶插入（压入）和删除（弹出）元素。
* std::queue：以 FIFO（先进先出）的方式存储元素，让您能够删除最先插入的元素。
* std::priority_queue：以特定顺序存储元素，因为优先级最高的元素总是位于队列开头。

## 迭代器
在C++中，**迭代器（Iterator）** 是一种通用概念，它提供了一种访问容器（如数组、列表、树等）中元素的方式，而无需暴露容器的底层实现细节。你可以把它想象成一个“智能指针”，它指向容器中的某个元素，并且可以**向前或向后移动**来遍历容器中的所有元素。

迭代器的主要作用就是将算法和容器分离。这样，你可以编写通用的算法（如排序、查找），这些算法可以应用于任何支持迭代器的容器，而不需要为每一种容器类型（如 `std::vector` 或 `std::list`）重复编写相同的代码。

### 迭代器的核心功能

一个典型的迭代器通常会提供以下操作：
* **解引用操作符 (`*`)**：获取迭代器当前指向的元素。
* **自增操作符 (`++`)**：将迭代器移动到下一个元素。
* **相等/不相等比较操作符 (`==`, `!=`)**：判断两个迭代器是否指向同一个位置。
* **自减操作符 (`--`)**：将迭代器移动到上一个元素（仅限部分类型）。

---

### STL 迭代器

**STL (Standard Template Library) 迭代器** 是 C++ 标准库中定义的一组特定的迭代器，它们是STL容器和算法之间的桥梁。

STL迭代器不是一个单一的类，而是一组概念和接口的集合。它们被分为五种主要类型，每种类型都有不同的功能，可以用于不同的场景：

1.  **输入迭代器 (Input Iterator)**
    * **用途：** 只能向前遍历容器一次，用于读取数据。
    * **例子：** 输入流迭代器 (`std::istream_iterator`)。

2.  **输出迭代器 (Output Iterator)**
    * **用途：** 只能向前遍历容器一次，用于写入数据。
    * **例子：** 输出流迭代器 (`std::ostream_iterator`)。

3.  **前向迭代器 (Forward Iterator)**
    * **用途：** 只能向前遍历容器，可以遍历多次。
    * **例子：** `std::forward_list` 的迭代器。

4.  **双向迭代器 (Bidirectional Iterator)**
    * **用途：** 可以向前和向后遍历容器。
    * **例子：** `std::list` 和 `std::set` 的迭代器。

5.  **随机访问迭代器 (Random Access Iterator)**
    * **用途：** 功能最强大，可以像指针一样进行**任意位置的跳转**。支持`+`, `-`, `[]`等操作。
    * **例子：** `std::vector`, `std::string`, `std::deque` 和 C 风格数组的迭代器。

### 为什么 STL 迭代器如此重要？

STL 迭代器的存在使得 STL 算法库非常强大和灵活。例如，`std::sort` 算法要求其参数是**随机访问迭代器**，因为它需要随机访问元素以进行高效的排序。而 `std::find` 算法只需要**输入迭代器**，因为它只需要从头到尾遍历一次即可。

总结来说，**C++ 迭代器**是一个通用的抽象概念，而 **STL 迭代器**是这个概念在 C++ 标准库中的具体实现，它们是连接 STL 容器和算法的通用接口，是 C++ 泛型编程的基石。

## STL算法
查找、排序和反转等都是标准的编程需求，不应让程序员重复实现这样的功能。因此 STL 以 STL
算法的方式提供这些函数，通过结合使用这些函数和迭代器，程序员可对容器执行一些最常见的操作。
最常用的 STL 算法如下所示。
* std::find：在集合中查找值。
* std::find_if：根据用户指定的谓词在集合中查找值。
* std::reverse：反转集合中元素的排列顺序。
* std::remove_if：根据用户定义的谓词将元素从集合中删除。
* std::transform：使用用户定义的变换函数对容器中的元素进行变换。
这些算法都是 std 命名空间中的模板函数，要使用它们，必须包含标准头文件`<algorithm>`。

### 举例从vector中查找元素及其下标
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // 查找元素
    int value_to_find = 30;
    auto it = std::find(vec.begin(), vec.end(), value_to_find);

    if (it != vec.end()) {
        std::cout << "Found value: " << *it << std::endl;
        // 获取下标
        int index = std::distance(vec.begin(), it);
        std::cout << "Index of value: " << index << std::endl;
    } else {
        std::cout << "Value not found." << std::endl;
    }

    return 0;
}
```

### 对比

![](/assets/img/blog/blogs_cpp_container_cmp.png)

## 字符串使用演进
C++中字符串的使用经历了从C风格字符串到C++标准库字符串类的演进，主要包括以下几个阶段：
1. **C风格字符串（C-Style Strings）**：
   * 这是最早的字符串表示方式，使用字符数组和空字符（`'\0'`）来表示字符串的结束。
   * 例如：`char str[] = "Hello, World!";`
   * 缺点：容易出现缓冲区溢出、内存管理复杂、操作不便等问题。
   * 优点：兼容性好，与C语言库函数兼容。

C++支持动态分配内存，使用`new`和`delete`运算符可以在运行时分配和释放内存。

比如使用 `char * dynamicName = new char[arrayLen]` 来定义一个动态分配的字符数组，其中 `arrayLen` 是一个整数，用于指定动态分配的字符数组的长度。

然而，如果要在运行阶段改变数组的长度，必须首先释放以前分
配给它的内存，再重新分配内存来存储数据。

如果将 char*用作类的成员属性，情况将更复杂。将对象赋给另一个对象时，如果编写正确的复制构造函数和赋值运算符，两个对象将包含同一个指针的拷贝，该指针指向相同的缓冲区。其结果是，两个对象的字符串指针存储的地址相同，指向同一个内存单元。其中一个对象被销毁时，另一个对象中的指针将非法，让应用程序面临崩溃的危险。

2. **C++标准库字符串类（std::string）**：
   * 这是C++标准库提供的字符串类，使用起来更加方便和安全。
   * 例如：`std::string str = "Hello, World!";`
   * 优点：自动管理内存、提供丰富的操作方法、支持字符串拼接、比较等。
   * 缺点：与C风格字符串相比，性能较低。

## string实例化和复制
string 类提供了很多重载的构造函数，因此可以多种方式进行实例化和初始化。例如，可使用常量字符串初始化 STL string 对象或将常量字符串赋给 STL std::string 对象：

```cpp
const char* constCStyleString = "Hello String!";
std::string strFromConst (constCStyleString);
```

或：

```cpp
std::string strFromConst = constCStyleString;
// 上述代码与下面的代码类似：
std::string str2 ("Hello String!"); 
```

同样，可使用一个 string 对象来初始化另一个：

```cpp
std::string str2Copy (str2);
```

可让 string 的构造函数只接受输入字符串的前 n 个字符：
```cpp
// Initialize a string to the first 5 characters of another
std::string strPartialCopy (constCStyleString, 5);
```

还可这样初始化 string 对象，即使其包含指定数量的特定字符：

```cpp
// Initialize a string object to contain 10 'a's
std::string strRepeatChars (10, 'a'); 
```

## string元素访问
第一种：使用`[]`运算符

```cpp
std::string str = "Hello, World!";
char ch = str[7]; // ch now holds 'W'
// 遍历
for (size_t i = 0; i < str.size(); ++i) {
    std::cout << str[i] << ' ';
}
```

这种方式来访问string内容时，需要注意的是，访问的下标必须在字符串的有效范围内，否则会导致未定义行为。

第二种：使用迭代器

```cpp
std::string str = "Hello, World!";
// 遍历
for (std::string::iterator it = str.begin(); it != str.end(); ++it) {
    std::cout << *it << ' ';
}
```

这种方式更加灵活，可以方便地进行各种操作，如插入、删除等。迭代器很重要，因为很多 string 成员函数都以迭代器的方式返回其结果。

## 拼接string 
可以使用`+`运算符或`append`方法来拼接字符串。

```cpp
std::string str1 = "Hello, ";
std::string str2 = "World!";
std::string str3 = str1 + str2; // str3 now holds "Hello, World!"
```

```cpp
std::string str1 = "Hello, ";
std::string str2 = "World!";
str1.append(str2); // str1 now holds "Hello, World!"
```

## string中字符和子字符串的查找
可以使用`find`方法来查找字符或子字符串。

```cpp
std::string str = "Hello, World!";
size_t pos = str.find("World"); // pos now holds 7
if (pos != std::string::npos) {
    std::cout << "Found at position: " << pos << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

`find`方法返回子字符串首次出现的位置，如果未找到则返回`std::string::npos`。

> 在C++的 **std::string** 类中， **string::npos** 是一个静态成员常量，它的值是 string::size_type 类型所能表示的最大值。它的主要作用是作为一个 **“未找到”**（"not found"）的标志。当你在使用 std::string 的查找方法（如 find() 或 rfind()）时，如果子字符串或字符没有被找到，这些方法就会返回 string::npos。

如果string中有不止一个的子字符串，`find`方法只会返回第一个子字符串的位置。如果要查找所有子字符串的位置，需要使用循环来实现。

```cpp
std::string str = "Hello, World! World!";
size_t pos = str.find("World");
while (pos != std::string::npos) {
    std::cout << "Found at position: " << pos << std::endl;
    pos = str.find("World", pos + 1);
}
```

## string的截断
如果是获取子字符串，可以使用`substr`方法来截取字符串的一部分。

```cpp
std::string str = "Hello, World!";
std::string subStr = str.substr(7, 5); // subStr now holds "World"
```

如果是直接对原字符串操作，可以使用 `erase()` 方法来删除指定位置的字符或子字符串。

STL string 类提供了 erase()函数，具有以下用途。
* 在给定偏移位置和字符数时删除指定数目的字符。

```cpp
string sampleStr ("Hello String! Wake up to a beautiful day!");
sampleStr.erase (13, 28); // Hello String!
```

* 在给定指向字符的迭代器时删除该字符。

```cpp
sampleStr.erase (iCharS); // iterator points to a specific character
```

* 在给定由两个迭代器指定的范围时删除该范围内的字符。

```cpp
sampleStr.erase (sampleStr.begin (), sampleStr.end ()); // erase from begin
```

例如：

```cpp
std::string str = "Hello, World!";
// 删除从位置 7 开始的 5 个字符
str.erase(7, 5); // str now holds "Hello!"
```

删除某一个字符：

```cpp
std::string str = "Hello, World!";
auto iChar = str.find('W');
if (iChar != std::string::npos) {
    str.erase(iChar, 1); // 删除第一个 'W'
}
std::cout << str << std::endl; // 输出 "Hello, orld!"
```

删除指定迭代器范围内的所有字符：
```cpp
std::string str = "Hello, World!";
auto iStart = str.begin() + 7;
auto iEnd = str.begin() + 12;
str.erase(iStart, iEnd); // str now holds "Hello!"
```

## 字符串反转
有时需要反转字符串的内容。假设要判断用户输入的字符串是否为回文，方法之一是将其反转，再与原来的字符串进行比较。反转 STL string 很容易，只需使用泛型算法 `std::reverse() ` 即可：

```cpp
string sampleStr ("Hello String! We will reverse you!");
reverse (sampleStr.begin (), sampleStr.end ());
```

std::reverse()算法根据两个输入参数指定的边界反转边界内的内容。在这里，两个边界分别是 string 对象的开头和末尾，因此整个字符串都被反转。只要提供合适的输入参数，也可将字符串的一部分反转。注意，边界不能超过 end()。

## 大小写转换
要对字符串进行大小写转换，可使用算法 `std::transform()` 来实现。

下面这个例子，将用户输入的字符串分别进行大写和小写转换：

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>

int main() {
    std::string input;
    std::cout << "Enter a string: ";
    std::getline(std::cin, input);

    // 转换为大写
    std::string upperCaseStr = input;
    std::transform(upperCaseStr.begin(), upperCaseStr.end(), upperCaseStr.begin(),
                   [](unsigned char c) { return std::toupper(c); });

    // 转换为小写
    std::string lowerCaseStr = input;
    std::transform(lowerCaseStr.begin(), lowerCaseStr.end(), lowerCaseStr.begin(),
                   [](unsigned char c) { return std::tolower(c); });

    std::cout << "Uppercase: " << upperCaseStr << std::endl;
    std::cout << "Lowercase: " << lowerCaseStr << std::endl;

    return 0;
}
```

## C++14引入的操作符""s
C++14引入了一个新的操作符`""s`，它可以直接将字符串字面量转换为`std::string`类型。这使得字符串的创建更加简洁和直观。

如果字面量字符串中包含了空字符，需要使用`""s`操作符来创建字符串。

```cpp
#include <iostream>
#include <string>

int main() {
    string str1("Hello \0 World!");
    cout << str1 << endl;
    // 输出：Hello


    string str2("Hello \0 World!"s);
    cout << str2 << endl;
    // 输出：Hello \0 World!

}
```

## vector
vector 是一个模板类，提供了动态数组的通用功能，具有如下特点：
* 在数组末尾添加元素所需的时间是固定的，即在末尾插入元素的所需时间不随数组大小而异，在末尾删除元素也如此；
* 在数组中间添加或删除元素所需的时间与该元素后面的元素个数成正比；
* 存储的元素数是动态的，而 vector 类负责管理内存。

### vector实例化
vector是一个模板类，需要指定元素类型。

```cpp
vector<int> dynamicIntArray;
vector<string> stringArray;
vector<double> doubleArray;
```

声明const迭代器可以这样写：

```cpp
vector<int>::const_iterator iter = dynamicIntArray.begin();
```

如果需要可修改值的迭代器，需要使用`iterator`而不是`const_iterator`。

```cpp
vector<int>::iterator iter = dynamicIntArray.begin();
```

其他实例化方式：

```cpp
// 初始化列表
vector<int> dynamicIntArray = {1, 2, 3, 4, 5};

// 指定大小，默认初始化元素为0
vector<int> dynamicIntArray(5);

// 指定大小，指定初始化元素，内部元素均为50
vector<int> dynamicIntArray(5, 50);

// 通过另一个vector初始化
vector<int> dynamicIntArray2(dynamicIntArray);

// 通过迭代器，使用另一个数组的一部分来初始化
vector<int> dynamicIntArray3(dynamicIntArray.begin(), dynamicIntArray.begin() + 3);
```

### 使用push_back()添加元素 和 pop_back()删除元素
添加元素：

```cpp
vector<int> dynamicIntArray;
dynamicIntArray.push_back(10);
dynamicIntArray.push_back(20);
dynamicIntArray.push_back(30);

// size() 函数返回vector中元素的个数
for (int i = 0; i < dynamicIntArray.size(); i++)
{
    cout << dynamicIntArray[i] << endl;
}
```

使用 `pop_back()` 将元素从 vector 中删除所需的时间是固定的，即不随 vector 存储的元素个数而异。例如：

```cpp
dynamicIntArray.pop_back(); // 删除最后一个元素
// 现在 dynamicIntArray 只包含 10 和 20
```

### 使用insert()指定位置插入元素
有好几个重载版本：

1. 插入指定位置，例如在开头插入一个元素：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
dynamicIntArray.insert(dynamicIntArray.begin(), 5); // 在开头插入5
// 结果： 5 10 20 30
```

2. 指定插入位置，元素数量，元素数值（数值相同）：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
dynamicIntArray.insert(dynamicIntArray.begin() + 1, 2, 15); // 在第二个位置插入两个15
// 结果： 10 15 15 20 30
```

3. 将另一个vector插入指定位置：

```cpp
vector<int> dynamicIntArray1 = {10, 20, 30};
vector<int> dynamicIntArray2 = {40, 50};
dynamicIntArray1.insert(dynamicIntArray1.begin() + 1, dynamicIntArray2.begin(), dynamicIntArray2.end());
// 结果： 10 40 50 20 30
```

### 使用数组语法访问元素
可以使用数组语法来访问 vector 中的元素：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
cout << dynamicIntArray[0] << endl; // 输出 10
cout << dynamicIntArray[1] << endl; // 输出 20
cout << dynamicIntArray[2] << endl; // 输出 30

// 循环
for (int i = 0; i < dynamicIntArray.size(); i++)
{
    cout << dynamicIntArray[i] << endl;
}
```

### 使用at()访问元素
`at()` 方法提供了边界检查，如果访问越界会抛出异常。

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
cout << dynamicIntArray.at(0) << endl; // 输出 10
cout << dynamicIntArray.at(1) << endl; // 输出 20
cout << dynamicIntArray.at(2) << endl; // 输出 30
```

### 使用指针语法访问vector元素
可以使用迭代器以类似指针的方式访问vector元素：

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
vector<int>::const_iterator it = dynamicIntArray.begin();

cout << *it << endl; // 输出 10

// 遍历
for (it = dynamicIntArray.begin(); it != dynamicIntArray.end(); it++)
{
    cout << *it << endl;
}

```

这里使用了 `++` 运算符移动位置，使用了 `*` 运算符解引用迭代器。

### vector的大小和容量
`size()` 方法返回 vector 中元素的个数，而 `capacity()` 方法返回 vector 分配的内存大小（即可以容纳的元素个数）。

```cpp
vector<int> dynamicIntArray = {10, 20, 30};
cout << "Size: " << dynamicIntArray.size() << endl; // 输出 3
cout << "Capacity: " << dynamicIntArray.capacity() << endl; // 输出 3 或更大
```

如果 vector 需要频繁地给其内部动态数组重新分配内存，将对性能造成一定的影响。在很大程度上说，这种问题可以通过使用成员函数 `reserve (number)` 来解决。`reserve` 函数的功能基本上是增加分配给内部数组的内存，以免频繁地重新分配内存。通过减少重新分配内存的次数，还可减少复制对象的时间，从而提高性能，这取决于存储在 vector 中的对象类型。

```cpp
vector<int> dynamicIntArray;
dynamicIntArray.reserve(100); // 预留空间以容纳100个元素
dynamicIntArray.push_back(10);
dynamicIntArray.push_back(20);
dynamicIntArray.push_back(30);
cout << "Size: " << dynamicIntArray.size() << endl; // 输出 3
cout << "Capacity: " << dynamicIntArray.capacity() << endl; // 输出 100
```

## deque
deque（double-ended queue）是一个模板类，提供了双端队列的通用功能，除了兼顾 vector 的随机访问能力，还支持在队列的前端进行快速的插入和删除操作。

对比两种结构的底层实现：
### vector和deque实现对比
C++ 的 `std::vector` 和 `std::deque` 都是标准模板库（STL）中的容器，它们在底层使用了不同的数据结构来存储元素，这导致了它们在性能特性上的差异。
### `std::vector`
`std::vector` 的底层实现是一个**动态数组（Dynamic Array）**。它的所有元素都存储在一段连续的内存块中。

* **优点：**
    * **快速随机访问：** 由于内存连续，通过索引访问任何元素的时间复杂度为 $O(1)$，因为它只需要简单的指针算术运算。
    * **缓存友好：** 连续的内存布局使得它在遍历元素时具有很好的 CPU 缓存局部性（cache locality），这通常能带来更好的性能。
* **缺点：**
    * **插入和删除开销大：** 在数组的中间或开头插入或删除元素需要移动其后的所有元素，时间复杂度为 $O(n)$。
    * **扩容开销：** 当动态数组的容量不足时，`vector` 需要分配一块更大的新内存，将所有旧元素复制到新内存中，然后释放旧内存。这个操作的时间复杂度也是 $O(n)$。

### `std::deque`
和 vector 容器采用连续的线性空间不同，deque 容器存储数据的空间是由一段一段等长的连续空间构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。

为了管理这些连续空间，deque 容器用数组（数组名假设为 map）存储着各个连续空间的首地址。

也就是说，map 数组中存储的都是指针，指向那些真正用来存储数据的各个连续空间。

![](/assets/img/blog/blogs_dequeue_mem_model.png)

通过建立 map 数组，deque 容器申请的这些分段的连续空间就能实现“整体连续”的效果。

换句话说，当 deque 容器需要在头部或尾部增加存储空间时，它会申请一段新的连续空间，同时在 map 数组的开头或结尾添加指向该空间的指针，由此该空间就串接到了 deque 容器的头部或尾部。

有读者可能会问，如果 map 数组满了怎么办？很简单，再申请一块更大的连续空间供 map 数组使用，将原有数据（很多指针）拷贝到新的 map 数组中，然后释放旧的空间。

deque 容器的分段存储结构，提高了在序列两端添加或删除元素的效率，但也使该容器迭代器的底层实现变得更复杂。

### 使用push_front()和push_back()

```cpp
#include <iostream>
#include <deque>
using namespace std;

int main() {
    deque<int> myDeque;

    // 在队列末尾添加元素
    myDeque.push_back(10);
    myDeque.push_back(20);
    myDeque.push_back(30);

    // 在队列前端添加元素
    myDeque.push_front(5);
    myDeque.push_front(1);

    // 当前deque内容: 1 5 10 20 30

    // 删除队列末尾的元素
    myDeque.pop_back();

    // 删除队列前端的元素
    myDeque.pop_front();

    // 修改后的deque内容: 5 10 20

    return 0;
}
```

### 两种遍历方式

```cpp
#include <iostream>
#include <deque>
using namespace std;

int main() {
    deque<int> myDeque = {10, 20, 30, 40, 50};

    // 使用索引遍历
    cout << "Using index:" << endl;
    for (size_t i = 0; i < myDeque.size(); ++i) {
        cout << myDeque[i] << " ";
    }
    cout << endl;

    // 使用迭代器遍历
    cout << "Using iterator:" << endl;
    for (deque<int>::iterator it = myDeque.begin(); it != myDeque.end(); ++it) {
        // 使用distance计算偏移位置
        size_t offset = distance(myDeque.begin(), it);
        cout << "Offset: " << offset << ", Value: " << *it << " ";
    }
    cout << endl;

    return 0;
}
```

> size_t 是无符号整数类型，用于表示对象的大小或索引。

### 清空vector和deque
可以使用 `clear()` 方法清空vector和deque，可以使用 `empty()` 来判断容器是否为空的。

```cpp
#include <iostream>
#include <vector>
#include <deque>

using namespace std;

int main() {
    vector<int> myVector = {1, 2, 3, 4, 5};
    deque<int> myDeque = {10, 20, 30, 40, 50};

    // 清空vector
    myVector.clear();
    if (myVector.empty()) {
        cout << "Vector is empty." << endl;
    } else {
        cout << "Vector is not empty." << endl;
    }

    // 清空deque
    myDeque.clear();
    if (myDeque.empty()) {
        cout << "Deque is empty." << endl;
    } else {
        cout << "Deque is not empty." << endl;
    }

    return 0;
}
```

| 应该                                             | 不应该                                           |
|--------------------------------------------------|--------------------------------------------------|
| 在不知道需要存储多少个元素时，务必使用动态数组 vector 或 deque。 | 使用固定大小的数组，可能会浪费内存或导致溢出。               |
| 请牢记，vector 只能在一端扩容，为此可使用函数 push_back( )。 | 试图在 vector 的前端插入元素，可能导致性能问题。               |
| 请牢记，deque 可在两端扩容，为此可使用函数 push_back( )和 push_front( )。 | 忘记 deque 的双端特性，导致不必要的复杂操作。                   |
| 访问动态数组时，不要跨越其边界。                             | 使用索引访问时不检查边界，可能导致未定义行为。                   |
| 使用迭代器遍历容器，确保代码的通用性和安全性。                   | 直接使用指针操作容器，可能导致错误和不安全的代码。               |

别忘了，函数 `pop_back()` 删除集合中的最后一个元素。函数 `pop_front()` 删除 deque 的第一个元素。

## std::list
`std::list` 在C++中是一个双向链表（doubly linked list），它的核心实现依赖于节点（node）和指针（pointer）。

![](/assets/img/blog/blogs_stdlist_linkedlist.png)

`std::list` 通常使用一个 **虚拟的头节点（sentinel node）** 来简化操作。这个节点不存储任何实际数据，它的作用是：
* next指针永远指向链表的第一个真实节点。
* prev指针永远指向链表的最后一个真实节点。
* 当链表为空时，这个虚拟头节点的next和prev都指向它自己。

使用虚拟头节点的好处是，无论是插入、删除还是遍历，你都不需要对链表为空或在头尾进行特殊判断，所有操作都可以用统一的方式处理，这大大简化了代码逻辑。

要实例化模板 list，需要指定要在其中存储的对象类型，因此实例化 list 的语法类似于下面这样：

```cpp
std::list<int> linkInts; // list containing integers
std::list<float> listFloats; // list containing floats
std::list<Tuna> listTunas; // list containing objects of type Tuna 
```

要声明一个指向 list 中元素的迭代器，可以像下面这样做：

```cpp
std::list<int>::const_iterator elementInList;
```

如果需要一个这样的迭代器，即可以使用它来修改值或调用非 const 函数，可将 const_iterator 替换为 iterator。

### list实例化方式

```cpp
#include <iostream>
#include <list>
using namespace std;
int main() {
    // 使用初始化列表
    list<int> myList = {1, 2, 3, 4, 5};

    // 使用默认构造函数
    list<string> stringList;

    // 使用指定大小和初始值
    list<double> doubleList(5, 3.14); // 包含5个3.14

    // 使用另一个list初始化
    list<int> anotherList(myList);

    // 使用vector的元素来实例化一个list
    vector<int> vec = {10, 20, 30, 40, 50};
    list<int> listFromVec(vec.cbegin(), vec.cend());

    return 0;
}
```
您首先实例化了一个 vector，接下来，实例化了一个 list，它包含从 vector 复制而来的元素，这是使用 C++11 新增的 vector::cbegin()和 vector::cend()返回的 const 迭代器复制的。该程序清单表明，迭代器让容器的实现彼此独立，其通用功能让您能够使用 vector 中的值实例化 list。

### list的开头和末尾插入元素
可以使用 `push_front()` 方法在 list 的开头插入元素，使用 `push_back()` 方法在 list 的末尾插入元素。

```cpp
#include <iostream>
#include <list>
using namespace std;
int main() {
    list<int> myList;

    // 在开头插入元素
    myList.push_front(10);
    myList.push_front(20);

    // 在末尾插入元素
    myList.push_back(30);
    myList.push_back(40);

    // 输出列表内容
    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    return 0;
}
```

### list中间插入元素
可以使用 `insert()` 方法在 list 的中间插入元素。

成员函数 list::insert()有 3 种版本。
* 第 1 种版本：

```cpp
iterator insert(iterator pos, const T& x)
```

在这里，insert 函数接受的第 1 个参数是插入位置，第 2 个参数是要插入的值。该函数返回一个迭代器，它指向刚插入到 list 中的元素。

* 第 2 种版本：

```cpp
void insert(iterator pos, size_type n, const T& x)
```

该函数的第 1 个参数是插入位置，最后一个参数是要插入的值，而第 2 个参数是要插入的元素个数。

* 第 3 种版本：

```cpp
template <class InputIterator>
void insert(iterator pos, InputIterator f, InputIterator l)
```

该重载版本是一个模板函数，除一个位置参数外，它还接受两个输入迭代器，指定要将集合中相应范围内的元素插入到 list 中。注意，输入类型 InputIterator 是一种模板参数化类型，因此可指定任何集合（数组、vector 或另一个 list）的边界。

```cpp
#include <iostream>
#include <list>
using namespace std;
int main() {
    list<int> myList = {10, 20, 30, 40};

    // 在第二个位置插入元素
    auto it = myList.begin();
    advance(it, 1); // 移动到第二个位置
    myList.insert(it, 15); // 在第二个位置插入15

    // 此时的列表内容 10 15 20 30 40

    // 在第二个位置插入多个元素
    it = myList.begin();
    advance(it, 1); // 移动到第二个位置
    myList.insert(it, 2, 25); // 在第二个位置插入2个25

    // 此时的列表内容 10 15 25 25 20 30 40

    // 在第二个位置插入数组元素
    int arr[] = {35, 45};
    it = myList.begin();
    advance(it, 1); // 移动到第二个位置
    myList.insert(it, arr, arr + 2); // 在第二个位置插入数组元素

    // 此时的列表内容 10 15 25 25 35 45 20 30 40

    return 0;
}
```

### list删除元素
erase() 方法用于删除 list 中的元素。有两个重载版本：
* 接受一个迭代器参数，删除指定位置的元素；
* 接受两个迭代器参数，删除指定范围内的元素。

```cpp
#include <iostream>
#include <list>
using namespace std;
int main() {
    list<int> myList = {10, 20, 30, 40, 50};

    // 删除第二个元素
    auto it = myList.begin();
    advance(it, 1); // 移动到第二个位置
    myList.erase(it); // 删除第二个元素

    // 此时的列表内容 10 30 40 50

    // 删除第二个元素到第四个元素
    it = myList.begin();
    advance(it, 1); // 移动到第二个位置
    auto endIt = myList.begin();
    advance(endIt, 3); // 移动到第四个位置
    myList.erase(it, endIt); // 删除第二个元素到第四个元素

    // 此时的列表内容: 10 50

    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    return 0;
}
```

需要注意的是， `list::erase(first, last)` 删除的是 `[first, last)` 范围内的元素，即包含 first 指向的元素，但不包含 last 指向的元素。这也是为什么第二次删除会移除 30 和 40，而保留 50（在执行第二次删除前的列表中）。因为尾迭代器 endIt 指向的为50这个元素。

> 区分于it.end() ，it.end() 指向的其实是最后一个元素的下一个位置，所以使用it.end()来删除元素时，会删除到最后一个元素。

### list元素反转
可以使用 `reverse()` 方法来反转 list 中的元素。

```cpp
#include <iostream>
#include <list>
using namespace std;
int main() {
    list<int> myList = {10, 20, 30, 40, 50};

    // 反转列表元素
    myList.reverse();

    // 输出列表内容
    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    return 0;
}
```

### list进行排序
可以使用 `sort()` 方法对 list 中的元素进行排序。
有两个重载方法：
* 单独一个sort()方法，默认以升序排序
* 接受一个比较函数作为参数，以指定的标准排序

```cpp
#include <iostream>
#include <list>
using namespace std;

bool SortPredicate_Descending(const int& a, const int& b) {
    return a > b; // 降序排序
}

int main() {
    list<int> myList = {40, 10, 30, 20, 50};

    // 默认升序排序
    myList.sort();

    cout << "Sorted in ascending order: ";
    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    // 降序排序
    myList.sort(SortPredicate_Descending);

    cout << "Sorted in descending order: ";
    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    return 0;
}
```

定义了函数 `SortPredicate_Descending` ，它是一个二元谓词，帮助 list 的 `sort()` 函数判断一个元素是否比另一个元素小。如果不是，则交换这两个元素的位置。换句话说，您告诉了 list 如何解释小于，就这里而言，小于的含义是第一个参数大于第二个参数。这个谓词仅在第一个值比第二个值大时返回 true。也就是说，使用该谓词时，仅当第一个元素（lsh）的数字值比第二个元素（rsh）大时，sort()才认为第一个元素比第二个元素小。基于这种解释，sort()交换元素的位置，以满足谓词指定的标准。

### 包含对象的list进行排序
实际使用中，很少使用list来存储int等简单内置类型，而是存储自定义的类型，这是如何排序呢？

答案是采取下面两种方式之一：
* 在 list 包含的对象所属的类中，实现运算符<；
* 提供一个排序二元谓词—一个这样的函数，即接受两个输入值，并返回一个布尔值，指出第一个值是否比第二个值小。

```cpp
#include <iostream>
#include <list>
#include <string>

using namespace std;


class Tuna {
    int age;
    string name;
public:
    Tuna(int age, string name) {
        this->age = age;
        this->name = name;
    }
    int getAge() const {
        return age;
    }
    string getName() const {
        return name;
    }
    // 实现<操作符函数，实现按照名称name的长度升序排序
    bool operator<(const Tuna& other) const {
        return name.size() < other.name.size();
    }
};

bool SortPredicate_Age(const Tuna& a, const Tuna& b) {
    return a.getAge() < b.getAge(); // 按年龄升序排序
}

int main() {
    list<Tuna> tunaList;
    tunaList.push_back(Tuna(1, "Tunadfbdbn1"));
    tunaList.push_back(Tuna(2, "Tunafbdfbdbfsddvw2"));
    tunaList.push_back(Tuna(3, "Tuna3"));

    // 按年龄排序
    tunaList.sort(SortPredicate_Age);

    cout << "Sorted Tuna List by Age:" << endl;
    for (const auto& tuna : tunaList) {
        cout << "Name: " << tuna.getName() << ", Age: " << tuna.getAge() << endl;
    }

    tunaList.sort();
    cout << "Sorted Tuna List by < oprator:" << endl;
    for (const auto& tuna : tunaList) {
        cout << "Name: " << tuna.getName() << ", Age: " << tuna.getAge() << endl;
    }

    return 0;
}
```

### 包含对象的list进行删除
这时候需要使用list的 `remove()` 方法，但是需要注意的是，需要给 `remove()` 方法指定标准。在类中实现 `==` 比较运算符。

```cpp
#include <iostream>
#include <list>
#include <string>
using namespace std;

class Human {
    string name;
    int age;
public:
    Human(string name, int age) {
        this->name = name;
        this->age = age;
    }
    string getName() const {
        return name;
    }
    int getAge() const {
        return age;
    }
    bool operator==(const Human& other) {
        return name == other.name;
    }
};

int main() {
    list<Human> humanList;
    humanList.push_back(Human("张三", 18));
    humanList.push_back(Human("李四", 20));
    humanList.push_back(Human("王五", 22));

    for (const auto& human : humanList) {
        cout << "Name: " << human.getName() << ", Age: " << human.getAge() << endl;
    }

    humanList.remove(Human("李四", 20));

    cout << "=======> After remove: 李四 <==========" << endl;
    for (const auto& human : humanList) {
        cout << "Name: " << human.getName() << ", Age: " << human.getAge() << endl;
    }

    return 0;
}
```

实现的 Human::operator==将该对象与 list 中的元素进行比较。该运算符在姓名相同时返回 true，向 list::remove( )指出了匹配标准。

### std::forward_list 
`std::forward_list` 是 C++11 引入的一个单向链表容器，提供了类似于 `std::list` 的功能，但只支持单向遍历。它的底层实现依赖于节点（node）和指针（pointer）。

![](/assets/img/blog/blogs_stdlist_forward_list.png)

forward_list 的用法与 list 很像，但只能沿一个方向移动迭代器，且插入元素时只能使用函数 `push_front()`，而不能使用 `push_back()`。当然，总是可以使用 `insert()` 及其重载版本在指定位置插入元素。

下列代码演示了 forward_list 的实例化，添加元素和单向遍历：

```cpp
#include <iostream>
#include <forward_list>
using namespace std;
int main() {
    forward_list<int> myList;
    myList.push_front(1);
    myList.push_front(2);
    myList.push_front(3);
    // 现在 myList 包含 3, 2, 1
    for (const auto& elem : myList) {
        cout << elem << " ";
    }
    cout << endl;

    auto it = myList.begin();
    myList.insert_after(it, 4);
    // 现在 myList 包含 3, 4, 2, 1
    for (auto singleIt = myList.begin(); singleIt != myList.end(); singleIt++) {
        cout << *singleIt << " ";
    }
    cout << endl;

    return 0;
}
```

> 鉴于 forward_list 不支持双向迭代，因此只能对迭代器使用运算符++，而不能使用--。

列表总结：

* 如果需要频繁地插入或删除元素（尤其是在中间插入或删除时），应使用 std::list，而不是 std::vetor。因为在这种情况下，vector 需要调整其内部缓冲区的大小，以支持数组语法，还需执行开销高昂的复制操作，而 list 只需建立或断开链接。

* 请记住，可使用成员方法 `push_front()` 和 `push_back()` 分别在 list 开头和末尾插入元素。

* 对于要使用 list 等 STL 容器存储其对象的类，别忘了在其中实现运算符<和==，以提供默认的排序和删除谓词。

* 请记住，像其他 STL 容器类一样，总是可以使用 `list::size()` 来确定 list 包含多少个元素。

* 请记住，像其他 STL 容器类一样，可使用方法 `list::clear()` 清空 list。

* 无需频繁在两端插入或删除元素，且不用在中间插入或删除元素时，请不要使用 list；在这些情况下，vector 和 deque 的速度要快得多。

* 如果不想根据默认标准进行删除或排序，别忘了给 `sort()` 和 `remove()` 提供一个谓词函数。

## STL集合类
