---
layout: post
description: > 
  本文记录了我学习C++的一些基础条目知识
image: 
  path: /assets/img/blog/blogs_cpp.png
  srcset: 
    1920w: /assets/img/blog/blogs_cpp.png
    960w:  /assets/img/blog/blogs_cpp.png
    480w:  /assets/img/blog/blogs_cpp.png
accent_image: /assets/img/blog/blogs_cpp.png
excerpt_separator: <!--more-->
sitemap: false
---
# C++基础记录（二）
本文是C++扫盲的第二篇记录，从STL标准模板往后的一些进阶内容。

前面的相关文章：

[C++基础记录](./2024-9-25-C++基础记录.md)

[【算法刷题】C++常见容器使用集合](./2025-4-5-【算法刷题】C++常见容器使用集合.md)

## STL容器
**STL 顺序容器** 如下所示。
* std::vector：操作与动态数组一样，在最后插入数据；可将 vector 视为书架，您可在一端添加和拿走图书。
* std::deque：与 std::vector 类似，但允许在开头插入或删除元素。
* std::list：操作与双向链表一样。可将它视为链条，对象被连接在一起，您可在任何位置添加或删除对象。
* std::forward_list：类似于 std::list，但是单向链表，只能沿一个方向遍历。

STL 提供的 **关联容器** 如下所示。
* std::set：存储各不相同的值，在插入时进行排序；容器的复杂度为对数。
* std::unordered_set：存储各不相同的值，在插入时进行排序；容器的复杂度为常数。这种容器是 C++11 新增的。
* std::map：存储键-值对，并根据唯一的键排序；容器的复杂度为对数。
* std::unordered_map：存储键-值对，并根据唯一的键排序；容器的复杂度为对数。这种容器是C++11 新增的。
* std::multiset：与 set 类似，但允许存储多个值相同的项，即值不需要是唯一的。
* std::unordered_multiset：与 unordered_set 类似，但允许存储多个值相同的项，即值不需要是唯一的。这种容器是 C++11 新增的。
* std::multimap：与 map 类似，但不要求键是唯一的。
* std::unordered_multimap：与 unordered_map 类似，但不要求键是唯一的。这种容器是 C++11新增的。

**容器适配器（Container Adapter）** 是顺序容器和关联容器的变种，其功能有限，用于满足特定的需
求。主要的适配器类如下所示。
* std::stack：以 LIFO（后进先出）的方式存储元素，让您能够在栈顶插入（压入）和删除（弹出）元素。
* std::queue：以 FIFO（先进先出）的方式存储元素，让您能够删除最先插入的元素。
* std::priority_queue：以特定顺序存储元素，因为优先级最高的元素总是位于队列开头。

## 迭代器
在C++中，**迭代器（Iterator）** 是一种通用概念，它提供了一种访问容器（如数组、列表、树等）中元素的方式，而无需暴露容器的底层实现细节。你可以把它想象成一个“智能指针”，它指向容器中的某个元素，并且可以**向前或向后移动**来遍历容器中的所有元素。

迭代器的主要作用就是将算法和容器分离。这样，你可以编写通用的算法（如排序、查找），这些算法可以应用于任何支持迭代器的容器，而不需要为每一种容器类型（如 `std::vector` 或 `std::list`）重复编写相同的代码。

### 迭代器的核心功能

一个典型的迭代器通常会提供以下操作：
* **解引用操作符 (`*`)**：获取迭代器当前指向的元素。
* **自增操作符 (`++`)**：将迭代器移动到下一个元素。
* **相等/不相等比较操作符 (`==`, `!=`)**：判断两个迭代器是否指向同一个位置。
* **自减操作符 (`--`)**：将迭代器移动到上一个元素（仅限部分类型）。

---

### STL 迭代器

**STL (Standard Template Library) 迭代器** 是 C++ 标准库中定义的一组特定的迭代器，它们是STL容器和算法之间的桥梁。

STL迭代器不是一个单一的类，而是一组概念和接口的集合。它们被分为五种主要类型，每种类型都有不同的功能，可以用于不同的场景：

1.  **输入迭代器 (Input Iterator)**
    * **用途：** 只能向前遍历容器一次，用于读取数据。
    * **例子：** 输入流迭代器 (`std::istream_iterator`)。

2.  **输出迭代器 (Output Iterator)**
    * **用途：** 只能向前遍历容器一次，用于写入数据。
    * **例子：** 输出流迭代器 (`std::ostream_iterator`)。

3.  **前向迭代器 (Forward Iterator)**
    * **用途：** 只能向前遍历容器，可以遍历多次。
    * **例子：** `std::forward_list` 的迭代器。

4.  **双向迭代器 (Bidirectional Iterator)**
    * **用途：** 可以向前和向后遍历容器。
    * **例子：** `std::list` 和 `std::set` 的迭代器。

5.  **随机访问迭代器 (Random Access Iterator)**
    * **用途：** 功能最强大，可以像指针一样进行**任意位置的跳转**。支持`+`, `-`, `[]`等操作。
    * **例子：** `std::vector`, `std::string`, `std::deque` 和 C 风格数组的迭代器。

### 为什么 STL 迭代器如此重要？

STL 迭代器的存在使得 STL 算法库非常强大和灵活。例如，`std::sort` 算法要求其参数是**随机访问迭代器**，因为它需要随机访问元素以进行高效的排序。而 `std::find` 算法只需要**输入迭代器**，因为它只需要从头到尾遍历一次即可。

总结来说，**C++ 迭代器**是一个通用的抽象概念，而 **STL 迭代器**是这个概念在 C++ 标准库中的具体实现，它们是连接 STL 容器和算法的通用接口，是 C++ 泛型编程的基石。

## STL算法
查找、排序和反转等都是标准的编程需求，不应让程序员重复实现这样的功能。因此 STL 以 STL
算法的方式提供这些函数，通过结合使用这些函数和迭代器，程序员可对容器执行一些最常见的操作。
最常用的 STL 算法如下所示。
* std::find：在集合中查找值。
* std::find_if：根据用户指定的谓词在集合中查找值。
* std::reverse：反转集合中元素的排列顺序。
* std::remove_if：根据用户定义的谓词将元素从集合中删除。
* std::transform：使用用户定义的变换函数对容器中的元素进行变换。
这些算法都是 std 命名空间中的模板函数，要使用它们，必须包含标准头文件`<algorithm>`。

### 举例从vector中查找元素及其下标
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // 查找元素
    int value_to_find = 30;
    auto it = std::find(vec.begin(), vec.end(), value_to_find);

    if (it != vec.end()) {
        std::cout << "Found value: " << *it << std::endl;
        // 获取下标
        int index = std::distance(vec.begin(), it);
        std::cout << "Index of value: " << index << std::endl;
    } else {
        std::cout << "Value not found." << std::endl;
    }

    return 0;
}
```

### 对比

![](/assets/img/blog/blogs_cpp_container_cmp.png)

## 字符串使用演进
C++中字符串的使用经历了从C风格字符串到C++标准库字符串类的演进，主要包括以下几个阶段：
1. **C风格字符串（C-Style Strings）**：
   * 这是最早的字符串表示方式，使用字符数组和空字符（`'\0'`）来表示字符串的结束。
   * 例如：`char str[] = "Hello, World!";`
   * 缺点：容易出现缓冲区溢出、内存管理复杂、操作不便等问题。
   * 优点：兼容性好，与C语言库函数兼容。

C++支持动态分配内存，使用`new`和`delete`运算符可以在运行时分配和释放内存。

比如使用 `char * dynamicName = new char[arrayLen]` 来定义一个动态分配的字符数组，其中 `arrayLen` 是一个整数，用于指定动态分配的字符数组的长度。

然而，如果要在运行阶段改变数组的长度，必须首先释放以前分
配给它的内存，再重新分配内存来存储数据。

如果将 char*用作类的成员属性，情况将更复杂。将对象赋给另一个对象时，如果编写正确的复制构造函数和赋值运算符，两个对象将包含同一个指针的拷贝，该指针指向相同的缓冲区。其结果是，两个对象的字符串指针存储的地址相同，指向同一个内存单元。其中一个对象被销毁时，另一个对象中的指针将非法，让应用程序面临崩溃的危险。

2. **C++标准库字符串类（std::string）**：
   * 这是C++标准库提供的字符串类，使用起来更加方便和安全。
   * 例如：`std::string str = "Hello, World!";`
   * 优点：自动管理内存、提供丰富的操作方法、支持字符串拼接、比较等。
   * 缺点：与C风格字符串相比，性能较低。

## string实例化和复制
string 类提供了很多重载的构造函数，因此可以多种方式进行实例化和初始化。例如，可使用常量字符串初始化 STL string 对象或将常量字符串赋给 STL std::string 对象：

```cpp
const char* constCStyleString = "Hello String!";
std::string strFromConst (constCStyleString);
```

或：

```cpp
std::string strFromConst = constCStyleString;
// 上述代码与下面的代码类似：
std::string str2 ("Hello String!"); 
```

同样，可使用一个 string 对象来初始化另一个：

```cpp
std::string str2Copy (str2);
```

可让 string 的构造函数只接受输入字符串的前 n 个字符：
```cpp
// Initialize a string to the first 5 characters of another
std::string strPartialCopy (constCStyleString, 5);
```

还可这样初始化 string 对象，即使其包含指定数量的特定字符：

```cpp
// Initialize a string object to contain 10 'a's
std::string strRepeatChars (10, 'a'); 
```

## string元素访问
第一种：使用`[]`运算符

```cpp
std::string str = "Hello, World!";
char ch = str[7]; // ch now holds 'W'
// 遍历
for (size_t i = 0; i < str.size(); ++i) {
    std::cout << str[i] << ' ';
}
```

这种方式来访问string内容时，需要注意的是，访问的下标必须在字符串的有效范围内，否则会导致未定义行为。

第二种：使用迭代器

```cpp
std::string str = "Hello, World!";
// 遍历
for (std::string::iterator it = str.begin(); it != str.end(); ++it) {
    std::cout << *it << ' ';
}
```

这种方式更加灵活，可以方便地进行各种操作，如插入、删除等。迭代器很重要，因为很多 string 成员函数都以迭代器的方式返回其结果。

## 拼接string 
可以使用`+`运算符或`append`方法来拼接字符串。

```cpp
std::string str1 = "Hello, ";
std::string str2 = "World!";
std::string str3 = str1 + str2; // str3 now holds "Hello, World!"
```

```cpp
std::string str1 = "Hello, ";
std::string str2 = "World!";
str1.append(str2); // str1 now holds "Hello, World!"
```

## string中字符和子字符串的查找
可以使用`find`方法来查找字符或子字符串。

```cpp
std::string str = "Hello, World!";
size_t pos = str.find("World"); // pos now holds 7
if (pos != std::string::npos) {
    std::cout << "Found at position: " << pos << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

`find`方法返回子字符串首次出现的位置，如果未找到则返回`std::string::npos`。

> 在C++的 **std::string** 类中， **string::npos** 是一个静态成员常量，它的值是 string::size_type 类型所能表示的最大值。它的主要作用是作为一个 **“未找到”**（"not found"）的标志。当你在使用 std::string 的查找方法（如 find() 或 rfind()）时，如果子字符串或字符没有被找到，这些方法就会返回 string::npos。

如果string中有不止一个的子字符串，`find`方法只会返回第一个子字符串的位置。如果要查找所有子字符串的位置，需要使用循环来实现。

```cpp
std::string str = "Hello, World! World!";
size_t pos = str.find("World");
while (pos != std::string::npos) {
    std::cout << "Found at position: " << pos << std::endl;
    pos = str.find("World", pos + 1);
}
```

## string的截断
如果是获取子字符串，可以使用`substr`方法来截取字符串的一部分。

```cpp
std::string str = "Hello, World!";
std::string subStr = str.substr(7, 5); // subStr now holds "World"
```

如果是直接对原字符串操作，可以使用 `erase()` 方法来删除指定位置的字符或子字符串。

STL string 类提供了 erase()函数，具有以下用途。
* 在给定偏移位置和字符数时删除指定数目的字符。

```cpp
string sampleStr ("Hello String! Wake up to a beautiful day!");
sampleStr.erase (13, 28); // Hello String!
```

* 在给定指向字符的迭代器时删除该字符。

```cpp
sampleStr.erase (iCharS); // iterator points to a specific character
```

* 在给定由两个迭代器指定的范围时删除该范围内的字符。

```cpp
sampleStr.erase (sampleStr.begin (), sampleStr.end ()); // erase from begin
```

例如：

```cpp
std::string str = "Hello, World!";
// 删除从位置 7 开始的 5 个字符
str.erase(7, 5); // str now holds "Hello!"
```

删除某一个字符：

```cpp
std::string str = "Hello, World!";
auto iChar = str.find('W');
if (iChar != std::string::npos) {
    str.erase(iChar, 1); // 删除第一个 'W'
}
std::cout << str << std::endl; // 输出 "Hello, orld!"
```

删除指定迭代器范围内的所有字符：
```cpp
std::string str = "Hello, World!";
auto iStart = str.begin() + 7;
auto iEnd = str.begin() + 12;
str.erase(iStart, iEnd); // str now holds "Hello!"
```

## 字符串反转
有时需要反转字符串的内容。假设要判断用户输入的字符串是否为回文，方法之一是将其反转，再与原来的字符串进行比较。反转 STL string 很容易，只需使用泛型算法 `std::reverse() ` 即可：

```cpp
string sampleStr ("Hello String! We will reverse you!");
reverse (sampleStr.begin (), sampleStr.end ());
```

std::reverse()算法根据两个输入参数指定的边界反转边界内的内容。在这里，两个边界分别是 string 对象的开头和末尾，因此整个字符串都被反转。只要提供合适的输入参数，也可将字符串的一部分反转。注意，边界不能超过 end()。

## 大小写转换
要对字符串进行大小写转换，可使用算法 `std::transform()` 来实现。

下面这个例子，将用户输入的字符串分别进行大写和小写转换：

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>

int main() {
    std::string input;
    std::cout << "Enter a string: ";
    std::getline(std::cin, input);

    // 转换为大写
    std::string upperCaseStr = input;
    std::transform(upperCaseStr.begin(), upperCaseStr.end(), upperCaseStr.begin(),
                   [](unsigned char c) { return std::toupper(c); });

    // 转换为小写
    std::string lowerCaseStr = input;
    std::transform(lowerCaseStr.begin(), lowerCaseStr.end(), lowerCaseStr.begin(),
                   [](unsigned char c) { return std::tolower(c); });

    std::cout << "Uppercase: " << upperCaseStr << std::endl;
    std::cout << "Lowercase: " << lowerCaseStr << std::endl;

    return 0;
}
```

## C++14引入的操作符""s
C++14引入了一个新的操作符`""s`，它可以直接将字符串字面量转换为`std::string`类型。这使得字符串的创建更加简洁和直观。

如果字面量字符串中包含了空字符，需要使用`""s`操作符来创建字符串。

```cpp
#include <iostream>
#include <string>

int main() {
    string str1("Hello \0 World!");
    cout << str1 << endl;
    // 输出：Hello


    string str2("Hello \0 World!"s);
    cout << str2 << endl;
    // 输出：Hello \0 World!

}
```

## vector
