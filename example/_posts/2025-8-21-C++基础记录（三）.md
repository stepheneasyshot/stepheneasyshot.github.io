---
layout: post
description: > 
  本文记录了我学习C++的一些基础条目知识
image: 
  path: /assets/img/blog/blogs_cpp.png
  srcset: 
    1920w: /assets/img/blog/blogs_cpp.png
    960w:  /assets/img/blog/blogs_cpp.png
    480w:  /assets/img/blog/blogs_cpp.png
accent_image: /assets/img/blog/blogs_cpp.png
excerpt_separator: <!--more-->
sitemap: false
---
# C++基础记录（三）
本文是C++扫盲的第三篇记录，从STL位标志往后的一些进阶内容。

前面的相关文章：

[C++基础记录](./2024-9-25-C++基础记录.md)
[C++基础记录（二）](./2025-8-18-C++基础记录（二）.md)

[【算法刷题】C++常见容器使用集合](./2025-4-5-【算法刷题】C++常见容器使用集合.md)

## STL位标志
### bitset
`std::bitset` 是 C++ 标准库中一个非常实用的类，它提供了一种管理和操作固定大小的位的集合（bit set）的方式。你可以把它想象成一个数组，但这个数组的每个元素都只能是 0 或 1。

> 从低位到高位是从右往左数，第 0 位是最右边的位。

主要特点：
* 固定大小: std::bitset 的大小在编译时就确定了。你需要用一个模板参数来指定它能存储多少位，例如 std::bitset<32> 表示一个能存储 32 位的 bit set。
* 高效: 因为大小是固定的，它在内存中通常会以一个或多个无符号整数的形式存储，这使得位操作（如位移、按位与、或、异或等）非常高效。
* 方便的接口: 它提供了很多方便的方法来操作和查询位，比如设置、清零、翻转、测试特定位等。

### 实例化 std::bitset
实例化这个模板类时，必须通过一个模板参数指定实例需要管理的位数：

```cpp
bitset <4> fourBits; // 4 bits initialized to 0000
```

还可将 bitset 初始化为一个用字符串字面量（char*）表示的位序列：

```cpp
bitset <5> fiveBits("10101"); // 5 bits 10101
```

使用一个 bitset 来实例化另一个 bitset 非常简单：

```cpp
bitset <8> fiveBitsCopy(fiveBits); 
```

使用实例：

```cpp
#include <iostream>
#include <bitset>
using namespace std;
int main() {
  // 创建一个 4 位的 bitset
  bitset<4> fourBits; // 4 bits initialized to 0000
  // 创建一个 5 位的 bitset
  bitset<5> fiveBits("10101"); // 5 bits 10101
  // 创建一个 8 位的 bitset
  bitset<8> eightBits(255); // 8 bits 11111111
  // 创建一个 8 位的 bitset 副本
  bitset <8> eightBitsCopy(eightBits); 
  
  return 0;
}
```

### bitset运算符
`std::bitset` 提供了多种运算符来进行位操作，这些运算符使得对位集合的操作变得非常直观和高效。以下是一些常用的运算符：

| 运算符 | 描述 |
| --- | --- |
| << | 将位序列的文本表示插入到输出流中|
| >> | 将一个字符串插入到bitset对象中 |
| ~ | 按位取反 |
| & | 按位与 |
| \| | 按位或 |
| ^ | 按位异或 |
| <<= | 左移，例如左移两位 fourBits <<= 2; |
| >>= | 右移 |
| [] | 访问特定位 |

使用举例：

```cpp
#include <iostream>
#include <bitset>

using namespace std;

int main() {
    bitset<8> b1(1);
    // 00000001
    b1 <<= 2;
    // 左移两位，变为 00000100
    cout << "b1 after left shift by 2: " << b1 << endl;
    return 0;
}
```

取反：

```cpp
#include <iostream>
#include <bitset>
using namespace std;

int main() {
    bitset<8> b1(5); // 00000101
    cout << "b1: " << b1 << endl;
    cout << "b1 after NOT: " << ~b1 << endl; // 11111010
    return 0;
}
```

### bitset成员方法
| 函数 | 描述 |
| --- | --- |
| set() | 将序列中的所有位都设置为 1 |
| set (N, val=1) | 将第 N+1 位设置为 val 指定的值（默认为 1） |
| reset() | 将序列中的所有位都重置为 0 |
| reset (N) | 将偏移位置为（N+1）的位清除 |
| flip() | 将位序列中的所有位取反 |
| size() | 返回序列中的位数 |
| count() | 返回序列中值为 1 的位数 |

使用举例：

```cpp
#include <iostream>
#include <bitset>
using namespace std;

int main() {
    bitset<8> b1(5); // 00000101
    cout << "b1: " << b1 << endl;
    b1.set(2); // 将第 3 位设置为 1
    cout << "b1 after set(2): " << b1 << endl;
    b1.reset(2); // 将第 3 位设置为 0
    cout << "b1 after reset(2): " << b1 << endl;
    b1.flip(); // 取反
    cout << "b1 after flip(): " << b1 << endl;
    return 0;
}
```

## `vector<bool>`
STL bitset 的缺点之一是不能动态地调整长度。仅当在编辑阶段知道序列将存储多少位时才能使用 bitset。
为了克服这种缺点，STL 向程序员提供了 `vector<bool>` 类（在有些 STL 实现中为bit_vector）。

实例化 `vector<bool>` 的方式与实例化 `vector` 类似，有一些方便的重载构造函数可供使用：

```cpp
vector <bool> boolFlags1;
```

例如，可创建一个这样的 vector，即它最初包含 10 个布尔元素，且每个元素都被初始化为 1（即true）：

```cpp
vector <bool> boolFlags2 (10, true);
```

还可使用一个 `vector<bool>` 创建另一个 `vector<bool>`：

```cpp
vector <bool> boolFlags2Copy (boolFlags2); 
```

### `vector<bool>` 成员方法和运算符
`vector<bool>`提供了函数 `flip()`，用于将序列中的布尔值取反，这与函数 `bitset<>::flip()` 很像。

除这个方法外，`vector<bool>` 与 `std::vector` 极其相似，例如，可使用 `push_back` 将标志位插入到序列中。

使用举例：

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<bool> vb(3);
    vb[0] = true;
    vb[1] = false;
    vb[2] = true;
    vb.push_back(true);
    
    for (int i = 0; i < vb.size(); i++)
    {
        cout << vb[i] << endl;
    }

    vb.flip();
    cout << "After flip:" << endl;
    for (int i = 0; i < vb.size(); i++)
    {
        cout << vb[i] << endl;
    }

    return 0;
}
```

一开始写作了：

```cpp
vector<bool> vb;
vb[0] = true;
```

没有指定大小，就直接使用 0 位，严重错误，直接越界。 **需要养成声明即初始化的好习惯** ，使用前确定大小。

可以先初始化大小，或者先push_back添加元素，再修改对应位置。也可以使用初始化列表： `vector <bool> boolFlags{ true, true, false }` .

## 智能指针
C++在内存分配、释放和管理方面具有其他语言不具备的灵活性。同时这种松散的机制也会引发一些不确定性。

例如：

```cpp
SomeClass* ptrData = anObject.GetData ();
/*
 Questions: Is object pointed by ptrData dynamically allocated using new?
 If so, who calls delete? Caller or the called?
 Answer: No idea!
*/
ptrData->DoSomething();
```

在上述代码中，没有显而易见的方法获悉 ptrData 指向的内存：
* 是否是从堆中分配的，因此最终需要释放；
* 是否由调用者负责释放；
* 对象的析构函数是否会自动销毁该对象。

### 优势
智能指针可以自动管理动态分配的内存，避免内存泄漏和悬空指针等问题。

```cpp
smart_pointer<SomeClass> spData = anObject.GetData ();
// Use a smart pointer like a conventional pointer!
spData->Display ();
(*spData).Display ();
// Don't have to worry about de-allocation
// (the smart pointer's destructor does it for you)
```

智能指针的行为类似常规指针（这里将其称为原始指针），但通过重载的运算符和析构函数确保动态分配的数据能够及时地销毁，从而提供了更多有用的功能。

智能指针类重载了 **解除引用运算符（*）** 和 **成员选择运算符（->）** ，让程序员可以像使用常规指针那样使用智能指针。

### 一个简单的智能指针类
代码如下：

```cpp
template <typename T>
class smart_pointer
{
  private:
    T* ptr;
  public:
    smart_pointer(T* p = nullptr) : ptr(p) {}
    ~smart_pointer() { delete ptr; }
    T& operator*() { return *ptr; }
    T* operator->() { return ptr; }
    // copy constructor
    smart_pointer(const smart_pointer& sp) : ptr(sp.ptr) {}
    // assignment operator
    smart_pointer& operator=(const smart_pointer& sp)
    {
        if (this != &sp)
        {
            delete ptr;
            ptr = sp.ptr;
        }
        return *this;
    }
};
```

实现了 `*` 和 `->` 运算符，从而可以像常规意义上的指针那样使用它。

### 插入：内存管理策略
使智能指针真正“智能”的是复制构造函数、赋值运算符和析构函数的实现，它们决定了智能指针对象被传递给函数、赋值或离开作用域（即像其他类对象一样被销毁）时的行为。
#### 策略：深复制
回顾一下切除问题：

```cpp
void MakeFishSwim(Fish aFish)
{
    aFish.swim();
}

...

Carp carp1;
MakeFishSwim(carp1);
// Slicing: only the Fish part of Carp is sent to MakeFishSwim() 

Tuna tuna1;
MakeFishSwim(tuna1);
```

下面实例，使用基于深复制的智能指针将多态对象作为基类对象进行传递：

```cpp
template <typename T>
class deepcopy_smart_ptr
{
  private:
    T* ptr;
    // copy constructor
    deepcopy_smart_ptr(const deepcopy_smart_ptr& source)
    {
      ptr = source->Clone();
    }
    // assignment operator
    deepcopy_smart_ptr& operator=(const deepcopy_smart_ptr& source)
    {
        if (ptr)
        {
            delete ptr;
        }
        ptr = source->Clone();
        return *this;
    }
};
```

实现了一个复制构造函数，使得能够通过函数 `Clone()` 函数对多态对象进行深复制—类必须实现函数 `Clone()` 。另外，它还实现了复制赋值运算符，为了简单起见，这里假设基类 Fish 实现的虚函数为 `Clone()` 。通常，实现深复制模型的智能指针通过模板参数或函数对象提供该函数。下面是 `deepcopy_smart_ptr` 的一种用法：

```cpp
deepcopy_smart_ptr<Carp> freshWaterFish(new Carp);
MakeFishSwim (freshWaterFish); // Carp will not be 'sliced' 
```

#### 策略：写时复制（Copy on Write）
COW是一种优化策略，它推迟了资源的复制操作。当你有两个对象共享同一份数据时，COW会让你在第一次**修改**数据时才真正地去复制它。
##### COW的核心思想
想象一下，你有一个`std::string`对象，叫`s1`，里面存着一段很长的文本。现在你想要用`s1`去初始化另一个`std::string`对象`s2`：

```cpp
std::string s1 = "这是一段很长的文本...";
std::string s2 = s1; // 理论上s2是s1的一个拷贝
```

如果`std::string`使用了COW，那么在这一步，`s2`并不会立刻复制`s1`的数据。相反，`s1`和`s2`会共享同一份底层数据。为了实现这一点，通常会有一个引用计数（reference count）来记录有多少个对象正在共享这份数据。在这个例子中，这份数据的引用计数会从1增加到2。
##### 什么时候会触发复制？
复制操作只会在你试图修改其中一个对象时发生。比如，你想修改`s2`：

```cpp
s2 += "，后面又加了一些新内容。"; // 触发写时复制
```

在你执行这行代码时，系统会检查`s2`所指向的数据的引用计数。因为它大于1，所以系统会：

1.  为`s2`分配一块新的内存。
2.  将原始数据（“这是一段很长的文本...”）从旧地址复制到新地址。
3.  让`s2`指向这份新数据。
4.  将原始数据的引用计数减1。
5.  最后，将新内容添加到`s2`的新数据中。

##### 智能指针的COW应用
写时复制机制（Copy on Write，COW）试图对深复制智能指针的性能进行优化，它共享指针，直到首次写入对象。首次调用非 const 函数时，COW 指针通常为该非 const 函数操作的对象创建一个副本，而其他指针实例仍共享源对象。

COW 深受很多程序员的喜欢。实现 const 和非 const 版本的运算符*和->，是实现 COW 指针功能的关键。非 const 版本用于创建副本。

重要的是，选择 COW 指针时，在使用这样的实现前务必理解其实现细节。否则，复制时将出现复制得太少或太多的情况。

#### 策略：引用计数智能指针
引用计数智能指针，通常指的是 C++ 标准库中的 `std::shared_ptr` ，它是一种用于管理动态分配对象生命周期的智能指针。它的核心思想是共享所有权（shared ownership），即多个智能指针可以同时指向同一个对象，并且该对象只有 **在所有指向它的智能指针都被销毁或重置后，才会自动释放内存**。因此，引用计数提供了一种优良的机制，使得可共享对象而无法对其进行复制。

这种智能指针被复制时，需要将对象的引用计数加 1。至少有两种常用的方法来跟踪计数：
* 在对象中维护引用计数；
* 引用计数由共享对象中的指针类维护。

前者称为入侵式引用计数，因为需要修改对象以维护和递增引用计数，并将其提供给管理对象的智能指针。COM 采取的就是这种方法。

后者是智能指针类将计数保存在自由存储区（如动态分配的整型），复制时复制构造函数将这个值加 1。

因此，使用引用计数机制，程序员只应通过智能指针来处理对象。在使用智能指针管理对象的同时让原始指针指向它是一种糟糕的做法，因为智能指针将在它维护的引用计数减为零时释放对象，而原始指针将继续指向已不属于当前应用程序的内存。

引用计数还有一个独特的问题：如果两个对象分别存储指向对方的指针，这两个对象将永远不会被释放，因为它们的生命周期依赖性导致其引用计数最少为 1。即循环引用。

**循环引用的解决办法**

为了解决循环引用的问题，C++ 提供了**std::weak_ptr**。std::weak_ptr 是一种不增加引用计数的智能指针，它通常用于打破循环引用，或者观察一个对象而不会阻止其被销毁。当你需要访问 `std::weak_ptr` 所指向的对象时，你需要先将其转换为 `std::shared_ptr` 。

区分于 `std::shared_ptr` ，`std::weak_ptr` 不会增加对象的强引用计数。对应的，被 `weak_ptr` 指向的引用，成为弱引用。只要有一个 `std::weak_ptr` 或 `std::shared_ptr` 指向控制块，弱引用计数就大于 0。当弱引用计数降为 0 时，控制块才会被销毁。

std::weak_ptr 只会影响弱引用计数，而不会影响强引用计数。这意味着，即使有多个 std::weak_ptr 指向同一个对象，只要没有 std::shared_ptr 指向它，对象随时都可能被销毁。

**核心功能：lock() 方法**

std::weak_ptr 最大的特点是它不能直接访问所指向的对象。为了安全地使用它，你需要先调用 lock() 方法。

lock() 方法会检查对象是否仍然存在（即强引用计数是否大于 0）。
* 如果对象存在，lock() 会返回一个临时的 std::shared_ptr。这时，强引用计数会增加 1，确保在你使用这个临时智能指针期间，对象不会被销毁。使用完毕后，这个临时智能指针会自动销毁，引用计数会减 1。
* 如果对象不存在（已经被销毁），lock() 会返回一个空的 std::shared_ptr。

这个机制非常重要，因为它保证了你在访问对象时，该对象是有效的。

#### 策略：破坏性复制
破坏性复制是这样一种机制，即在智能指针被复制时，将对象的所有权转交给目标指针并重置原来的指针。

```cpp
destructive_copy_smartptr <SampleClass> smartPtr (new SampleClass ());
SomeFunc (smartPtr); // Ownership transferred to SomeFunc
// Don't use smartPtr in the caller any more!
```

虽然破坏性复制机制使用起来并不直观，但它有一个优点，即可确保任何时刻只有一个活动指针指向对象。因此，它非常适合从函数返回指针以及需要利用其“破坏性”的情形。

一个破坏性复制智能指针的例子：

```cpp
template <typename T>
class destructive_copy_smartptr
{
public:
    destructive_copy_smartptr(T* p = nullptr) : _ptr(p) {}
    ~destructive_copy_smartptr() { delete _ptr; }
  
    // 接收的参数并非const类型，是为了实现破坏性复制
    destructive_copy_smartptr& operator=(destructive_copy_smartptr& other)
    {
        _ptr = other._ptr;
        // 赋值后，将外部的原指针设为nullptr
        other._ptr = nullptr;
        return *this;
    }

    destructive_copy_smartptr(destructive_copy_smartptr& other)
    {
        _ptr = other._ptr;
        other._ptr = nullptr;
    }

private:
    T* _ptr;
};
```

不同于大多数 C++类，该智能指针类的复制构造函数和赋值运算符不能接受 const 引用，因为它在复制源引用后使其无效。这不仅不符合传统复制构造函数和赋值运算符的语义，还让智能指针类的用法不直观。复制或赋值后销毁源引用不符合预期。鉴于这种智能指针销毁源引用，这也使得它不适合用于 STL 容器，如 `std::vector` 或其他任何动态集合类。这些容器需要在内部复制内容，这将导致指针失效。由于种种原因，不在程序中使用破坏性复制智能指针是明智的选择。

#### 使用 std::unique_ptr
C++标准一直支持 auto_ptr，它是一种基于破坏性复制的智能指针。C++11 终于摒弃了该智能指针，现在您应使用 `std::unique_ptr`。

unique_ptr 是一种简单的智能指针，但其复制构造函数和赋值运算符被声明为私有的，因此不能复制它，即不能将其按值传递给函数，也不能将其赋给其他指针。

要使用 `std:unique_ptr` ，必须包含头文件`<memory>`：

```cpp
#include <memory> 
```

使用举例：

```cpp
#include <iostream>
#include <memory>
using namespace std;

class Fish
{
  public:
    Fish() { cout << "Fish constructor" << endl; }
    ~Fish() { cout << "Fish destructor" << endl; }
    void Swim() { cout << "Fish swim" << endl; }
};

void MakeFishSwim(const unique_ptr<Fish>& inFish)
{
    inFish->Swim();
}

int main()
{
    unique_ptr<Fish> pFish(new Fish);
    pFish->Swim();

    MakeFishSwim(pFish);

    unique_ptr<Fish> pFish2;
    // error: operator= is private
    // pFish2 = pFish;

    return 0;
}
```

可以看到，pFish指向的对象是在main函数中创建的，当main函数结束时，pFish指向的对象会自动销毁，无需手动调用delete。总之，unique_ptr 比 C++11 已摒弃的 auto_ptr 更安全，因为复制和赋值不会导致源智能指针对象无
效。它在销毁时释放对象。

unique_ptr 支持移动语义，即可以将一个 unique_ptr 移动到另一个 unique_ptr 中。移动语义可以避免复制对象，提高效率。

移动语义的使用举例：

```cpp
#include <iostream>
using namespace std;

int main()
{
  unique_ptr<int> ptr1(new int(1));
  cout << *ptr1 << endl;
  cout << ptr1.get() << endl;

  unique_ptr<int> ptr2 = move(ptr1);
  cout << *ptr2 << endl;
  cout << ptr2.get() << endl;

  // 移动后，ptr1 不再指向原对象，而是由ptr2指向这个对象
  // ptr1 指向 nullptr
  if(ptr1)
  {
    cout << *ptr1 << endl;
  } 
  else
  {
    cout << "ptr1 is null" << endl;
  }

  return 0;
}
```

#### 深受欢迎的三方智能指针库
显然，C++标准库提供的智能指针并不能满足所有程序员的需求，这就是还有很多其他智能指针库的原因。

Boost（www.boost.org）提供了一些经过测试且文档完善的智能指针类，还有很多其他的实用类。

有关 Boost 智能指针的更详细信息，请访问 http://www.boost.org/libs/ smart_ptr/smart_ptr.htm，在这里还可下载相关的库。

## 使用流进行输入和输出
