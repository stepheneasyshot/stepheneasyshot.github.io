---
layout: post
description: > 
  本文记录了我学习C++的一些基础条目知识
image: 
  path: /assets/img/blog/blogs_cpp.png
  srcset: 
    1920w: /assets/img/blog/blogs_cpp.png
    960w:  /assets/img/blog/blogs_cpp.png
    480w:  /assets/img/blog/blogs_cpp.png
accent_image: /assets/img/blog/blogs_cpp.png
excerpt_separator: <!--more-->
sitemap: false
---
# C++基础记录（三）
本文是C++扫盲的第三篇记录，从STL位标志往后的一些进阶内容。

前面的相关文章：

[C++基础记录](./2024-9-25-C++基础记录.md)
[C++基础记录（二）](./2025-8-18-C++基础记录（二）.md)

[【算法刷题】C++常见容器使用集合](./2025-4-5-【算法刷题】C++常见容器使用集合.md)

## STL位标志
### bitset
`std::bitset` 是 C++ 标准库中一个非常实用的类，它提供了一种管理和操作固定大小的位的集合（bit set）的方式。你可以把它想象成一个数组，但这个数组的每个元素都只能是 0 或 1。

> 从低位到高位是从右往左数，第 0 位是最右边的位。

主要特点：
* 固定大小: std::bitset 的大小在编译时就确定了。你需要用一个模板参数来指定它能存储多少位，例如 std::bitset<32> 表示一个能存储 32 位的 bit set。
* 高效: 因为大小是固定的，它在内存中通常会以一个或多个无符号整数的形式存储，这使得位操作（如位移、按位与、或、异或等）非常高效。
* 方便的接口: 它提供了很多方便的方法来操作和查询位，比如设置、清零、翻转、测试特定位等。

### 实例化 std::bitset
实例化这个模板类时，必须通过一个模板参数指定实例需要管理的位数：

```cpp
bitset <4> fourBits; // 4 bits initialized to 0000
```

还可将 bitset 初始化为一个用字符串字面量（char*）表示的位序列：

```cpp
bitset <5> fiveBits("10101"); // 5 bits 10101
```

使用一个 bitset 来实例化另一个 bitset 非常简单：

```cpp
bitset <8> fiveBitsCopy(fiveBits); 
```

使用实例：

```cpp
#include <iostream>
#include <bitset>
using namespace std;
int main() {
  // 创建一个 4 位的 bitset
  bitset<4> fourBits; // 4 bits initialized to 0000
  // 创建一个 5 位的 bitset
  bitset<5> fiveBits("10101"); // 5 bits 10101
  // 创建一个 8 位的 bitset
  bitset<8> eightBits(255); // 8 bits 11111111
  // 创建一个 8 位的 bitset 副本
  bitset <8> eightBitsCopy(eightBits); 
  
  return 0;
}
```

### bitset运算符
`std::bitset` 提供了多种运算符来进行位操作，这些运算符使得对位集合的操作变得非常直观和高效。以下是一些常用的运算符：

| 运算符 | 描述 |
| --- | --- |
| << | 将位序列的文本表示插入到输出流中|
| >> | 将一个字符串插入到bitset对象中 |
| ~ | 按位取反 |
| & | 按位与 |
| \| | 按位或 |
| ^ | 按位异或 |
| <<= | 左移，例如左移两位 fourBits <<= 2; |
| >>= | 右移 |
| [] | 访问特定位 |

使用举例：

```cpp
#include <iostream>
#include <bitset>

using namespace std;

int main() {
    bitset<8> b1(1);
    // 00000001
    b1 <<= 2;
    // 左移两位，变为 00000100
    cout << "b1 after left shift by 2: " << b1 << endl;
    return 0;
}
```

取反：

```cpp
#include <iostream>
#include <bitset>
using namespace std;

int main() {
    bitset<8> b1(5); // 00000101
    cout << "b1: " << b1 << endl;
    cout << "b1 after NOT: " << ~b1 << endl; // 11111010
    return 0;
}
```

### bitset成员方法
| 函数 | 描述 |
| --- | --- |
| set() | 将序列中的所有位都设置为 1 |
| set (N, val=1) | 将第 N+1 位设置为 val 指定的值（默认为 1） |
| reset() | 将序列中的所有位都重置为 0 |
| reset (N) | 将偏移位置为（N+1）的位清除 |
| flip() | 将位序列中的所有位取反 |
| size() | 返回序列中的位数 |
| count() | 返回序列中值为 1 的位数 |

使用举例：

```cpp
#include <iostream>
#include <bitset>
using namespace std;

int main() {
    bitset<8> b1(5); // 00000101
    cout << "b1: " << b1 << endl;
    b1.set(2); // 将第 3 位设置为 1
    cout << "b1 after set(2): " << b1 << endl;
    b1.reset(2); // 将第 3 位设置为 0
    cout << "b1 after reset(2): " << b1 << endl;
    b1.flip(); // 取反
    cout << "b1 after flip(): " << b1 << endl;
    return 0;
}
```

## `vector<bool>`
STL bitset 的缺点之一是不能动态地调整长度。仅当在编辑阶段知道序列将存储多少位时才能使用 bitset。
为了克服这种缺点，STL 向程序员提供了 `vector<bool>` 类（在有些 STL 实现中为bit_vector）。

实例化 `vector<bool>` 的方式与实例化 `vector` 类似，有一些方便的重载构造函数可供使用：

```cpp
vector <bool> boolFlags1;
```

例如，可创建一个这样的 vector，即它最初包含 10 个布尔元素，且每个元素都被初始化为 1（即true）：

```cpp
vector <bool> boolFlags2 (10, true);
```

还可使用一个 `vector<bool>` 创建另一个 `vector<bool>`：

```cpp
vector <bool> boolFlags2Copy (boolFlags2); 
```

### `vector<bool>` 成员方法和运算符
`vector<bool>`提供了函数 `flip()`，用于将序列中的布尔值取反，这与函数 `bitset<>::flip()` 很像。

除这个方法外，`vector<bool>` 与 `std::vector` 极其相似，例如，可使用 `push_back` 将标志位插入到序列中。

使用举例：

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<bool> vb(3);
    vb[0] = true;
    vb[1] = false;
    vb[2] = true;
    vb.push_back(true);
    
    for (int i = 0; i < vb.size(); i++)
    {
        cout << vb[i] << endl;
    }

    vb.flip();
    cout << "After flip:" << endl;
    for (int i = 0; i < vb.size(); i++)
    {
        cout << vb[i] << endl;
    }

    return 0;
}
```

一开始写作了：

```cpp
vector<bool> vb;
vb[0] = true;
// 为指定大小，就直接使用0位，严重错误，直接越界
// 可以先初始化大小，或者先push_back添加元素，再修改对应位置
// 也可以使用初始化列表： vector <bool> boolFlags{ true, true, false }
```

