---
layout: post
description: > 
  本文记录了我学习C++的一些基础条目知识
image: 
  path: /assets/img/blog/blogs_cpp.png
  srcset: 
    1920w: /assets/img/blog/blogs_cpp.png
    960w:  /assets/img/blog/blogs_cpp.png
    480w:  /assets/img/blog/blogs_cpp.png
accent_image: /assets/img/blog/blogs_cpp.png
excerpt_separator: <!--more-->
sitemap: false
---
# C++基础记录（三）
本文是C++扫盲的第三篇记录，从STL位标志往后的一些进阶内容。

前面的相关文章：

[C++基础记录](./2024-9-25-C++基础记录.md)
[C++基础记录（二）](./2025-8-18-C++基础记录（二）.md)

[【算法刷题】C++常见容器使用集合](./2025-4-5-【算法刷题】C++常见容器使用集合.md)

## STL位标志
### bitset
`std::bitset` 是 C++ 标准库中一个非常实用的类，它提供了一种管理和操作固定大小的位的集合（bit set）的方式。你可以把它想象成一个数组，但这个数组的每个元素都只能是 0 或 1。

> 从低位到高位是从右往左数，第 0 位是最右边的位。

主要特点：
* 固定大小: std::bitset 的大小在编译时就确定了。你需要用一个模板参数来指定它能存储多少位，例如 std::bitset<32> 表示一个能存储 32 位的 bit set。
* 高效: 因为大小是固定的，它在内存中通常会以一个或多个无符号整数的形式存储，这使得位操作（如位移、按位与、或、异或等）非常高效。
* 方便的接口: 它提供了很多方便的方法来操作和查询位，比如设置、清零、翻转、测试特定位等。

### 实例化 std::bitset
实例化这个模板类时，必须通过一个模板参数指定实例需要管理的位数：

```cpp
bitset <4> fourBits; // 4 bits initialized to 0000
```

还可将 bitset 初始化为一个用字符串字面量（char*）表示的位序列：

```cpp
bitset <5> fiveBits("10101"); // 5 bits 10101
```

使用一个 bitset 来实例化另一个 bitset 非常简单：

```cpp
bitset <8> fiveBitsCopy(fiveBits); 
```

使用实例：

```cpp
#include <iostream>
#include <bitset>
using namespace std;
int main() {
  // 创建一个 4 位的 bitset
  bitset<4> fourBits; // 4 bits initialized to 0000
  // 创建一个 5 位的 bitset
  bitset<5> fiveBits("10101"); // 5 bits 10101
  // 创建一个 8 位的 bitset
  bitset<8> eightBits(255); // 8 bits 11111111
  // 创建一个 8 位的 bitset 副本
  bitset <8> eightBitsCopy(eightBits); 
  
  return 0;
}
```

### bitset运算符
`std::bitset` 提供了多种运算符来进行位操作，这些运算符使得对位集合的操作变得非常直观和高效。以下是一些常用的运算符：

| 运算符 | 描述 |
| --- | --- |
| << | 将位序列的文本表示插入到输出流中|
| >> | 将一个字符串插入到bitset对象中 |
| ~ | 按位取反 |
| & | 按位与 |
| \| | 按位或 |
| ^ | 按位异或 |
| <<= | 左移，例如左移两位 fourBits <<= 2; |
| >>= | 右移 |
| [] | 访问特定位 |

使用举例：

```cpp
#include <iostream>
#include <bitset>

using namespace std;

int main() {
    bitset<8> b1(1);
    // 00000001
    b1 <<= 2;
    // 左移两位，变为 00000100
    cout << "b1 after left shift by 2: " << b1 << endl;
    return 0;
}
```

取反：

```cpp
#include <iostream>
#include <bitset>
using namespace std;

int main() {
    bitset<8> b1(5); // 00000101
    cout << "b1: " << b1 << endl;
    cout << "b1 after NOT: " << ~b1 << endl; // 11111010
    return 0;
}
```

### bitset成员方法
| 函数 | 描述 |
| --- | --- |
| set() | 将序列中的所有位都设置为 1 |
| set (N, val=1) | 将第 N+1 位设置为 val 指定的值（默认为 1） |
| reset() | 将序列中的所有位都重置为 0 |
| reset (N) | 将偏移位置为（N+1）的位清除 |
| flip() | 将位序列中的所有位取反 |
| size() | 返回序列中的位数 |
| count() | 返回序列中值为 1 的位数 |

使用举例：

```cpp
#include <iostream>
#include <bitset>
using namespace std;

int main() {
    bitset<8> b1(5); // 00000101
    cout << "b1: " << b1 << endl;
    b1.set(2); // 将第 3 位设置为 1
    cout << "b1 after set(2): " << b1 << endl;
    b1.reset(2); // 将第 3 位设置为 0
    cout << "b1 after reset(2): " << b1 << endl;
    b1.flip(); // 取反
    cout << "b1 after flip(): " << b1 << endl;
    return 0;
}
```

## `vector<bool>`
STL bitset 的缺点之一是不能动态地调整长度。仅当在编辑阶段知道序列将存储多少位时才能使用 bitset。
为了克服这种缺点，STL 向程序员提供了 `vector<bool>` 类（在有些 STL 实现中为bit_vector）。

实例化 `vector<bool>` 的方式与实例化 `vector` 类似，有一些方便的重载构造函数可供使用：

```cpp
vector <bool> boolFlags1;
```

例如，可创建一个这样的 vector，即它最初包含 10 个布尔元素，且每个元素都被初始化为 1（即true）：

```cpp
vector <bool> boolFlags2 (10, true);
```

还可使用一个 `vector<bool>` 创建另一个 `vector<bool>`：

```cpp
vector <bool> boolFlags2Copy (boolFlags2); 
```

### `vector<bool>` 成员方法和运算符
`vector<bool>`提供了函数 `flip()`，用于将序列中的布尔值取反，这与函数 `bitset<>::flip()` 很像。

除这个方法外，`vector<bool>` 与 `std::vector` 极其相似，例如，可使用 `push_back` 将标志位插入到序列中。

使用举例：

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<bool> vb(3);
    vb[0] = true;
    vb[1] = false;
    vb[2] = true;
    vb.push_back(true);
    
    for (int i = 0; i < vb.size(); i++)
    {
        cout << vb[i] << endl;
    }

    vb.flip();
    cout << "After flip:" << endl;
    for (int i = 0; i < vb.size(); i++)
    {
        cout << vb[i] << endl;
    }

    return 0;
}
```

一开始写作了：

```cpp
vector<bool> vb;
vb[0] = true;
```

没有指定大小，就直接使用 0 位，严重错误，直接越界。 **需要养成声明即初始化的好习惯** ，使用前确定大小。

可以先初始化大小，或者先push_back添加元素，再修改对应位置。也可以使用初始化列表： `vector <bool> boolFlags{ true, true, false }` .

## 智能指针
C++在内存分配、释放和管理方面具有其他语言不具备的灵活性。同时这种松散的机制也会引发一些不确定性。

例如：

```cpp
SomeClass* ptrData = anObject.GetData ();
/*
 Questions: Is object pointed by ptrData dynamically allocated using new?
 If so, who calls delete? Caller or the called?
 Answer: No idea!
*/
ptrData->DoSomething();
```

在上述代码中，没有显而易见的方法获悉 ptrData 指向的内存：
* 是否是从堆中分配的，因此最终需要释放；
* 是否由调用者负责释放；
* 对象的析构函数是否会自动销毁该对象。

### 优势
智能指针可以自动管理动态分配的内存，避免内存泄漏和悬空指针等问题。

```cpp
smart_pointer<SomeClass> spData = anObject.GetData ();
// Use a smart pointer like a conventional pointer!
spData->Display ();
(*spData).Display ();
// Don't have to worry about de-allocation
// (the smart pointer's destructor does it for you)
```

智能指针的行为类似常规指针（这里将其称为原始指针），但通过重载的运算符和析构函数确保动态分配的数据能够及时地销毁，从而提供了更多有用的功能。

智能指针类重载了 **解除引用运算符（*）** 和 **成员选择运算符（->）** ，让程序员可以像使用常规指针那样使用智能指针。

### 一个简单的智能指针类
代码如下：

```cpp
template <typename T>
class smart_pointer
{
  private:
    T* ptr;
  public:
    smart_pointer(T* p = nullptr) : ptr(p) {}
    ~smart_pointer() { delete ptr; }
    T& operator*() { return *ptr; }
    T* operator->() { return ptr; }
    // copy constructor
    smart_pointer(const smart_pointer& sp) : ptr(sp.ptr) {}
    // assignment operator
    smart_pointer& operator=(const smart_pointer& sp)
    {
        if (this != &sp)
        {
            delete ptr;
            ptr = sp.ptr;
        }
        return *this;
    }
};
```

实现了 `*` 和 `->` 运算符，从而可以像常规意义上的指针那样使用它。

### 插入：内存管理策略
使智能指针真正“智能”的是复制构造函数、赋值运算符和析构函数的实现，它们决定了智能指针对象被传递给函数、赋值或离开作用域（即像其他类对象一样被销毁）时的行为。
#### 深复制
回顾一下切除问题：

```cpp
void MakeFishSwim(Fish aFish)
{
    aFish.swim();
}

...

Carp carp1;
MakeFishSwim(carp1);
// Slicing: only the Fish part of Carp is sent to MakeFishSwim() 

Tuna tuna1;
MakeFishSwim(tuna1);
```

下面实例，使用基于深复制的智能指针将多态对象作为基类对象进行传递：

```cpp
template <typename T>
class deepcopy_smart_ptr
{
  private:
    T* ptr;
    // copy constructor
    deepcopy_smart_ptr(const deepcopy_smart_ptr& source)
    {
      ptr = source->Clone();
    }
    // assignment operator
    deepcopy_smart_ptr& operator=(const deepcopy_smart_ptr& source)
    {
        if (ptr)
        {
            delete ptr;
        }
        ptr = source->Clone();
        return *this;
    }
};
```

实现了一个复制构造函数，使得能够通过函数 `Clone()` 函数对多态对象进行深复制—类必须实现函数 `Clone()` 。另外，它还实现了复制赋值运算符，为了简单起见，这里假设基类 Fish 实现的虚函数为 `Clone()` 。通常，实现深复制模型的智能指针通过模板参数或函数对象提供该函数。下面是 `deepcopy_smart_ptr` 的一种用法：

```cpp
deepcopy_smart_ptr<Carp> freshWaterFish(new Carp);
MakeFishSwim (freshWaterFish); // Carp will not be 'sliced' 
```

#### 写时复制（Copy on Write）
COW是一种优化策略，它推迟了资源的复制操作。当你有两个对象共享同一份数据时，COW会让你在第一次**修改**数据时才真正地去复制它。
##### COW的核心思想
想象一下，你有一个`std::string`对象，叫`s1`，里面存着一段很长的文本。现在你想要用`s1`去初始化另一个`std::string`对象`s2`：

```cpp
std::string s1 = "这是一段很长的文本...";
std::string s2 = s1; // 理论上s2是s1的一个拷贝
```

如果`std::string`使用了COW，那么在这一步，`s2`并不会立刻复制`s1`的数据。相反，`s1`和`s2`会共享同一份底层数据。为了实现这一点，通常会有一个引用计数（reference count）来记录有多少个对象正在共享这份数据。在这个例子中，这份数据的引用计数会从1增加到2。
##### 什么时候会触发复制？
复制操作只会在你试图修改其中一个对象时发生。比如，你想修改`s2`：

```cpp
s2 += "，后面又加了一些新内容。"; // 触发写时复制
```

在你执行这行代码时，系统会检查`s2`所指向的数据的引用计数。因为它大于1，所以系统会：

1.  为`s2`分配一块新的内存。
2.  将原始数据（“这是一段很长的文本...”）从旧地址复制到新地址。
3.  让`s2`指向这份新数据。
4.  将原始数据的引用计数减1。
5.  最后，将新内容添加到`s2`的新数据中。

##### 智能指针的COW应用
写时复制机制（Copy on Write，COW）试图对深复制智能指针的性能进行优化，它共享指针，直到首次写入对象。首次调用非 const 函数时，COW 指针通常为该非 const 函数操作的对象创建一个副本，而其他指针实例仍共享源对象。

COW 深受很多程序员的喜欢。实现 const 和非 const 版本的运算符*和->，是实现 COW 指针功能的关键。非 const 版本用于创建副本。

重要的是，选择 COW 指针时，在使用这样的实现前务必理解其实现细节。否则，复制时将出现复制得太少或太多的情况。

#### 引用计数智能指针

