---
layout: post
description: > 
  本文记录了我学习C++的一些进阶知识
image: 
  path: /assets/img/blog/blogs_cpp.png
  srcset: 
    1920w: /assets/img/blog/blogs_cpp.png
    960w:  /assets/img/blog/blogs_cpp.png
    480w:  /assets/img/blog/blogs_cpp.png
accent_image: /assets/img/blog/blogs_cpp.png
excerpt_separator: <!--more-->
sitemap: false
---
# C++基础进阶
本文是C++基础学习完成的进阶记录，一些高阶技法和基础补齐

前面的相关文章：

[C++基础记录](./2024-9-25-C++基础记录.md)

[C++基础记录（二）](./2025-8-18-C++基础记录（二）.md)

[C++基础记录（三）](./2025-8-21-C++基础记录（三）.md)

[【算法刷题】C++常见容器使用集合](./2025-4-5-【算法刷题】C++常见容器使用集合.md)

## 处理器
时钟频率（Clock Speed）和内核数量（Core Count）是衡量处理器性能的两个关键指标，它们对 C++ 程序的性能影响很大，但方式各不相同。理解这两者如何协同工作，能帮助你更好地优化程序。

### 时钟频率对C++程序性能的影响

时钟频率通常以千兆赫兹（GHz）为单位，它 **决定了处理器每个内核每秒能执行多少个操作** 。一个 3.0 GHz 的处理器，意味着处理器每秒有 3.0×10 
9 个时钟周期（或脉冲）。

一个时钟周期并不总是对应一条指令。现代处理器为了提高效率，通常会在一个时钟周期内执行多条指令，或者一条复杂的指令会占用多个时钟周期。

IPC (Instructions Per Cycle) 也是衡量处理器效率的关键指标。IPC 表示每个时钟周期可以执行的指令数量。一个 IPC 大于 1 的处理器比 IPC 小于 1 的处理器更高效。不同的处理器架构（如 x86, ARM）、不同的指令集和不同的程序代码，IPC 值都会有很大差异。

* **单线程性能：** 对于**单线程**的 C++ 程序，时钟频率是决定性能的最主要因素。因为程序的所有计算都集中在一个内核上，更高的时钟频率意味着每个指令的执行时间更短，程序的运行速度就越快。
* **不适合的场景：** 尽管时钟频率很重要，但它并不是万能的。如果你的程序瓶颈在于 I/O 操作（比如读写文件或网络通信），或者内存访问速度，单纯提高时钟频率的效果就不那么明显了。

**总结：** 时钟频率直接影响 C++ 程序中**串行执行部分**的性能。如果你的代码大部分是顺序执行的，没有很好地利用并行化，那么提高时钟频率会带来显著的性能提升。

### 内核数量对C++程序性能的影响
内核数量指的是一个处理器中独立处理单元的数量。每个内核都可以独立执行任务。

![](/assets/img/blog/blogs_multi_core_cpu.png)

* **多线程性能：** 内核数量主要影响**多线程** C++ 程序的性能。如果你使用如 `std::thread`、`OpenMP` 或 `TBB` 这样的技术，将任务分解成多个可以并行执行的部分，那么更多的内核就能同时处理更多的任务，从而大幅缩短总运行时间。
* **并行化是关键：** 要利用多核的优势，你的程序必须是**可并行化**的。如果你的算法本身就是串行的（比如一个简单的循环没有依赖性），那么增加再多的内核也无济于事，因为它只能在一个内核上运行。
* **并非越多越好：** 尽管多核能提升性能，但多线程编程也引入了新的挑战，比如**同步（Synchronization）**、**锁竞争（Lock Contention）**和**数据共享**等问题。如果处理不好，这些开销反而可能导致性能下降。例如，两个线程频繁地争抢同一个锁，它们可能会大部分时间都处于等待状态，而不是真正地执行计算。

**总结：** 内核数量决定了你的 C++ 程序能够**并行处理任务的能力**。要充分利用多核优势，你需要设计并实现能有效并行化的算法。

## 多线程
应用程序代码总是运行在线程中。线程是一个同步执行实体，其中的语句依次执行。可将 main( )的代码视为在应用程序的主线程中执行。在这个主线程中，可以创建并行运行的线程。如果应用程序除主线程外，还包含一个或多个并行运行的线程，则被称为多线程应用程序。

线程的创建方式由操作系统决定，您可直接调用操作系统提供的 API 来创建线程。

> 从 C++11 起，C++规定由线程函数负责为您调用操作系统 API，这提高了多线程应用程序的可移植性。如果您编写的应用程序将在特定操作系统上运行，请了解该操作系统提供的用于编写多线程应用程序的 API。

创建线程的方式随操作系统而异，C++在头文件`<thread>`中提供了 `std::thread`，它隐藏了与平台相关的细节。如果您针对特定平台编写应用程序，最好只使用针对该操作系统的线程函数。编写 C++应用程序时，如果您希望其中的线程是可移植的，请务必了解[Boost 线程库](www.boost.org)

### 简单方法示例

```cpp
#include <iostream>
#include <thread>

void PrintStrings() {
    for (int i = 0; i < 5; i++) {
        std::cout << "Hello, World! from thread " << std::endl;
    }
}

int main() {
    std::thread t(PrintStrings);
    t.join();
    for (int i = 0; i < 5; i++) {
        std::cout << "Hello, World! from main()" << std::endl;
    }
    return 0;
}
```

按照java的理解写出上述代码，期望看到两个线程交替打印。

**问题** ：子线程内部打印完了才往下执行main内的打印。

**原因** ： `t.join()` 的作用是阻塞（block）主线程 main()，让它停下来，等待子线程 t 执行完毕。只有当子线程 t 中的 PrintStrings() 函数完全执行完成、线程终止后，main() 函数才会继续执行 t.join() 后面的代码，也就是你看到的第二个 for 循环。

解决思路就是弄清楚线程是什么时候开始执行的。

尝试将 `join()` 移到最后，但是这次是main中的打印全部完成，再开启子线程的打印。

**原因** ：在多线程程序中，操作系统负责在不同的线程之间切换，分配 CPU 时间片。虽然理论上主线程和子线程是并行运行的，但实际的执行顺序取决于操作系统的调度器。在更改 `join()` 位置后的代码中，main 线程创建子线程 t 之后，它会立即执行它自己的 for 循环。而子线程 t 什么时候真正开始运行，取决于操作系统什么时候给它分配 CPU 时间。对于一个相对简单的程序，main 线程通常会因为其优先级或调度策略的缘故，在创建子线程后立即获得 CPU 时间片，并执行自己的任务。在这个极短的时间内，main 线程的 for 循环可能已经全部执行完毕，甚至在子线程有机会开始运行之前。

**解决** ：两个线程的循环中插入延时， `std::this_thread::sleep_for()` 函数会让当前线程进入休眠，并主动放弃对 CPU 的占用。当 main 线程执行到 sleep_for 时，它会暂停一段时间，给操作系统一个机会去调度其他就绪的线程（比如你的子线程）。当主线程休眠结束后，它和子线程就会进入竞争状态，从而更有可能产生交替执行的效果。

```cpp
#include <iostream>
#include <thread>

using namespace std;

void PrintStrings() {
    for (int i = 0; i < 5; i++) {
        cout << "Hello, World! from thread " << endl;
        // 让出CPU
        this_thread::sleep_for(chrono::milliseconds(10)); 
    }
}

int main() {
    thread t(PrintStrings);
    for (int i = 0; i < 5; i++) {
        cout << "Hello, World! from main()" << endl;
        // 让出CPU
        this_thread::sleep_for(chrono::milliseconds(10));  
    }
    t.join();
    return 0;
}
```

### 多线程的必要性
使用多线程技术的应用程序并行地执行特定任务的多个会话（session）。假设有 10000 名用户在Amazon 购物，您是其中的一员。Amazon 的 Web 服务器当然不会让其他 9999 位用户都等待，而是创建多个同时为用户服务的线程。如果该 Web 服务器运行在多核处理器或多处理器云上，这些线程将能够充分利用基础设施，向用户提供最佳的性能。

另一个常见的多线程示例是，与用户交互（例如，通过进度条）的同时做其他工作的应用程序。这样的应用程序通常包含用户界面线程和工作线程，其中前者负责显示和更新用户界面以及接受用户输入，而后者在后台完成其任务。磁盘碎片整理工具就是一个这样的应用程序。用户单击“开始”按钮后，将创建一个工作线程，负责扫描和整理磁盘碎片；与此同时，用户界面线程将显示进度，并提供取消碎片整理的选项。为了让用户界面线程显示进度，整理碎片的工作线程需要定期地提供进度；同样，为了让工作线程在用户撤销时停止工作，用户界面线程需要提供这种信息。

* 多线程应用程序常常要求线程彼此通信，这样应用程序才能成为一个整体，而不是一系列互不关心、各自为政的线程。
* 另外，顺序也很重要，您不希望用户界面线程在负责整理碎片的工作线程之前结束。在有些情况下，一个线程需要等待另一个线程。例如，读取数据库的线程应等待写入数据库的线程结束。
* 让一个线程等待另一个线程被称为线程同步。

### 线程数据通信
线程可共享变量，可访问全局数据。创建线程时，可给它提供一个指向共享对象（结构或类）的指针。

![](/assets/img/blog/blogs_cpp_thread_data_share.png)

线程将数据写入其他线程能够存取的内存单元，这让线程能够共享数据，从而彼此进行通信。在磁盘碎片整理工具中，工作线程知道进度，而用户界面线程需要获悉这种信息；工作线程定期地存储进度（用整数表示的百分比），而用户界面线程可使用它来显示进度。

这种情形非常简单：一个线程创建信息，另一个线程使用它。如果多个线程读写相同的内存单元，结果将如何呢？有些线程开始读取数据时，其他线程可能还未结束写入操作，这将给数据的完整性带来威胁。这就是需要同步线程的原因所在。

### 使用互斥量和信号量同步线程
线程是操作系统级实体，而用来同步线程的对象也是操作系统提供的。大多数操作系统都提供了信号量（semaphore）和互斥量（mutex），供您用来同步线程。
互斥量（互斥同步对象）通常用于避免多个线程同时访问同一段代码。换句话说，互斥量指定了一段代码，其他线程要执行它，必须等待当前执行它的线程结束并释放该互斥量。接下来，下一个线程获取该互斥量，完成其工作，并释放该互斥量。从 C++11 起，C++通过类 std::mutex 提供了一种互斥量实现，这个类位于头文件 `<mutex>` 中。

通过使用信号量，可指定多少个线程可同时执行某个代码段。只允许一个线程访问的信号量被称为二值信号量（binary semaphore）。

### 多线程技术带来的问题
要使用多线程技术，必须妥善地同步线程，否则，您将有大量的无眠之夜。多线程应用程序面临的问题很多，下面是最常见的两个。

**竞争状态** ：多个线程试图写入同一项数据。哪个线程获胜？该对象处于什么状态？
**死锁** ：两个线程彼此等待对方结束，导致它们都处于“等待”状态，而应用程序被挂起。

妥善地同步可避免竞争状态。一般而言，线程被允许写入共享对象时，您必须格外小心，确保：

* 每次只能有一个线程写入；
* 在当前执行写入的线程结束前，不允许其他线程读取该对象。

通过确保任何情况下都不会有两个线程彼此等待，可避免死锁。为此，可使用主线程同步工作线程，也可在线程之间分配任务时，确保工作负荷分配明确。可以让一个线程等待另一个线程，但绝不要同时让后者也等待前者。

要学习多线程编程，可参阅大量有关该主题的在线文档，也可亲自动手实践。一旦掌握了这个主题，就能让 C++应用程序充分利用未来将发布的多核处理器。